<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phrenophobia - Decomposition</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000000; /* Pure Black Void */
      font-family: 'Courier New', Courier, monospace;
      color: #ccff00; /* Bright Bio-Slime Green */
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* UI OVERLAY */
    #overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 100;
      padding: 40px;
      text-align: center;
      background: rgba(10, 15, 5, 0.9); /* Slightly lighter background */
      border: 1px solid #ccff00;
      box-shadow: 0 0 50px rgba(100, 255, 0, 0.2), inset 0 0 30px rgba(20, 40, 0, 0.8);
      clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
      backdrop-filter: blur(4px);
      max-width: 500px;
      width: 90%;
      transition: opacity 0.5s ease;
    }

    h1 {
      font-size: 1.8rem;
      margin: 0 0 10px 0;
      color: #ffaa00; /* Bright Toxic Orange */
      text-shadow: 2px 2px 0px #334400;
      text-transform: uppercase;
      letter-spacing: 4px;
      font-weight: 900;
    }

    h2 {
      font-size: 0.8rem;
      color: #ccff00; /* Bright Slime Green */
      letter-spacing: 3px;
      text-transform: uppercase;
      margin-bottom: 30px;
      border-bottom: 1px solid #ffaa00;
      display: inline-block;
      padding-bottom: 5px;
    }

    .control-group {
      margin-bottom: 25px;
      padding: 20px;
      border: 1px solid #ffaa00;
      background: rgba(30, 20, 0, 0.5); /* Lighter container */
    }

    .btn {
      background: rgba(50, 60, 0, 0.3);
      color: #ffaa00;
      font-family: inherit;
      font-size: 1.0rem;
      font-weight: 700;
      padding: 15px 30px;
      border: 1px solid #ccff00;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 2px;
      transition: all 0.1s ease;
      box-shadow: 0 0 10px rgba(100, 200, 0, 0.2);
      width: 100%;
      margin-top: 10px;
    }

    .btn:hover { background: #ccff00; color: #000; box-shadow: 0 0 20px rgba(150, 255, 0, 0.6); }

    #fileInput { display: none; }

    /* Recording UI */
    #recordContainer {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 150;
      display: none;
      flex-direction: row;
      gap: 15px;
      opacity: 0;
      transition: opacity 0.5s;
    }

    .rec-btn {
      padding: 10px 20px;
      border: 1px solid #ccff00;
      background: #0a1500;
      color: #ccff00;
      font-weight: 600;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      text-transform: uppercase;
      font-size: 0.7rem;
      letter-spacing: 1px;
      transition: all 0.1s;
    }

    #recordButton { background: #331100; color: #ffaa00; min-width: 150px; border: 1px solid #ffaa00; }
    #recordButton:hover { background: #ffaa00; color: #000; }
    #recordButton.recording { animation: pulseWarning 0.2s infinite alternate; }
    #leaveButton:hover { background: #ccff00; color: #000; }

    @keyframes pulseWarning {
      from { box-shadow: 0 0 5px #ffaa00; background: #331100; transform: scale(1.0); }
      to { box-shadow: 0 0 20px #ccff00; background: #553300; transform: scale(1.05); }
    }

    #fullscreenBtn {
      position: fixed;
      top: 15px;
      right: 15px;
      width: 35px;
      height: 35px;
      background: rgba(10, 20, 5, 0.8);
      border: 1px solid #ccff00;
      color: #ffaa00;
      font-size: 18px;
      cursor: pointer;
      z-index: 150;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s;
    }

    #fullscreenBtn:hover { background: #ccff00; color: #000; }
    #message { margin-top: 15px; color: #ffaa00; font-size: 0.8rem; min-height: 1.2em; font-weight: bold; }

    .checkbox-wrapper { display: flex; align-items: center; justify-content: center; gap: 10px; color: #ccff00; margin-top: 15px; font-size: 0.8rem;}
    input[type="checkbox"] { accent-color: #ffaa00; cursor: pointer; }
  </style>
</head>
<body>

<div id="canvas-container"></div>

<button id="fullscreenBtn" title="Toggle Fullscreen">â›¶</button>

<div id="recordContainer">
  <button id="recordButton" class="rec-btn">INITIATE</button>
  <button id="leaveButton" class="rec-btn">ABORT</button>
</div>

<div id="overlay">
  <h1>MICROBIAL</h1>
  <h2>Decomposition</h2>
  <div class="control-group">
    <p style="margin-top:0; color:#ccff00; font-size: 0.75rem; letter-spacing: 1px; margin-bottom: 15px;">INGEST AUDIO</p>
    <button id="selectFileBtn" class="btn">Select Track</button>
    <input type="file" id="fileInput" accept="audio/*">
  </div>

  <div class="checkbox-wrapper">
    <input type="checkbox" id="record4k">
    <label for="record4k">High Definition Nightmare (4K)</label>
  </div>

  <div class="checkbox-wrapper">
    <input type="checkbox" id="autoRecord">
    <label for="autoRecord">Auto-Log Decay</label>
  </div>

  <div id="message"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<!-- FRAGMENT SHADER: FRACTAL PLASMA + CELTIC VINES + BURNING -->
<script type="x-shader/x-fragment" id="fragShader">
  uniform float uTime;
  uniform vec2 uResolution;
  uniform float uBass;
  uniform float uMid;
  uniform float uHigh;
  uniform float uFade;
  uniform float uProgress; // 0.0 to 1.0 song progress

  #define PI 3.14159265359

  // --- NOISE FUNCTIONS ---
  float hash(vec2 p) {
      return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
  }

  // Fractional Brownian Motion
  float noise(vec2 x) {
      vec2 i = floor(x);
      vec2 f = fract(x);
      f = f * f * (3.0 - 2.0 * f);
      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));
      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
  }

  float fbm(vec2 x) {
      float v = 0.0;
      float a = 0.5;
      vec2 shift = vec2(100.0);
      mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));
      for (int i = 0; i < 4; ++i) {
          v += a * noise(x);
          x = rot * x * 2.0 + shift;
          a *= 0.5;
      }
      return v;
  }

  // --- CELTIC KNOT (TRUCHET) FUNCTION ---
  float getVineDist(vec2 p) {
      vec2 grid = fract(p) - 0.5;
      vec2 id = floor(p);
      float check = hash(id);
      if (check > 0.5) grid.x *= -1.0;
      float d1 = abs(length(grid - vec2(0.5)) - 0.5);
      float d2 = abs(length(grid + vec2(0.5)) - 0.5);
      return min(d1, d2);
  }

  // --- PLASMA PALETTE ---
  vec3 palette( in float t ) {
      vec3 a = vec3(0.5, 0.5, 0.5);
      vec3 b = vec3(0.5, 0.5, 0.5);
      vec3 c = vec3(1.0, 1.0, 1.0);
      vec3 d = vec3(0.0, 0.33, 0.67);
      return a + b*cos( 6.28318*(c*t+d) );
  }

  void main() {
      if (uFade >= 1.0) {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
          return;
      }

      vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.y;
      vec2 uv0 = uv;
      vec2 normUV = gl_FragCoord.xy / uResolution.xy;

      // --- 1. ORGANIC FLUID BACKGROUND ---
      vec2 p = uv * 1.2;
      float bgRot = uTime * 0.5 + uBass * 0.3;
      float c = cos(bgRot);
      float s = sin(bgRot);
      p = vec2(p.x * c - p.y * s, p.x * s + p.y * c);

      vec3 finalColor = vec3(0.0);

      for(float i = 1.0; i < 3.5; i++){
          p.x += 0.7 / i * sin(i * 5.0 * p.y + uTime * 0.8 + uBass * 2.5);
          p.y += 0.7 / i * cos(i * 5.0 * p.x + uTime * 0.8 + uMid * 2.5);
      }

      float pattern = sin(p.x * 2.0 + p.y * 2.0 + uTime);
      vec3 bg = palette(pattern * 0.4 + length(uv) * 0.4 + uTime * 0.2);
      bg.r += uBass * 0.5;
      bg.g += uMid * 0.3;
      finalColor = bg * (0.8 + uBass * 0.5);

      // --- 2. VEIN OVERLAY ---
      float r = length(uv);
      float a = atan(uv.y, uv.x);
      float veins = sin(r * 20.0 - uTime * 2.0) * sin(a * 8.0 + uTime);
      veins = smoothstep(0.8, 1.0, veins);
      vec3 veinCol = vec3(0.4, 0.8, 0.0) * uMid + vec3(0.8, 0.0, 0.8) * uHigh;
      finalColor += veinCol * veins;

      // --- 3. CELTIC KNOT VINES & CYCLICAL LOGIC ---

      // CYCLE LOGIC: 3.0 Cycles per song
      float cycleProg = fract(uProgress * 3.0);

      // TRANSITION POINT: 0.6 (60% Growth, 40% Burn)
      float transitionPoint = 0.6;

      // Phases within ONE cycle (0.0 to 1.0)
      // Delay Start: 0.0 to 0.02
      // Grow: 0.02 to 0.6 (Vines creep in)
      // Burn: 0.6 to 1.0 (Long, slow burn)

      // Remap cycleProg: Start growing almost immediately
      float effectiveGrowTime = smoothstep(0.02, transitionPoint, cycleProg);
      float growPhase = effectiveGrowTime;

      // Start burn exactly when growth ends
      float burnPhase = max((cycleProg - transitionPoint) / (1.0 - transitionPoint), 0.0);

      // A. VINE GENERATION (High Density)
      vec2 vineSt = uv0 * 5.0;

      // SLOWER WRITHING
      vec2 q = vec2(fbm(vineSt + 0.02*uTime), fbm(vineSt + vec2(5.2, 1.3) + 0.02*uTime));
      vec2 rCoord = vec2(fbm(vineSt + 4.0*q + vec2(1.7, 9.2)), fbm(vineSt + 4.0*q + vec2(8.3, 2.8)));
      float d = getVineDist(vineSt * 1.5 + 0.8 * rCoord);

      float thickness = 0.14;
      float solidity = smoothstep(thickness, thickness - 0.02, d);
      float hollow = smoothstep(0.04, 0.06, d);
      float vineStructure = solidity * hollow;
      float ridges = sin(d * 100.0);
      vineStructure += ridges * 0.2 * solidity;

      // B. GROWTH MASK (Edges -> In)
      float distFromCenter = length(normUV - 0.5) * 2.5;

      // ADJUSTED THRESHOLDS for Immediate Visibility
      // Start: 1.6 (Corners at ~1.77 are visible immediately)
      // End: -1.4 (Fully covered)
      // Range: 3.0 (Smaller range = Slower movement, satisfying both requests)
      float growThresh = 1.6 - (growPhase * 3.0);
      float growthMask = smoothstep(growThresh, growThresh + 0.8, distFromCenter);

      // C. BURN MASK (Center -> Out)
      float burnNoise = fbm(vineSt * 3.0 + uTime * 0.2);
      float burnMap = distFromCenter * 0.3 + burnNoise * 0.7;

      // Burn level increases with time.
      float currentBurnLevel = burnPhase * 2.5;

      float integrity = smoothstep(currentBurnLevel, currentBurnLevel + 0.2, burnMap);

      // Fire Band
      float fireBand = (1.0 - integrity) * smoothstep(currentBurnLevel - 0.2, currentBurnLevel, burnMap);

      float fireFlicker = fbm(uv * 20.0 + vec2(0.0, uTime * 15.0));
      float fireIntensity = fireBand * 6.0 * (0.6 + 0.4 * fireFlicker);

      // D. COMPOSITING
      float vineOpacity = smoothstep(0.1, 0.9, vineStructure) * growthMask;
      vineOpacity = clamp(vineOpacity * 5.0, 0.0, 1.0);

      // Apply Burn to Opacity
      float finalOpacity = vineOpacity * (integrity + step(0.1, fireIntensity));

      // Vine Colors
      vec3 vineCore = vec3(0.05, 0.25, 0.05);
      vec3 vineEdge = vec3(0.4, 1.0, 0.2);
      float edgeFactor = smoothstep(0.05, 0.15, d);
      vec3 vineCol = mix(vineEdge, vineCore, edgeFactor);
      vineCol += ridges * 0.3;

      // Fire Colors
      vec3 fireCol = vec3(2.5, 0.9, 0.2);
      vec3 ashCol = vec3(0.0, 0.0, 0.0);

      vec3 baseRenderCol = mix(ashCol, vineCol, smoothstep(0.0, 0.2, integrity));
      vec3 finalRenderCol = baseRenderCol + fireCol * fireIntensity;

      // Apply Pulse
      float pulse = 1.0 + uBass * 0.2;

      // Shadows
      float shadow = smoothstep(0.0, 1.0, solidity + 0.1) * growthMask * integrity;
      finalColor *= (1.0 - shadow * 0.85);

      // Final Mix
      finalColor = mix(finalColor, finalRenderCol * pulse, clamp(finalOpacity, 0.0, 1.0));

      finalColor = pow(finalColor, vec3(1.1));

      // --- E. IGNITION FLASH (Red Screen) ---
      // Trigger flash exactly at transitionPoint (0.6)
      float flashTrigger = 1.0 - smoothstep(0.0, 0.04, abs(cycleProg - transitionPoint));
      finalColor = mix(finalColor, vec3(1.0, 0.0, 0.0), flashTrigger * 0.8);

      vec3 fadeColor = vec3(0.0, 0.0, 0.0);
      finalColor = mix(finalColor, fadeColor, uFade);

      gl_FragColor = vec4(finalColor, 1.0);
  }
</script>

<script>
  (function(){
    // --- CONFIG & STATE ---
    let audioContext, analyser, dataArray, sourceNode;
    let renderer, sceneBG, cameraBG, materialBG, meshBG;
    let scene3D, camera3D;
    // sceneHUD removed
    let isRunning = false;
    let currentAudioFile = null;
    let audioDuration = 0;

    // 3D HUD Objects
    let bioCluster, dnaStrand, tunnelRings = [];
    let sporeObj, bacteriaObj;
    let centerNucleus;

    // Optimization Objects
    const colorToxic = new THREE.Color(0x883300);
    const colorSlime = new THREE.Color(0x116600);
    const colorTemp = new THREE.Color();

    // Morphing State
    let nextMorphThreshold = 0.1;
    let morphState = { active: false, start: 0, duration: 5.0, oldMesh: null, newMesh: null };

    // Audio State
    let smoothBass = 0, smoothMid = 0, smoothHigh = 0;
    let lastVolume = 0;
    let maxBass = 0.5, maxMid = 0.5, maxHigh = 0.5;

    // Fading State
    let isFading = false;
    let fadeStartTime = 0;
    let fadeCompleteTime = 0;
    const FADE_DURATION = 3.0;
    const END_BUFFER = 1.0;

    // Recording
    let mediaRecorder;
    let recordedChunks = [];
    let isRecording = false;
    let was4k = false;

    let optimalBands = {
      bass: [0, 10],
      mid: [10, 80],
      high: [80, 200]
    };

    const container = document.getElementById('canvas-container');
    const overlay = document.getElementById('overlay');
    const fileInput = document.getElementById('fileInput');
    const selectFileBtn = document.getElementById('selectFileBtn');
    const messageDiv = document.getElementById('message');
    const recordBtn = document.getElementById('recordButton');
    const leaveBtn = document.getElementById('leaveButton');
    const recordContainer = document.getElementById('recordContainer');
    const autoRecordCheck = document.getElementById('autoRecord');
    const record4kCheck = document.getElementById('record4k');
    const fullscreenBtn = document.getElementById('fullscreenBtn');

    // --- THREE.JS SETUP ---
    function initThree() {
      if (renderer) { container.innerHTML = ''; }

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, preserveDrawingBuffer: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.autoClear = false;
      container.appendChild(renderer.domElement);

      // 1. BG Scene (Organic Fluid)
      sceneBG = new THREE.Scene();
      cameraBG = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
      const geometry = new THREE.PlaneGeometry(2, 2);
      materialBG = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          uBass: { value: 0.0 },
          uMid: { value: 0.0 },
          uHigh: { value: 0.0 },
          uFade: { value: 0.0 },
          uProgress: { value: 0.0 } // Song progress for Vines
        },
        fragmentShader: document.getElementById('fragShader').textContent,
        depthWrite: false
      });
      meshBG = new THREE.Mesh(geometry, materialBG);
      sceneBG.add(meshBG);

      // 2. 3D Scene (Bio Structures)
      scene3D = new THREE.Scene();
      camera3D = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
      camera3D.position.z = 10;
      create3DInterface();

      // HUD Scene Removed

      container.addEventListener("webglcontextlost", (event) => { event.preventDefault(); resetUI(); }, false);
      container.addEventListener("webglcontextrestored", initThree, false);
      window.addEventListener('resize', onResize);
      onResize();
    }

    function create3DInterface() {
      // MICROBIAL MATERIALS
      const virusMat = new THREE.LineBasicMaterial({ color: 0x660099, transparent: false, opacity: 0.9, linewidth: 2 });
      const slimeMat = new THREE.LineBasicMaterial({ color: 0x116600, transparent: false, opacity: 0.9, linewidth: 2 });
      const coreMat = new THREE.LineBasicMaterial({ color: 0x883300, transparent: false, opacity: 0.9 });

      // 1. BOTTOM LEFT: VIRAL CLUSTER - MEMORY OPTIMIZED
      const clusterGroup = new THREE.Group();

      const coreGeo = new THREE.IcosahedronGeometry(0.7, 0);
      const core = new THREE.LineSegments(new THREE.WireframeGeometry(coreGeo), coreMat);
      clusterGroup.add(core);

      const midGeo = new THREE.IcosahedronGeometry(1.3, 1);
      const midMesh = new THREE.LineSegments(new THREE.WireframeGeometry(midGeo), virusMat);
      clusterGroup.add(midMesh);

      const spikesGeo = new THREE.DodecahedronGeometry(1.8, 0);
      const spikes = new THREE.LineSegments(new THREE.WireframeGeometry(spikesGeo), slimeMat);
      clusterGroup.add(spikes);

      const hyperGeo = new THREE.IcosahedronGeometry(1.5, 2);
      const hyperMesh = new THREE.LineSegments(new THREE.WireframeGeometry(hyperGeo), new THREE.LineBasicMaterial({ color: 0x883300, transparent: true, opacity: 0.0 }));
      clusterGroup.add(hyperMesh);

      scene3D.add(clusterGroup);
      bioCluster = clusterGroup;

      // 2. BOTTOM RIGHT: DNA TANGLE
      const dnaGroup = new THREE.Group();
      const knotGeo = new THREE.TorusKnotGeometry(1.0, 0.3, 100, 16, 2, 5);
      const knot = new THREE.LineSegments(new THREE.WireframeGeometry(knotGeo), virusMat);
      dnaGroup.add(knot);
      const outerRing = new THREE.TorusGeometry(1.8, 0.05, 16, 100);
      const ringMesh = new THREE.LineSegments(new THREE.WireframeGeometry(outerRing), slimeMat);
      ringMesh.rotation.x = Math.PI / 2;
      dnaGroup.add(ringMesh);
      scene3D.add(dnaGroup);
      dnaStrand = dnaGroup;

      // 3. TOP LEFT: SPORE POD
      const sporeGroup = new THREE.Group();
      const sporeCoreGeo = new THREE.IcosahedronGeometry(0.6, 2);
      const sporeCore = new THREE.LineSegments(new THREE.WireframeGeometry(sporeCoreGeo), coreMat);
      sporeGroup.add(sporeCore);
      const starGeo = new THREE.IcosahedronGeometry(1.4, 0);
      const starMesh = new THREE.LineSegments(new THREE.WireframeGeometry(starGeo), slimeMat);
      sporeGroup.add(starMesh);
      const ringGeo = new THREE.TorusGeometry(1.8, 0.02, 16, 50);
      const sporeRing = new THREE.LineSegments(new THREE.WireframeGeometry(ringGeo), virusMat);
      sporeRing.rotation.x = Math.PI / 4;
      sporeGroup.add(sporeRing);
      scene3D.add(sporeGroup);
      sporeObj = sporeGroup;

      // 4. TOP RIGHT: BACTERIA CHAIN
      const bacteriaGroup = new THREE.Group();
      const bacGeo = new THREE.SphereGeometry(0.6, 12, 12);
      const bacWire = new THREE.WireframeGeometry(bacGeo);

      const bac1 = new THREE.LineSegments(bacWire, slimeMat);
      bac1.position.x = -0.9;
      bacteriaGroup.add(bac1);

      const bac2 = new THREE.LineSegments(bacWire, virusMat);
      bac2.position.x = 0;
      bac2.scale.setScalar(1.2);
      bacteriaGroup.add(bac2);

      const bac3 = new THREE.LineSegments(bacWire, slimeMat);
      bac3.position.x = 0.9;
      bacteriaGroup.add(bac3);

      scene3D.add(bacteriaGroup);
      bacteriaObj = bacteriaGroup;


      // 5. CENTER: ARTERIAL TUNNEL
      tunnelRings = [];
      const createPoly = (radius, sides) => {
        const pts = [];
        for(let i=0; i<=sides; i++) {
          const theta = (i/sides) * Math.PI * 2;
          pts.push(new THREE.Vector3(Math.cos(theta)*radius, Math.sin(theta)*radius, 0));
        }
        return new THREE.BufferGeometry().setFromPoints(pts);
      };
      const circleGeo = createPoly(4.0, 32);
      const hexGeo = createPoly(3.5, 6);

      for(let i=0; i<30; i++) {
        const frameMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0 });
        const tunnelGroup = new THREE.Group();
        const frameA = new THREE.Line(circleGeo, frameMat);
        const frameB = new THREE.Line(hexGeo, frameMat);
        frameB.rotation.z = (i % 2 === 0) ? 0 : Math.PI / 6;
        frameB.scale.setScalar(0.85);
        tunnelGroup.add(frameA);
        tunnelGroup.add(frameB);
        tunnelGroup.position.z = - (i * 3);
        tunnelGroup.userData = { rotSpeed: (Math.random() - 0.5) * 0.4 };
        scene3D.add(tunnelGroup);
        tunnelRings.push(tunnelGroup);
      }

      // 6. CENTER: CELL NUCLEUS
      const nucleusGroup = new THREE.Group();
      const nucGeo = new THREE.SphereGeometry(0.8, 16, 16);
      const nucMesh = new THREE.LineSegments(new THREE.WireframeGeometry(nucGeo), coreMat);
      const shellGeo = new THREE.IcosahedronGeometry(1.2, 0);
      const shellMesh = new THREE.LineSegments(new THREE.WireframeGeometry(shellGeo), slimeMat);
      nucleusGroup.add(nucMesh);
      nucleusGroup.add(shellMesh);
      nucleusGroup.position.z = 0;
      scene3D.add(nucleusGroup);
      centerNucleus = nucleusGroup;
    }

    function update3DLayout() {
      if (!camera3D) return;
      const vFOV = THREE.MathUtils.degToRad(camera3D.fov);
      const distance = camera3D.position.z;
      const heightAtZero = 2 * Math.tan(vFOV / 2) * distance;
      const widthAtZero = heightAtZero * camera3D.aspect;

      if (bioCluster) {
        bioCluster.position.x = (-widthAtZero / 2.5);
        bioCluster.position.y = -heightAtZero/4;
      }
      if (dnaStrand) {
        dnaStrand.position.x = (widthAtZero / 2.5);
        dnaStrand.position.y = -heightAtZero/4;
      }
      if (sporeObj) {
        sporeObj.position.x = (-widthAtZero / 2.5);
        sporeObj.position.y = heightAtZero/4;
      }
      if (bacteriaObj) {
        bacteriaObj.position.x = (widthAtZero / 2.5);
        bacteriaObj.position.y = heightAtZero/4;
      }
    }

    function resizeApp(w, h, updateStyle = true) {
      if (!renderer) return;
      renderer.setSize(w, h, updateStyle);

      // No HUD resize needed anymore

      if(materialBG) {
        const drawingSize = new THREE.Vector2();
        renderer.getDrawingBufferSize(drawingSize);
        materialBG.uniforms.uResolution.value.x = drawingSize.x;
        materialBG.uniforms.uResolution.value.y = drawingSize.y;
      }
      if(camera3D) {
        camera3D.aspect = w / h;
        camera3D.updateProjectionMatrix();
      }
      update3DLayout();
    }

    function onResize() {
      if(isRecording && was4k) return;
      resizeApp(window.innerWidth, window.innerHeight, true);
    }

    // --- HUD REMOVED ---

    function initAudio() {
      if(!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
      } else if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
    }

    // --- AUTO-GAIN SYSTEM ---
    function getAudioData() {
      if(!analyser) return { bass:0, mid:0, high:0, stats: {db: -100, hz: 0, flux: 0} };
      analyser.getByteFrequencyData(dataArray);

      const len = dataArray.length;
      const avg = (start, end) => {
        let sum = 0;
        let count = 0;
        const s = Math.floor(Math.max(0, start));
        const e = Math.floor(Math.min(len, end));
        if (s >= e) return dataArray[s] || 0;

        for(let i=s; i<e; i++) {
          sum += dataArray[i];
          count++;
        }
        return count > 0 ? sum / count : 0;
      };

      let sumSq = 0;
      let peakVal = 0;
      let peakIdx = 0;
      for(let i=0; i<len; i++) {
        const val = dataArray[i] / 255.0;
        sumSq += val * val;
        if(dataArray[i] > peakVal) {
          peakVal = dataArray[i];
          peakIdx = i;
        }
      }

      const rms = Math.sqrt(sumSq / len);
      let db = 20 * Math.log10(rms);
      if (!isFinite(db)) db = -100;

      const hz = peakIdx * (audioContext.sampleRate / analyser.fftSize);
      const flux = Math.abs(rms - lastVolume);
      lastVolume = rms;

      let rawBass = avg(0, 10) / 255;
      let rawMid = avg(10, 80) / 255;
      let rawHigh = avg(80, 200) / 255;

      maxBass = Math.max(maxBass, rawBass);
      maxMid = Math.max(maxMid, rawMid);
      maxHigh = Math.max(maxHigh, rawHigh);

      maxBass *= 0.999;
      maxMid *= 0.999;
      maxHigh *= 0.999;

      if (maxBass < 0.1) maxBass = 0.1;
      if (maxMid < 0.1) maxMid = 0.1;
      if (maxHigh < 0.1) maxHigh = 0.1;

      return {
        bass: Math.min(1.0, rawBass / maxBass),
        mid: Math.min(1.0, rawMid / maxMid),
        high: Math.min(1.0, rawHigh / maxHigh),
        stats: { db, hz, flux }
      };
    }

    // --- ANIMATION ---
    let lastFrameTime = 0;
    let animationFrameId;

    function animate(time) {
      if(!isRunning && !isFading) return;

      const currentTimeSec = time / 1000;
      const deltaTime = (time - lastFrameTime) / 1000;
      lastFrameTime = time;

      // CALCULATE SONG PROGRESS (0.0 to 1.0)
      let songProgress = 0;
      if (audioDuration > 0) {
        songProgress = currentTimeSec / audioDuration;
        if (songProgress > 1.0) songProgress = 1.0;
      }

      if (isFading) {
        const fadeProgress = (currentTimeSec - fadeStartTime) / FADE_DURATION;
        if (fadeProgress >= 1.0) {
          materialBG.uniforms.uFade.value = 1.0;
          if (fadeCompleteTime === 0) fadeCompleteTime = currentTimeSec;
          renderer.clear();
          renderer.render(sceneBG, cameraBG);
          if (currentTimeSec - fadeCompleteTime >= END_BUFFER) {
            resetUI();
            return;
          }
          animationFrameId = requestAnimationFrame(animate);
          return;
        }
        materialBG.uniforms.uFade.value = fadeProgress;
      }

      const data = getAudioData();
      smoothBass += (data.bass - smoothBass) * 0.2;
      smoothMid += (data.mid - smoothMid) * 0.2;
      smoothHigh += (data.high - smoothHigh) * 0.2;

      materialBG.uniforms.uTime.value = currentTimeSec;
      materialBG.uniforms.uBass.value = smoothBass;
      materialBG.uniforms.uMid.value = smoothMid;
      materialBG.uniforms.uHigh.value = smoothHigh;
      // Pass song progress to shader for Vines
      materialBG.uniforms.uProgress.value = songProgress;

      // --- GLOBAL SPIN (Camera Roll) ---
      camera3D.rotation.z += deltaTime * (0.05 + smoothBass * 0.1);

      // 1. BIO CLUSTER (Bottom Left)
      if(bioCluster) {
        bioCluster.rotation.x = currentTimeSec * 0.25;
        bioCluster.rotation.y = currentTimeSec * 0.35 + smoothBass;
        bioCluster.rotation.z = currentTimeSec * 0.15;

        bioCluster.position.x += Math.sin(currentTimeSec * 0.5) * 0.05;
        bioCluster.position.y += Math.cos(currentTimeSec * 0.7) * 0.05;

        const pulse = 1.0 + smoothBass * 0.4;
        bioCluster.scale.set(pulse, pulse, pulse);

        // STATIC MORPHING
        const children = bioCluster.children;
        const stage = songProgress * 3;
        const idx = Math.floor(stage);
        const frac = stage - idx;

        for(let j=0; j<children.length; j++) {
          if(children[j] && children[j].material) children[j].material.opacity = 0;
        }

        if (children[idx] && children[idx].material) {
          children[idx].material.opacity = (1.0 - frac) * 0.9;
        }
        if (children[idx+1] && children[idx+1].material) {
          children[idx+1].material.opacity = frac * 0.9;
        }
      }

      // 2. DNA STRAND (Bottom Right)
      if(dnaStrand) {
        dnaStrand.rotation.z = Math.PI / 6;
        dnaStrand.rotation.x = Math.sin(currentTimeSec * 0.2) * 0.5;
        dnaStrand.rotateY(deltaTime * (0.5 + smoothMid + (songProgress * 2.0)));

        if(dnaStrand.children[0]) {
          dnaStrand.children[0].rotation.x += deltaTime;
        }

        const pulse = 1.0 + smoothMid * 0.2;
        dnaStrand.scale.set(pulse, pulse, pulse);
      }

      // 3. SPORE OBJ (Top Left)
      if(sporeObj) {
        sporeObj.rotation.x = Math.sin(currentTimeSec * 0.6) * 1.5;
        sporeObj.rotation.y = Math.cos(currentTimeSec * 0.3) * 1.5;

        if (sporeObj.children[2]) {
          sporeObj.children[2].rotation.x += deltaTime * 2.0;
          sporeObj.children[2].rotation.y += deltaTime * 0.5;
        }
        sporeObj.children[1].scale.setScalar(1.0 + smoothHigh * 0.5);
      }

      // 4. BACTERIA (Top Right)
      if(bacteriaObj) {
        const chaos = 1.0 + (songProgress * 3.0);
        bacteriaObj.rotation.x += deltaTime * 0.3 * chaos;
        bacteriaObj.rotation.y += deltaTime * 0.2 * chaos;
        bacteriaObj.rotation.z += deltaTime * 0.1 * chaos;

        bacteriaObj.position.x += Math.sin(currentTimeSec * 1.1) * 0.02;
        bacteriaObj.position.y += Math.cos(currentTimeSec * 0.9) * 0.02;

        const s = 1.0 + smoothBass * 0.3;
        bacteriaObj.scale.set(s, s, s);
      }

      // 5. NUCLEUS (Center)
      if(centerNucleus) {
        centerNucleus.children[0].rotation.y += deltaTime * (0.5 + smoothHigh);
        centerNucleus.children[0].rotation.z = Math.sin(currentTimeSec * 0.2);

        centerNucleus.children[1].rotation.x += deltaTime * (0.3 + smoothBass);
        centerNucleus.children[1].rotation.y -= deltaTime * 0.5;

        centerNucleus.scale.setScalar(1.0 + smoothBass * 0.6);
      }

      // --- OPTIMIZED LOOP: Reuse color objects to save GC ---
      for(let i=0, l=tunnelRings.length; i<l; i++) {
        const ring = tunnelRings[i];

        ring.position.z += deltaTime * (8 + (songProgress * 20) + Math.pow(smoothBass, 2) * 30);
        ring.rotation.z += deltaTime * ring.userData.rotSpeed * 2.0;
        ring.position.x = Math.sin(currentTimeSec * 0.5 + i * 0.1) * 0.5;
        ring.position.y = Math.cos(currentTimeSec * 0.3 + i * 0.1) * 0.5;

        if (ring.children[0]) ring.children[0].scale.setScalar(1.0 + smoothBass * 0.1 * Math.sin(i + currentTimeSec));

        if(ring.position.z > 5) {
          ring.position.z -= 90;
        }

        const z = ring.position.z;
        let opacity = 0;
        if (z < -80) opacity = 0;
        else if (z < -10) opacity = 1.0;
        else opacity = (2 - z) / 10;

        opacity = Math.max(0, Math.min(1, opacity));

        if (Math.random() > 0.98) opacity = 0.0;

        colorTemp.copy(colorToxic).lerp(colorSlime, smoothHigh);

        for(let j=0; j<ring.children.length; j++) {
          const child = ring.children[j];
          if(child.material) {
            child.material.opacity = opacity;
            child.material.color.copy(colorTemp);
          }
        }
      }

      renderer.clear();
      renderer.render(sceneBG, cameraBG);
      renderer.clearDepth();
      renderer.render(scene3D, camera3D);
      // Removed HUD Render

      animationFrameId = requestAnimationFrame(animate);
    }

    // --- FILE HANDLING & UTILS ---
    selectFileBtn.onclick = () => { initAudio(); fileInput.value = ''; fileInput.click(); };

    fileInput.onchange = (e) => {
      const file = e.target.files[0];
      if(!file) return;
      currentAudioFile = file;
      messageDiv.innerText = "SAMPLE ACQUIRED...";
      const reader = new FileReader();
      reader.onload = async (ev) => {
        try {
          const audioBuffer = await audioContext.decodeAudioData(ev.target.result);
          await startVisualizer(audioBuffer);
        } catch(err) {
          messageDiv.innerText = "ERROR: " + err.message;
        }
      };
      reader.readAsArrayBuffer(file);
    };

    async function startVisualizer(buffer) {
      if (audioContext.state === 'suspended') await audioContext.resume();
      if(sourceNode) { try { sourceNode.onended = null; sourceNode.disconnect(); sourceNode.stop(); } catch(e) {} }

      // Safe Auto-Gain Calibration (No Offline Context)
      messageDiv.innerText = "CALIBRATION: AUTO-GAIN";

      sourceNode = audioContext.createBufferSource();
      sourceNode.buffer = buffer;
      sourceNode.connect(analyser);
      analyser.connect(audioContext.destination);
      sourceNode.onended = () => { if (isRunning) triggerFadeOut(); };
      sourceNode.start(0);

      // STORE DURATION FOR MORPHING
      audioDuration = buffer.duration;
      nextMorphThreshold = 0.1; // Reset morph state

      overlay.style.opacity = 0;
      setTimeout(() => overlay.style.display = 'none', 800);
      recordContainer.style.display = 'flex';
      setTimeout(() => recordContainer.style.opacity = 1, 10);

      isRunning = true;
      isFading = false;
      fadeCompleteTime = 0;
      materialBG.uniforms.uFade.value = 0.0;
      lastFrameTime = performance.now();
      smoothBass = 0; smoothMid = 0; smoothHigh = 0;

      onResize();

      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      animate(lastFrameTime);
      if(autoRecordCheck.checked) setTimeout(toggleRecord, 800);
    }

    function triggerFadeOut() {
      if (!isRunning || isFading) return;
      isFading = true;
      fadeStartTime = performance.now() / 1000;
      fadeCompleteTime = 0;
    }

    function resetUI() {
      isRunning = false;
      isFading = false;
      fadeCompleteTime = 0;
      if (animationFrameId) cancelAnimationFrame(animationFrameId);
      if(isRecording) toggleRecord();
      overlay.style.display = 'block';
      setTimeout(() => overlay.style.opacity = 1, 10);
      recordContainer.style.opacity = 0;
      setTimeout(() => recordContainer.style.display = 'none', 500);
      if(sourceNode) { try { sourceNode.onended = null; sourceNode.disconnect(); } catch(e){} }
    }

    leaveBtn.onclick = () => { if(sourceNode) { try { sourceNode.stop(); } catch(e){} } resetUI(); };
    recordBtn.onclick = toggleRecord;

    function toggleRecord() {
      if(isRecording) {
        try { mediaRecorder.stop(); } catch(e){}
        isRecording = false;
        recordBtn.innerText = "INITIATE";
        recordBtn.classList.remove('recording');
        if (was4k) {
          was4k = false;
          resizeApp(window.innerWidth, window.innerHeight, true);
        }
      } else {
        let fps = 60;
        let bitrate = 15000000; // 15 Mbps for standard

        if (record4kCheck.checked) {
          was4k = true;
          resizeApp(3840, 2160, false);
          // OPTIMIZATION: Drop to 30fps for 4K to prevent stuttering
          fps = 30;
          bitrate = 25000000; // 25 Mbps for 4K crispness
        }

        const stream = renderer.domElement.captureStream(fps);
        const dest = audioContext.createMediaStreamDestination();
        sourceNode.connect(dest);
        const tracks = [...stream.getVideoTracks(), ...dest.stream.getAudioTracks()];

        try {
          mediaRecorder = new MediaRecorder(new MediaStream(tracks), {
            mimeType: 'video/webm;codecs=vp9',
            videoBitsPerSecond: bitrate
          });
        }
        catch (e) {
          try {
            mediaRecorder = new MediaRecorder(new MediaStream(tracks));
          } catch (e2) {
            messageDiv.innerText = "Recording not supported";
            return;
          }
        }

        mediaRecorder.ondataavailable = (e) => { if(e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = saveVideo;
        recordedChunks = [];
        mediaRecorder.start();
        isRecording = true;
        recordBtn.innerText = "STOP REC";
        recordBtn.classList.add('recording');
      }
    }

    function saveVideo() {
      if (recordedChunks.length === 0) return;
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = currentAudioFile ? `microbial-${currentAudioFile.name.split('.')[0]}.webm` : 'microbial.webm';
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 100);
    }

    fullscreenBtn.onclick = () => {
      if (!document.fullscreenElement) { document.body.requestFullscreen(); fullscreenBtn.innerHTML = "ðŸ¡¼"; }
      else { document.exitFullscreen(); fullscreenBtn.innerHTML = "â›¶"; }
    };

    initThree();
  })();
</script>
</body>
</html>git