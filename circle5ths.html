<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle of Fifths Websynth - MIDI Polling & Channel</title>
    <style>
        /* General Body Styles */
        body {
            font-family: 'Inter', 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #282c34; /* Dark background */
            color: #abb2bf; /* Light grey text */
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            color: #61afef; /* Accent blue */
            margin-bottom: 30px;
        }

        /* Main container for synth layout */
        .synth-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 40px; /* Increased gap */
            justify-content: center;
            align-items: flex-start;
            width: 100%;
            max-width: 1000px; /* Max width for the synth */
        }

        /* Circle of Fifths Container */
        #circle-of-fifths-container {
            width: 400px; /* Increased size for two rings */
            height: 400px;
            position: relative;
            border-radius: 50%;
            background-color: #3a3f4b;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 15px rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Styling for each segment/key in the circle */
        .cof-segment {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            background-color: #4f5666;
            color: #dcdfe4;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.1s ease, transform 0.1s ease, box-shadow 0.1s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            border: 2px solid #3a3f4b;
            user-select: none;
        }

        .cof-segment-major {
            width: 80px;
            height: 80px;
            font-size: 14px;
        }

        .cof-segment-minor {
            width: 65px;
            height: 65px;
            font-size: 12px;
            background-color: #464c59;
        }

        .cof-segment.active { /* This class now indicates the *hovered and playing* key */
            background-color: #98c379; /* Green for active/playing */
            color: #282c34;
            transform: scale(1.1); /* Scale up when active */
            box-shadow: 0 4px 10px rgba(152, 195, 121, 0.6), inset 0 0 5px rgba(0,0,0,0.2);
            border-color: #86ae6a;
            z-index: 10;
        }
         .cof-segment-minor.active {
            background-color: #8ab86f;
             transform: scale(1.1);
        }

        /* Central Stop Button */
        #center-stop-button {
            position: absolute;
            width: 70px;
            height: 70px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background-color: #e06c75;
            color: white;
            font-weight: bold;
            font-size: 16px;
            border: 3px solid #282c34;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            cursor: pointer;
            z-index: 20;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        #center-stop-button:hover {
            background-color: #f28b94;
            transform: translate(-50%, -50%) scale(1.05);
        }
        #center-stop-button:active {
            background-color: #c75b65;
            transform: translate(-50%, -50%) scale(0.98);
        }


        /* Controls Panel Styling */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Slightly reduced gap */
            background-color: #3a3f4b;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            min-width: 300px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px; /* Slightly reduced gap */
        }

        .control-group label {
            font-weight: bold;
            color: #c8ccd4;
            margin-bottom: 4px;
        }

        .control-group select,
        .control-group input[type="number"],
        .control-group input[type="range"] {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #5c6370;
            background-color: #2c313a;
            color: #abb2bf;
            width: 100%;
            box-sizing: border-box;
            font-size: 1em;
        }
        .control-group input[type="range"] {
            padding: 0;
             -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #5c6370;
            outline: none;
            opacity: 0.9;
            transition: opacity .15s ease-in-out;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #61afef;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #282c34;
        }
        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #61afef;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #282c34;
        }


        .adsr-group div {
            margin-bottom: 10px; /* Slightly reduced */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .adsr-group label {
            flex-basis: 90px; /* Adjusted */
        }
        .adsr-group input[type="range"] {
            flex-grow: 1;
            margin: 0 8px; /* Adjusted */
        }
        .adsr-group span {
            font-size: 0.9em;
            color: #828997;
            min-width: 35px;
            text-align: right;
        }

        #audio-message, #midi-message, #chord-display-area {
            margin-top: 15px;
            padding: 10px;
            background-color: #3a3f4b;
            border-radius: 6px;
            text-align: center;
            font-size: 0.9em;
            display: none;
            max-width: 90%;
            word-wrap: break-word;
        }
        #audio-message { color: #e06c75; }
        #midi-message { color: #61afef; }
        #chord-display-area {
            color: #98c379;
            font-weight: bold;
            font-size: 1.1em;
            min-height: 2em;
            border: 1px dashed #5c6370;
        }


        @media (max-width: 768px) {
            .synth-container {
                flex-direction: column;
                align-items: center;
            }
            #circle-of-fifths-container {
                width: 320px;
                height: 320px;
            }
            .cof-segment-major {
                width: 65px;
                height: 65px;
                font-size: 12px;
            }
            .cof-segment-minor {
                width: 50px;
                height: 50px;
                font-size: 10px;
            }
            #center-stop-button {
                width: 60px;
                height: 60px;
                font-size: 14px;
            }
            .controls {
                min-width: unset;
                width: 90%;
                max-width: 400px;
            }
        }
    </style>
</head>
<body>
    <h1>Circle of Fifths Websynth</h1>
    <div id="audio-message"></div>
    <div id="midi-message">
        <p>Attempting to initialize MIDI. <b>If MIDI access fails due to 'Permissions Policy':</b><br>
        1. Ensure this page is served over <b>HTTPS</b> or from <b>localhost</b>.<br>
        2. If this page is in an <b>iframe</b> (likely in this environment), the iframe needs the <code>allow="midi"</code> attribute set by the parent page.</p>
    </div>

    <div class="synth-container">
        <div id="circle-of-fifths-container">
            <button id="center-stop-button">Stop</button>
            </div>

        <div class="controls">
            <div class="control-group">
                <label for="waveform">Waveform:</label>
                <select id="waveform">
                    <option value="sine">Sine</option>
                    <option value="square">Square</option>
                    <option value="sawtooth">Sawtooth</option>
                    <option value="triangle">Triangle</option>
                </select>
            </div>

            <div class="control-group">
                <label for="octave">Octave:</label>
                <input type="number" id="octave" value="3" min="0" max="7">
            </div>

            <div class="control-group adsr-group">
                <div>
                    <label for="attack">Attack:</label>
                    <input type="range" id="attack" min="0.01" max="2" step="0.01" value="0.1">
                    <span id="attack-value">0.10s</span>
                </div>
                <div>
                    <label for="decay">Decay:</label>
                    <input type="range" id="decay" min="0.01" max="2" step="0.01" value="0.1">
                    <span id="decay-value">0.10s</span>
                </div>
                <div>
                    <label for="sustain">Sustain:</label>
                    <input type="range" id="sustain" min="0.0" max="1" step="0.01" value="0.8">
                    <span id="sustain-value">0.80</span>
                </div>
                <div>
                    <label for="release">Release:</label>
                    <input type="range" id="release" min="0.01" max="3" step="0.01" value="0.5">
                    <span id="release-value">0.50s</span>
                </div>
            </div>
             <div class="control-group">
                <label for="midi-output">MIDI Output:</label>
                <select id="midi-output">
                    <option value="">-- Select MIDI Output --</option>
                </select>
            </div>
            <div class="control-group">
                <label for="midi-channel">MIDI Channel:</label>
                <input type="number" id="midi-channel" value="1" min="1" max="16">
            </div>
            <div id="chord-display-area">Chord: ---</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let audioContext;
            const audioMessageDiv = document.getElementById('audio-message');
            const midiMessageDiv = document.getElementById('midi-message');
            const chordDisplayArea = document.getElementById('chord-display-area');

            function initAudioContext() {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioContext.state === 'suspended') {
                        audioMessageDiv.textContent = "Move mouse over a key on the circle to start audio.";
                        audioMessageDiv.style.display = 'block';
                    } else {
                        audioMessageDiv.style.display = 'none';
                    }
                } catch (e) {
                    audioMessageDiv.textContent = "Web Audio API is not supported in this browser.";
                    audioMessageDiv.style.display = 'block';
                    console.error("Web Audio API not supported:", e);
                    return false;
                }
                return true;
            }
            const audioReady = initAudioContext();

            // DOM Elements
            const circleContainer = document.getElementById('circle-of-fifths-container');
            const waveformSelect = document.getElementById('waveform');
            const octaveInput = document.getElementById('octave');
            const attackSlider = document.getElementById('attack');
            const decaySlider = document.getElementById('decay');
            const sustainSlider = document.getElementById('sustain');
            const releaseSlider = document.getElementById('release');
            const attackValueSpan = document.getElementById('attack-value');
            const decayValueSpan = document.getElementById('decay-value');
            const sustainValueSpan = document.getElementById('sustain-value');
            const releaseValueSpan = document.getElementById('release-value');
            const centerStopButton = document.getElementById('center-stop-button');
            const midiOutputSelect = document.getElementById('midi-output');
            const midiChannelInput = document.getElementById('midi-channel'); // New MIDI Channel Input

            // Synth State
            let currentOscillator = null;
            let currentGainNode = null;
            let selectedRootNote = 'C';
            let selectedKeyType = 'major';
            let activeSegmentElement = null;
            let currentPlayingMidiNote = null;

            // MIDI State
            let midiAccess = null;
            let selectedMidiOutput = null;

            // Mouse Polling State
            let mousePosition = { x: 0, y: 0 };
            let segmentRects = [];
            let currentlyPollingOverSegment = null;
            let pollingIntervalId = null;


            // Note Data
            const circleKeysData = [
                { major: 'C', minorLabel: 'Am', minorRoot: 'A', angle: -90 },
                { major: 'G', minorLabel: 'Em', minorRoot: 'E', angle: -60 },
                { major: 'D', minorLabel: 'Bm', minorRoot: 'B', angle: -30 },
                { major: 'A', minorLabel: 'F♯m', minorRoot: 'F♯/G♭', angle: 0 },
                { major: 'E', minorLabel: 'C♯m', minorRoot: 'C♯/D♭', angle: 30 },
                { major: 'B', minorLabel: 'G♯m', minorRoot: 'G♯/A♭', angle: 60 },
                { major: 'F♯/G♭', minorLabel: 'D♯m/E♭m', minorRoot: 'D♯/E♭', angle: 90 },
                { major: 'C♯/D♭', minorLabel: 'A♯m/B♭m', minorRoot: 'A♯/B♭', angle: 120 },
                { major: 'A♭', minorLabel: 'Fm', minorRoot: 'F', angle: 150 },
                { major: 'E♭', minorLabel: 'Cm', minorRoot: 'C', angle: 180 },
                { major: 'B♭', minorLabel: 'Gm', minorRoot: 'G', angle: 210 },
                { major: 'F', minorLabel: 'Dm', minorRoot: 'D', angle: 240 }
            ];

            const noteNameToOffset = {
                'C': 0, 'C♯': 1, 'D♭': 1, 'D': 2, 'D♯': 3, 'E♭': 3, 'E': 4, 'F': 5,
                'F♯': 6, 'G♭': 6, 'G': 7, 'G♯': 8, 'A♭': 8, 'A': 9, 'A♯': 10, 'B♭': 10, 'B': 11,
                'C♯/D♭': 1, 'D♯/E♭': 3, 'F♯/G♭': 6, 'G♯/A♭': 8, 'A♯/B♭': 10
            };
            const displayNotes = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];

            const baseFrequencies = {
                'C': 261.63, 'C♯/D♭': 277.18, 'D': 293.66, 'D♯/E♭': 311.13, 'E♭': 311.13,
                'E': 329.63, 'F': 349.23, 'F♯/G♭': 369.99, 'G♭': 369.99, 'G': 392.00,
                'G♯/A♭': 415.30, 'A♭': 415.30, 'A': 440.00, 'A♯/B♭': 466.16, 'B♭': 466.16, 'B': 493.88
            };

            function calculateSegmentRects() {
                segmentRects = [];
                const segments = circleContainer.querySelectorAll('.cof-segment');
                segments.forEach(segment => {
                    segmentRects.push({
                        element: segment,
                        rect: segment.getBoundingClientRect(),
                        note: segment.dataset.note,
                        keyType: segment.dataset.keyType
                    });
                });
            }

            function createCircleUI() {
                if (!circleContainer) return;
                Array.from(circleContainer.querySelectorAll('.cof-segment')).forEach(el => el.remove());
                const containerWidth = circleContainer.offsetWidth;
                const containerHeight = circleContainer.offsetHeight;
                const radiusOuter = containerWidth / 2 * 0.80;
                const radiusInner = containerWidth / 2 * 0.50;

                circleKeysData.forEach((keyData) => {
                    const segmentMajor = document.createElement('div');
                    segmentMajor.classList.add('cof-segment', 'cof-segment-major');
                    segmentMajor.textContent = keyData.major;
                    segmentMajor.dataset.note = keyData.major;
                    segmentMajor.dataset.keyType = 'major';
                    positionSegment(segmentMajor, keyData.angle, radiusOuter, containerWidth, containerHeight);
                    circleContainer.appendChild(segmentMajor);

                    const segmentMinor = document.createElement('div');
                    segmentMinor.classList.add('cof-segment', 'cof-segment-minor');
                    segmentMinor.textContent = keyData.minorLabel;
                    segmentMinor.dataset.note = keyData.minorRoot;
                    segmentMinor.dataset.keyType = 'minor';
                    positionSegment(segmentMinor, keyData.angle, radiusInner, containerWidth, containerHeight);
                    circleContainer.appendChild(segmentMinor);
                });

                calculateSegmentRects();

                 if (chordDisplayArea) {
                    chordDisplayArea.style.display = 'block';
                    if (!activeSegmentElement) {
                        updateChordDisplay(selectedRootNote, selectedKeyType);
                    }
                 }
            }

            function positionSegment(segment, angle, radius, containerWidth, containerHeight) {
                const angleRad = angle * (Math.PI / 180);
                const segmentWidth = parseFloat(getComputedStyle(segment).width) || (segment.classList.contains('cof-segment-major') ? 80 : 65);
                const segmentHeight = parseFloat(getComputedStyle(segment).height) || (segment.classList.contains('cof-segment-major') ? 80 : 65);
                const x = (containerWidth / 2) + radius * Math.cos(angleRad) - (segmentWidth / 2);
                const y = (containerHeight / 2) + radius * Math.sin(angleRad) - (segmentHeight / 2);
                segment.style.left = `${x}px`;
                segment.style.top = `${y}px`;
            }

            createCircleUI();

            // --- Mouse Polling Logic ---
            document.addEventListener('mousemove', (event) => {
                mousePosition.x = event.clientX;
                mousePosition.y = event.clientY;
            });

            function pollMousePosition() {
                if (!audioReady || !audioContext) return;

                let segmentUnderMouse = null;
                for (const segRect of segmentRects) {
                    if (mousePosition.x >= segRect.rect.left && mousePosition.x <= segRect.rect.right &&
                        mousePosition.y >= segRect.rect.top && mousePosition.y <= segRect.rect.bottom) {
                        segmentUnderMouse = segRect;
                        break;
                    }
                }

                if (segmentUnderMouse) {
                    if (currentlyPollingOverSegment !== segmentUnderMouse.element) {
                        const playAfterResume = () => {
                            if (currentlyPollingOverSegment) {
                                currentlyPollingOverSegment.classList.remove('active');
                            }
                            segmentUnderMouse.element.classList.add('active');
                            activeSegmentElement = segmentUnderMouse.element;

                            selectedRootNote = segmentUnderMouse.note;
                            selectedKeyType = segmentUnderMouse.keyType;

                            console.log("Polling - Play Note:", selectedRootNote, "(Type:", selectedKeyType, ")");
                            playNote();
                            currentlyPollingOverSegment = segmentUnderMouse.element;
                        };

                        if (audioContext.state === 'suspended') {
                            audioContext.resume().then(() => {
                                audioMessageDiv.style.display = 'none';
                                playAfterResume();
                            }).catch(err => console.error("AudioContext resume failed:", err));
                        } else {
                            playAfterResume();
                        }
                    }
                } else {
                    if (currentlyPollingOverSegment) {
                        console.log("Polling - Mouse left segment:", currentlyPollingOverSegment.dataset.note);
                        stopNote();
                        currentlyPollingOverSegment.classList.remove('active');
                        activeSegmentElement = null;
                        currentlyPollingOverSegment = null;
                        if (chordDisplayArea) chordDisplayArea.textContent = "Chord: ---";
                    }
                }
            }

            if (circleContainer) {
                circleContainer.addEventListener('mouseleave', (event) => {
                    console.log("Mouse left circle container - ensuring all sound stopped.");
                    if (currentlyPollingOverSegment) {
                        stopNote();
                        currentlyPollingOverSegment.classList.remove('active');
                        currentlyPollingOverSegment = null;
                    }
                    if (activeSegmentElement) {
                         activeSegmentElement.classList.remove('active');
                         activeSegmentElement = null;
                    }
                    if (chordDisplayArea) {
                        chordDisplayArea.textContent = "Chord: ---";
                    }
                });
                circleContainer.addEventListener('mouseenter', () => {
                    if (!pollingIntervalId) {
                        calculateSegmentRects();
                        pollingIntervalId = setInterval(pollMousePosition, 50);
                        console.log("Polling started.");
                    }
                });
                 circleContainer.addEventListener('mouseleave', () => {
                    if (pollingIntervalId) {
                        clearInterval(pollingIntervalId);
                        pollingIntervalId = null;
                        console.log("Polling stopped.");
                    }
                });

            }


            function initMidi() { /* ... same as before ... */
                midiMessageDiv.innerHTML = "<p>Attempting to initialize MIDI. <b>If MIDI access fails due to 'Permissions Policy':</b><br>1. Ensure this page is served over <b>HTTPS</b> or from <b>localhost</b>.<br>2. If this page is in an <b>iframe</b> (likely in this environment), the iframe needs the <code>allow=\"midi\"</code> attribute set by the parent page.</p>";
                midiMessageDiv.style.color = "#61afef";
                midiMessageDiv.style.display = 'block';

                if (!navigator.requestMIDIAccess) {
                    midiMessageDiv.innerHTML = "<b>Web MIDI API not supported in this browser.</b>";
                    midiMessageDiv.style.color = "#e06c75";
                    return;
                }
                if (!window.isSecureContext && window.location.protocol !== "file:" && window.location.hostname !== "localhost" && window.location.hostname !== "127.0.0.1") {
                    midiMessageDiv.innerHTML = "<b>MIDI Disabled:</b> Page is not secure (HTTPS). <br>Web MIDI API requires a secure connection or localhost/file access for MIDI functionality.";
                    midiMessageDiv.style.color = "#e06c75";
                    return;
                }
                navigator.requestMIDIAccess({ sysex: false })
                    .then(onMIDISuccess, onMIDIFailure);
            }
            function onMIDISuccess(midi) { /* ... same as before ... */
                midiAccess = midi;
                midiMessageDiv.textContent = "MIDI ready. Select an output device from the dropdown.";
                midiMessageDiv.style.color = "#98c379";
                midiMessageDiv.style.display = 'block';

                const outputs = midiAccess.outputs.values();
                midiOutputSelect.innerHTML = '<option value="">-- Select MIDI Output --</option>';
                for (let output = outputs.next(); output && !output.done; output = outputs.next()) {
                    const option = document.createElement('option');
                    option.value = output.value.id;
                    option.textContent = output.value.name;
                    midiOutputSelect.appendChild(option);
                }

                midiOutputSelect.onchange = (event) => {
                    if (event.target.value) {
                        selectedMidiOutput = midiAccess.outputs.get(event.target.value);
                        midiMessageDiv.textContent = `MIDI Output selected: ${selectedMidiOutput.name}`;
                        console.log("Selected MIDI Output:", selectedMidiOutput);
                    } else {
                        selectedMidiOutput = null;
                        midiMessageDiv.textContent = "MIDI output deselected. Select an output to send MIDI.";
                    }
                };

                midiAccess.onstatechange = (event) => {
                    console.log("MIDI state change:", event.port.name, event.port.state, event.port.type);
                    const currentSelectedId = selectedMidiOutput ? selectedMidiOutput.id : midiOutputSelect.value;
                    midiOutputSelect.innerHTML = '<option value="">-- Select MIDI Output --</option>';
                    let foundSelected = false;
                    const updatedOutputs = midiAccess.outputs.values();
                    for (let output = updatedOutputs.next(); output && !output.done; output = updatedOutputs.next()) {
                        const option = document.createElement('option');
                        option.value = output.value.id;
                        option.textContent = output.value.name;
                        midiOutputSelect.appendChild(option);
                        if (output.value.id === currentSelectedId) {
                            option.selected = true;
                            foundSelected = true;
                        }
                    }

                    if (currentSelectedId && !foundSelected) {
                        selectedMidiOutput = null;
                         midiMessageDiv.textContent = `Previously selected MIDI output '${event.port.name}' disconnected. Please select another.`;
                        midiMessageDiv.style.color = "#e06c75";
                    } else if (foundSelected && selectedMidiOutput) {
                         midiMessageDiv.textContent = `MIDI Output: ${selectedMidiOutput.name}`;
                        midiMessageDiv.style.color = "#98c379";
                    } else if (!selectedMidiOutput) {
                         midiMessageDiv.textContent = "MIDI ready. Select an output device.";
                         midiMessageDiv.style.color = "#98c379";
                    }
                };
            }
            function onMIDIFailure(error) { /* ... same as before ... */
                let msg = `Failed to get MIDI access: ${error.message}.`;
                if (error.name === 'SecurityError') {
                    msg = "<b>MIDI Access Error (Security):</b> " + error.message + "<br>";
                    if (window.self !== window.top && window.location.protocol !== "file:") {
                        msg += "This page is likely in an <b>iframe</b>. The parent frame needs to grant MIDI permission (e.g., using <code>allow=\"midi\"</code> attribute on the iframe tag). This is a common issue in embedded environments. ";
                    } else if (!window.isSecureContext && window.location.protocol !== "file:" && window.location.hostname !== "localhost" && window.location.hostname !== "127.0.0.1") {
                        msg += "This page is not served over <b>HTTPS</b> or from <b>localhost/file</b>. Web MIDI requires a secure context. ";
                    } else {
                        msg += "Please check browser settings or if the server is sending restrictive Permissions Policy headers. ";
                    }
                    msg += "Try serving the page via HTTPS or a local web server if applicable.";
                } else if (error.name === "NotAllowedError") {
                     msg = "<b>MIDI Access Error (Not Allowed):</b> " + error.message + "<br>You may need to explicitly grant MIDI permission in your browser settings for this site.";
                }

                midiMessageDiv.innerHTML = msg;
                midiMessageDiv.style.color = "#e06c75";
                midiMessageDiv.style.display = 'block';
                console.error(`Failed to get MIDI access - ${error.name}: ${error.message}`);
            }
            initMidi();

            function getMidiNoteNumber(noteName, octaveVal) { /* ... same as before ... */
                let note = noteName.split('/')[0];
                let offset = noteNameToOffset[note];

                if (offset === undefined) {
                    offset = 0;
                }
                const finalMidiNote = ((parseInt(octaveVal) - 4) * 12) + 60 + offset;
                return Math.max(0, Math.min(127, finalMidiNote));
            }

            function getChordNotes(rootNote, type) { /* ... same as before ... */
                const rootNoteClean = rootNote.split('/')[0];
                const rootOffset = noteNameToOffset[rootNoteClean];
                if (rootOffset === undefined) return ['N/A', 'N/A', 'N/A'];
                const thirdInterval = (type === 'major') ? 4 : 3;
                const fifthInterval = 7;
                const thirdOffset = (rootOffset + thirdInterval) % 12;
                const fifthOffset = (rootOffset + fifthInterval) % 12;
                return [ displayNotes[rootOffset], displayNotes[thirdOffset], displayNotes[fifthOffset] ];
            }
            function updateChordDisplay(rootNote, type) { /* ... same as before ... */
                if (!chordDisplayArea) return;
                const chord = getChordNotes(rootNote, type);
                chordDisplayArea.textContent = `Chord: ${rootNote} ${type === 'major' ? 'Maj' : 'min'} (${chord.join(' - ')})`;
                chordDisplayArea.style.display = 'block';
            }

            centerStopButton.addEventListener('click', () => {
                 if (!audioReady || !audioContext) return;
                 const stopAudioPlayback = () => {
                    console.log("Center Stop Button clicked - Stopping note.");
                    stopNote();
                    if (activeSegmentElement) {
                        activeSegmentElement.classList.remove('active');
                        activeSegmentElement = null;
                    }
                    currentlyPollingOverSegment = null;
                    if (chordDisplayArea) {
                        chordDisplayArea.textContent = "Chord: ---";
                    }
                 };

                if (audioContext.state === 'suspended') {
                     audioContext.resume().then(() => {
                        audioMessageDiv.style.display = 'none';
                        stopAudioPlayback();
                    }).catch(err => {
                        console.error("Error resuming AudioContext via stop button:", err);
                         audioMessageDiv.textContent = "Could not resume audio. Try clicking a key first.";
                        audioMessageDiv.style.display = 'block';
                    });
                } else {
                    stopAudioPlayback();
                }
            });

            function getFrequency(noteName, octaveVal) { /* ... same as before ... */
                let baseFreq = baseFrequencies[noteName];
                if (!baseFreq && noteName.includes('/')) {
                    const parts = noteName.split('/');
                    baseFreq = baseFrequencies[parts[0]] || baseFrequencies[parts[1]];
                }
                if (!baseFreq) {
                    return baseFrequencies['C'] * Math.pow(2, parseInt(octaveVal) - 4);
                }
                return baseFreq * Math.pow(2, parseInt(octaveVal) - 4);
            }

            function playNote() {
                 if (!audioReady || !audioContext) {
                    audioMessageDiv.textContent = "Audio system not ready.";
                    audioMessageDiv.style.display = 'block';
                    return;
                }

                stopNote();

                const currentOctave = parseInt(octaveInput.value);
                const freq = getFrequency(selectedRootNote, currentOctave);
                const waveform = waveformSelect.value;
                const attackTime = parseFloat(attackSlider.value);
                const decayTime = parseFloat(decaySlider.value);
                const sustainLevel = parseFloat(sustainSlider.value);
                const currentTime = audioContext.currentTime;

                currentOscillator = audioContext.createOscillator();
                currentGainNode = audioContext.createGain();
                currentOscillator.type = waveform;
                currentOscillator.frequency.setValueAtTime(freq, currentTime);
                currentGainNode.gain.setValueAtTime(0, currentTime);
                currentGainNode.gain.linearRampToValueAtTime(1.0, currentTime + attackTime);
                currentGainNode.gain.linearRampToValueAtTime(sustainLevel, currentTime + attackTime + decayTime);
                currentOscillator.connect(currentGainNode);
                currentGainNode.connect(audioContext.destination);
                currentOscillator.start(currentTime);

                updateChordDisplay(selectedRootNote, selectedKeyType);

                if (selectedMidiOutput) {
                    const selectedChannel = parseInt(midiChannelInput.value) || 1; // Default to channel 1
                    const midiChannelByte = Math.max(0, Math.min(15, selectedChannel - 1)); // 0-15

                    currentPlayingMidiNote = getMidiNoteNumber(selectedRootNote, currentOctave);
                    const velocity = 100;
                    selectedMidiOutput.send([0x90 + midiChannelByte, currentPlayingMidiNote, velocity]);
                    console.log(`MIDI Note On: Ch ${selectedChannel}, Note ${currentPlayingMidiNote} (Vel: ${velocity}) sent to ${selectedMidiOutput.name}`);
                }
            }


            function stopNote() {
                if (currentOscillator && currentGainNode && audioContext && audioContext.state !== 'closed') {
                    const releaseTime = parseFloat(releaseSlider.value);
                    const currentTime = audioContext.currentTime;
                    const currentVolume = currentGainNode.gain.value;
                    currentGainNode.gain.cancelScheduledValues(currentTime);
                    currentGainNode.gain.setValueAtTime(currentVolume, currentTime);
                    currentGainNode.gain.linearRampToValueAtTime(0, currentTime + releaseTime);

                    if (currentOscillator.playbackState === currentOscillator.PLAYING_STATE || currentOscillator.playbackState === currentOscillator.SCHEDULED_STATE) {
                         try {
                            currentOscillator.stop(currentTime + releaseTime + 0.01);
                        } catch (e) { /* ignore */ }
                    }

                    const oldOsc = currentOscillator;
                    const oldGain = currentGainNode;
                    oldOsc.onended = () => {
                        if (oldGain && oldGain.numberOfOutputs > 0) {
                           try { oldGain.disconnect(); } catch(e) { /* ignore */ }
                        }
                        if (currentOscillator === oldOsc) currentOscillator = null;
                        if (currentGainNode === oldGain) currentGainNode = null;
                    };
                }

                if (selectedMidiOutput && currentPlayingMidiNote !== null) {
                    const selectedChannel = parseInt(midiChannelInput.value) || 1;
                    const midiChannelByte = Math.max(0, Math.min(15, selectedChannel - 1));
                    selectedMidiOutput.send([0x80 + midiChannelByte, currentPlayingMidiNote, 0]);
                    console.log(`MIDI Note Off: Ch ${selectedChannel}, Note ${currentPlayingMidiNote} sent to ${selectedMidiOutput.name}`);
                    currentPlayingMidiNote = null;
                }
            }

            function updateSliderValue(slider, span, unit = 's') {
                const value = parseFloat(slider.value).toFixed(2);
                span.textContent = `${value}${unit === 's' ? 's' : ''}`;
            }
            attackSlider.addEventListener('input', () => updateSliderValue(attackSlider, attackValueSpan));
            decaySlider.addEventListener('input', () => updateSliderValue(decaySlider, decayValueSpan));
            sustainSlider.addEventListener('input', () => updateSliderValue(sustainSlider, sustainValueSpan, ''));
            releaseSlider.addEventListener('input', () => updateSliderValue(releaseSlider, releaseValueSpan));
            updateSliderValue(attackSlider, attackValueSpan);
            updateSliderValue(decaySlider, decayValueSpan);
            updateSliderValue(sustainSlider, sustainValueSpan, '');
            updateSliderValue(releaseSlider, releaseValueSpan);

            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    activeSegmentElement = null;
                    currentlyPollingOverSegment = null;
                    createCircleUI();
                }, 250);
            });
        });
    </script>
</body>
</html>
