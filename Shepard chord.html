<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stargate Corridor // Audio Reactive</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Custom Font & Cyberpunk Base */
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #000;
            overflow: hidden;
            margin: 0;
            padding: 0;
            color: #00ffff;
            /* Center the canvas stage */
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        /* Neon Glow Utilities */
        .neon-text-cyan {
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
        }
        .neon-text-magenta {
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff;
        }
        .neon-box {
            box-shadow: 0 0 10px #00ffff, inset 0 0 5px #00ffff;
            border: 1px solid #00ffff;
        }
        .neon-box-magenta {
            box-shadow: 0 0 10px #ff00ff, inset 0 0 5px #ff00ff;
            border: 1px solid #ff00ff;
        }

        /* Glitch Title Effect */
        .glitch-title {
            position: relative;
            font-size: 2rem;
            letter-spacing: 4px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .glitch-title::before, .glitch-title::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .glitch-title::before {
            left: 2px;
            text-shadow: -1px 0 #ff00ff;
            clip: rect(24px, 550px, 90px, 0);
            animation: glitch-anim-2 3s infinite linear alternate-reverse;
        }
        .glitch-title::after {
            left: -2px;
            text-shadow: -1px 0 #00ffff;
            clip: rect(85px, 550px, 140px, 0);
            animation: glitch-anim 2.5s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim {
            0% { clip: rect(10px, 9999px, 31px, 0); }
            20% { clip: rect(65px, 9999px, 89px, 0); }
            40% { clip: rect(22px, 9999px, 6px, 0); }
            60% { clip: rect(89px, 9999px, 12px, 0); }
            80% { clip: rect(4px, 9999px, 55px, 0); }
            100% { clip: rect(33px, 9999px, 92px, 0); }
        }
        @keyframes glitch-anim-2 {
            0% { clip: rect(65px, 9999px, 100px, 0); }
            20% { clip: rect(12px, 9999px, 44px, 0); }
            40% { clip: rect(87px, 9999px, 2px, 0); }
            60% { clip: rect(33px, 9999px, 55px, 0); }
            80% { clip: rect(10px, 9999px, 83px, 0); }
            100% { clip: rect(56px, 9999px, 30px, 0); }
        }

        /* UI Transition Classes */
        .fade-enter { opacity: 0; }
        .fade-enter-active { opacity: 1; transition: opacity 500ms ease-in; }
        .fade-exit { opacity: 1; }
        .fade-exit-active { opacity: 0; transition: opacity 500ms ease-out; }

        .hidden-visually {
            opacity: 0;
            pointer-events: none;
        }

        /* Canvas Positioning for Fixed Aspect Ratio */
        #visualizerCanvas {
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            /* Dimensions are controlled by JS for letterboxing */
        }
    </style>
<style>
  .toolbar {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    background: #333;
    padding: 2px;
    box-sizing: border-box;
    text-align: center;
    z-index: 1000;
  }
  .toolbar button {
    background: #555;
    color: white;
    border: 1px solid #888;
    border-radius: 3px;
    padding: 1px 4px;
    margin: 1px;
    cursor: pointer;
    font-size: 12px;
  }
  .toolbar button:disabled {
    background: #777;
    color: #ccc;
    cursor: default;
  }
</style>
<div class="toolbar">
    <button onclick="window.location.href='index.html'">Home</button>
    <button onclick="window.location.href='berlin.html'">Berlin</button>
    <button onclick="window.location.href='chords.html'">Chords</button>
    <button onclick="window.location.href='CosmicDrift.html'">Cosmic</button>
    <button onclick="window.location.href='delay.html'">Delay</button>
    <button onclick="window.location.href='karplus.html'">Karplus</button>
    <button onclick="window.location.href='polychain.html'">Polychain</button>
    <button onclick="window.location.href='pondviz.html'">Pond</button>
    <button onclick="window.location.href='Psychedelia.html'">Psyche</button>
    <button onclick="window.location.href='rhythm.html'">Rhythm</button>
    <button disabled>Shepard</button>
    <button onclick="window.location.href='starfield.html'">Starfield</button>
</div>
</head>
<body>

<!-- Main Canvas Container -->
<canvas id="visualizerCanvas" class="z-10"></canvas>

<!-- Audio Element (Hidden) -->
<audio id="audioElement" crossorigin="anonymous"></audio>
<input type="file" id="audioInput" accept="audio/*" class="hidden">

<!-- UI Overlay: Start Modal -->
<div id="startModal" class="fixed inset-0 z-50 flex items-center justify-center bg-black/85 backdrop-blur-sm transition-opacity duration-500">
    <div class="relative w-[90%] max-w-[500px] p-8 bg-black/90 neon-box text-center">
        <h1 class="glitch-title mb-6" data-text="STARGATE CORRIDOR">STARGATE CORRIDOR</h1>

        <div class="space-y-4 text-sm mb-8 text-cyan-200">
            <p>AUDIO REACTIVE SYSTEM INITIALIZATION</p>
            <div class="flex justify-between border-b border-cyan-900 pb-1">
                <span>MODULE</span><span>STATUS</span>
            </div>
            <div class="flex justify-between text-xs">
                <span>AUDIO SOURCE</span><span id="sourceStatus" class="text-yellow-400 blink">WAITING SELECTION</span>
            </div>
            <div class="flex justify-between text-xs">
                <span>OUTPUT RES</span><span class="text-green-400">1920x1080 (HD)</span>
            </div>
            <div class="flex justify-between text-xs">
                <span>AUTO-REC</span><span class="text-green-400">ENABLED</span>
            </div>
            <div id="fileInfo" class="text-xs text-magenta-400 mt-2 hidden text-left truncate neon-text-magenta border border-fuchsia-900 p-2">
                <!-- File name goes here -->
            </div>
        </div>

        <div class="flex flex-col gap-3">
            <button id="selectFileBtn" class="w-full py-3 text-lg font-bold uppercase tracking-[2px] border border-gray-600 text-gray-400 hover:border-cyan-400 hover:text-cyan-400 hover:bg-cyan-400/10 transition-all duration-300">
                <i class="fas fa-folder-open mr-2"></i> Select Target
            </button>

            <button id="startButton" class="w-full py-4 text-xl font-bold uppercase tracking-[2px] border border-gray-800 text-gray-800 cursor-not-allowed transition-all duration-300 group" disabled>
                <i class="fas fa-play mr-2 group-hover:animate-pulse"></i> Engage
            </button>
        </div>

        <p class="mt-4 text-xs text-gray-500 uppercase">Warning: Flashing lights / High GPU usage</p>
    </div>
</div>

<!-- Recording Interface -->
<div id="controlsUI" class="fixed bottom-8 left-0 w-full z-40 flex justify-center items-center gap-4 hidden-visually transition-opacity duration-500">
    <div class="bg-black/80 backdrop-blur border border-gray-800 p-2 rounded-lg flex gap-4 items-center neon-box-magenta">

        <!-- Play/Pause Control -->
        <button id="playPauseBtn" class="w-12 h-12 rounded-full border border-cyan-500 text-cyan-500 hover:bg-cyan-500/20 flex items-center justify-center transition-all">
            <i class="fas fa-pause"></i>
        </button>

        <div class="h-8 w-px bg-gray-700 mx-2"></div>

        <div id="recStatus" class="text-xs uppercase font-bold tracking-widest text-gray-500 w-24 text-center">STANDBY</div>

        <button id="recordBtn" class="w-12 h-12 rounded-full border-2 border-red-500 flex items-center justify-center text-red-500 hover:bg-red-500/20 hover:shadow-[0_0_10px_#ff0000] transition-all">
            <div id="recIcon" class="w-4 h-4 bg-red-500 rounded-sm"></div>
        </button>
    </div>
</div>

<!-- Error Toast -->
<div id="errorToast" class="fixed top-4 right-4 z-50 bg-red-900/90 border border-red-500 text-red-100 px-6 py-4 hidden">
    <h3 class="font-bold">SYSTEM ERROR</h3>
    <p id="errorMsg" class="text-sm">Operation failed.</p>
</div>

<script>
    // --- Configuration ---
    const CONFIG = {
        tunnel: {
            ringCount: 40,
            baseSpeed: 2,
            maxSpeed: 20,
            depth: 3000,
            resolution: 64,
            gridStep: 8
        },
        video: {
            width: 1920,
            height: 1080
        }
    };

    // --- State Management ---
    const state = {
        isRecording: false,
        isPlaying: false,
        audioContext: null,
        analyser: null,
        dataArray: null,
        sourceNode: null,
        recordDest: null,
        mediaRecorder: null,
        recordedChunks: [],
        animationId: null,
        globalHue: 180,
        frameCount: 0
    };

    // --- DOM Elements ---
    const canvas = document.getElementById('visualizerCanvas');
    const ctx = canvas.getContext('2d');
    const startModal = document.getElementById('startModal');
    const controlsUI = document.getElementById('controlsUI');
    const selectFileBtn = document.getElementById('selectFileBtn');
    const audioInput = document.getElementById('audioInput');
    const startBtn = document.getElementById('startButton');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const recordBtn = document.getElementById('recordBtn');
    const recStatus = document.getElementById('recStatus');
    const recIcon = document.getElementById('recIcon');
    const audioElement = document.getElementById('audioElement');
    const sourceStatus = document.getElementById('sourceStatus');
    const fileInfo = document.getElementById('fileInfo');
    const errorToast = document.getElementById('errorToast');
    const errorMsg = document.getElementById('errorMsg');

    // --- Visualizer Classes ---

    class Tunnel {
        constructor() {
            this.rings = [];
            this.initRings();
            this.rotation = 0;
        }

        initRings() {
            for (let i = 0; i < CONFIG.tunnel.ringCount; i++) {
                this.rings.push({
                    z: (CONFIG.tunnel.depth / CONFIG.tunnel.ringCount) * i,
                    baseHue: i * (360 / CONFIG.tunnel.ringCount)
                });
            }
        }

        update(audioData) {
            const bass = audioData.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
            const speed = CONFIG.tunnel.baseSpeed + (bass / 255) * CONFIG.tunnel.maxSpeed;
            const mid = audioData.slice(20, 50).reduce((a, b) => a + b, 0) / 30;

            this.rotation += 0.002 + (mid / 255) * 0.01;
            state.globalHue += 0.5;

            this.rings.forEach(ring => {
                ring.z -= speed;
                if (ring.z <= 0) {
                    ring.z = CONFIG.tunnel.depth;
                }
            });

            this.rings.sort((a, b) => b.z - a.z);
        }

        draw(ctx, w, h, audioData) {
            const cx = w / 2;
            const cy = h / 2;

            const bass = audioData[5] / 255;
            const treble = audioData[100] / 255;
            const mid = audioData[40] / 255;

            const shakeX = bass > 0.8 ? (Math.random() - 0.5) * 15 : 0;
            const shakeY = bass > 0.8 ? (Math.random() - 0.5) * 15 : 0;

            let prevPoints = [];

            // Use additive blending for glow effect - MUCH faster than shadowBlur
            ctx.globalCompositeOperation = 'lighter';

            this.rings.forEach((ring, index) => {
                const factor = 300 / (ring.z + 10);
                const baseRadius = (w > h ? w : h) * factor * 0.6;

                if (ring.z <= 0 || factor > 20) return;

                const vertices = CONFIG.tunnel.resolution;
                let currentPoints = [];

                for (let i = 0; i < vertices; i++) {
                    const theta = (i / vertices) * 2 * Math.PI + this.rotation + (index * 0.02);
                    const wave1 = Math.sin(theta * 3 + index * 0.2 + state.frameCount * 0.02);
                    const wave2 = Math.sin(theta * 8 - index * 0.1 + state.frameCount * 0.05) * (bass * 0.5);
                    const wave3 = Math.sin(theta * 20 + state.frameCount * 0.1) * (treble * 0.2);
                    const distortion = 1 + (wave1 * 0.15) + (wave2 * 0.1) + (wave3 * 0.1);

                    const r = baseRadius * distortion;
                    const x = (cx + shakeX) + Math.cos(theta) * r;
                    const y = (cy + shakeY) + Math.sin(theta) * r;
                    currentPoints.push({x, y});
                }

                const hue = (state.globalHue + (index * 4) + (bass * 40)) % 360;
                const opacity = Math.min(1, (CONFIG.tunnel.depth - ring.z) / (CONFIG.tunnel.depth * 0.4));
                const color = `hsla(${hue}, 100%, 50%, ${opacity})`;

                // Boost line width slightly to compensate for lack of shadow
                ctx.lineWidth = (2 + (bass * 3)) * factor;
                ctx.strokeStyle = color;

                // Optimization: Removed expensive per-frame shadowBlur inside loop
                ctx.shadowBlur = 0;

                ctx.beginPath();
                currentPoints.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.closePath();
                ctx.stroke();

                if (prevPoints.length > 0) {
                    ctx.beginPath();
                    ctx.lineWidth = 1 * factor;
                    ctx.strokeStyle = `hsla(${hue}, 80%, 40%, ${opacity * 0.4})`;

                    for (let i = 0; i < vertices; i += CONFIG.tunnel.gridStep) {
                        ctx.moveTo(currentPoints[i].x, currentPoints[i].y);
                        ctx.lineTo(prevPoints[i].x, prevPoints[i].y);
                    }
                    ctx.stroke();

                    if (treble > 0.5) {
                        ctx.fillStyle = `hsla(${hue}, 100%, 80%, ${opacity})`;
                        const dotSize = 2.5 * factor;
                        for (let i = 0; i < vertices; i += CONFIG.tunnel.gridStep) {
                            ctx.fillRect(currentPoints[i].x - dotSize/2, currentPoints[i].y - dotSize/2, dotSize, dotSize);
                        }
                    }
                }

                prevPoints = currentPoints;
            });

            // Singularity - Keep effects here as it's only drawn once
            ctx.save();
            ctx.translate(cx + shakeX, cy + shakeY);
            // Composite is already 'lighter'

            const coreHue = (state.globalHue + 180) % 360;
            const coreRadius = 10 + (treble * 40);
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius * 2.5);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.1, `hsla(${coreHue}, 100%, 90%, 1)`);
            gradient.addColorStop(0.4, `hsla(${coreHue}, 100%, 60%, 0.6)`);
            gradient.addColorStop(1, `hsla(${coreHue}, 100%, 50%, 0)`);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, coreRadius * 3, 0, Math.PI * 2);
            ctx.fill();

            const ringCount = 4;
            for(let i = 0; i < ringCount; i++) {
                ctx.save();
                const direction = i % 2 === 0 ? 1 : -1;
                const speed = (0.02 + (i * 0.01)) * (1 + bass);
                ctx.rotate((state.frameCount * speed * direction) + (i * Math.PI / 4));

                const ringR = coreRadius * (1.2 + i * 0.6);
                ctx.beginPath();
                ctx.strokeStyle = `hsla(${coreHue}, 100%, 70%, ${0.8 - i * 0.15})`;
                ctx.lineWidth = 2 + (mid * 3);
                ctx.shadowBlur = 10; // Keep shadow only for center elements
                ctx.shadowColor = `hsla(${coreHue}, 100%, 50%, 1)`;

                const segments = 3 + i;
                for(let s = 0; s < segments; s++) {
                    const startAngle = (s / segments) * Math.PI * 2;
                    const gap = 0.5;
                    ctx.arc(0, 0, ringR, startAngle, startAngle + ((Math.PI * 2 / segments) - gap));
                    ctx.stroke();
                    ctx.beginPath();
                }
                ctx.restore();
            }

            if (mid > 0.3) {
                ctx.beginPath();
                const rays = 8;
                ctx.rotate(state.frameCount * -0.05);

                for(let i=0; i<rays; i++) {
                    const angle = (i / rays) * Math.PI * 2;
                    const len = coreRadius * (2 + bass * 6);

                    ctx.moveTo(0,0);
                    const x = Math.cos(angle) * len;
                    const y = Math.sin(angle) * len;
                    ctx.lineTo(x, y);
                }
                ctx.strokeStyle = `hsla(${coreHue}, 100%, 90%, ${mid})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.restore();

            // Reset standard drawing state
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
            ctx.globalCompositeOperation = 'source-over';
        }
    }

    // --- System Logic ---

    const tunnel = new Tunnel();

    function resizeCanvas() {
        // Force High Resolution for Video
        canvas.width = CONFIG.video.width;
        canvas.height = CONFIG.video.height;

        // Calculate Scale to Fit Window (Letterboxing/Contain)
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        const scale = Math.min(winW / CONFIG.video.width, winH / CONFIG.video.height);

        canvas.style.width = `${CONFIG.video.width * scale}px`;
        canvas.style.height = `${CONFIG.video.height * scale}px`;
    }

    function initAudioEngine() {
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            state.audioContext = new AudioContext();
            state.analyser = state.audioContext.createAnalyser();
            state.analyser.fftSize = 256;

            const bufferLength = state.analyser.frequencyBinCount;
            state.dataArray = new Uint8Array(bufferLength);

            if (!state.sourceNode) {
                state.sourceNode = state.audioContext.createMediaElementSource(audioElement);
                state.sourceNode.connect(state.analyser);
                state.analyser.connect(state.audioContext.destination);

                // Create destination for recorder
                state.recordDest = state.audioContext.createMediaStreamDestination();
                state.sourceNode.connect(state.recordDest);
            }

            return true;
        } catch (e) {
            console.error(e);
            showError("Web Audio API not supported.");
            return false;
        }
    }

    function renderLoop() {
        state.animationId = requestAnimationFrame(renderLoop);
        state.frameCount++;

        if (state.analyser && !audioElement.paused) {
            state.analyser.getByteFrequencyData(state.dataArray);
        } else if (state.dataArray && audioElement.paused) {
            for(let i=0; i<state.dataArray.length; i++) {
                state.dataArray[i] = Math.max(0, state.dataArray[i] - 5);
            }
        }

        // Standard fade
        ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (state.dataArray) {
            tunnel.update(state.dataArray);
            tunnel.draw(ctx, canvas.width, canvas.height, state.dataArray);
        }
    }

    // --- Recording Logic ---

    function setupRecorder() {
        // Capture the canvas stream
        const canvasStream = canvas.captureStream(60);
        let finalStream = canvasStream;

        // Mix in audio
        if (state.recordDest) {
            const audioTracks = state.recordDest.stream.getAudioTracks();
            if (audioTracks.length > 0) {
                finalStream = new MediaStream([...canvasStream.getVideoTracks(), ...audioTracks]);
            }
        }

        const mimeTypes = [
            'video/webm;codecs=vp9,opus',
            'video/webm;codecs=vp8,opus',
            'video/webm'
        ];

        let selectedMime = mimeTypes.find(type => MediaRecorder.isTypeSupported(type)) || '';

        if (!selectedMime) {
            if (MediaRecorder.isTypeSupported('video/webm')) selectedMime = 'video/webm';
            else {
                showError("Screen recording not supported.");
                return;
            }
        }

        try {
            // High bitrate for 1080p content
            state.mediaRecorder = new MediaRecorder(finalStream, { mimeType: selectedMime, videoBitsPerSecond: 8000000 });

            state.mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) state.recordedChunks.push(e.data);
            };

            state.mediaRecorder.onstop = saveRecording;

        } catch (e) {
            console.error(e);
            showError("Recorder initialization failed.");
        }
    }

    function toggleRecording() {
        if (!state.mediaRecorder) setupRecorder();
        if (!state.mediaRecorder) return;

        if (state.isRecording) {
            state.mediaRecorder.stop();
            state.isRecording = false;
            updateRecordUI(false);
        } else {
            state.recordedChunks = [];
            state.mediaRecorder.start();
            state.isRecording = true;
            updateRecordUI(true);
        }
    }

    function saveRecording() {
        const blob = new Blob(state.recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        a.download = `stargate-HD-${timestamp}.webm`;

        document.body.appendChild(a);
        a.click();

        setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 100);

        recStatus.innerText = "SAVED";
        setTimeout(() => {
            if(!state.isRecording) recStatus.innerText = "STANDBY";
        }, 2000);
    }

    function updateRecordUI(isRecording) {
        if (isRecording) {
            recStatus.innerText = "REC";
            recStatus.classList.add("text-red-500", "animate-pulse");
            recStatus.classList.remove("text-gray-500");
            recIcon.classList.remove("rounded-sm");
            recIcon.classList.add("rounded-none");
            recordBtn.classList.add("bg-red-500/10");
        } else {
            recStatus.innerText = "PROCESSING";
            recStatus.classList.remove("text-red-500", "animate-pulse");
            recStatus.classList.add("text-gray-500");
            recIcon.classList.add("rounded-sm");
            recIcon.classList.remove("rounded-none");
            recordBtn.classList.remove("bg-red-500/10");
        }
    }

    function showError(msg) {
        errorMsg.innerText = msg;
        errorToast.classList.remove('hidden');
        setTimeout(() => errorToast.classList.add('hidden'), 5000);
    }

    selectFileBtn.addEventListener('click', () => {
        audioInput.click();
    });

    audioInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const url = URL.createObjectURL(file);
            audioElement.src = url;
            sourceStatus.innerText = "LOCKED";
            sourceStatus.classList.remove("text-yellow-400", "blink");
            sourceStatus.classList.add("text-cyan-400");
            fileInfo.innerText = "> " + file.name;
            fileInfo.classList.remove('hidden');
            startBtn.disabled = false;
            startBtn.classList.remove('border-gray-800', 'text-gray-800', 'cursor-not-allowed');
            startBtn.classList.add('border-cyan-400', 'text-cyan-400', 'hover:bg-cyan-400/20', 'hover:shadow-[0_0_15px_#00ffff]');
        }
    });

    playPauseBtn.addEventListener('click', () => {
        if (audioElement.paused) {
            audioElement.play();
            state.isPlaying = true;
            playPauseBtn.innerHTML = '<i class="fas fa-pause"></i>';
            if(state.audioContext && state.audioContext.state === 'suspended') {
                state.audioContext.resume();
            }
        } else {
            audioElement.pause();
            state.isPlaying = false;
            playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
        }
    });

    // Auto Stop Logic
    audioElement.addEventListener('ended', () => {
        playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
        state.isPlaying = false;

        if (state.isRecording) {
            console.log("Audio ended. Stopping recording in 3 seconds...");
            setTimeout(() => {
                if (state.isRecording) {
                    toggleRecording();
                }
            }, 3000);
        }
    });

    startBtn.addEventListener('click', async () => {
        startBtn.innerHTML = '<i class="fas fa-circle-notch fa-spin"></i> ENGAGING...';

        const audioReady = initAudioEngine();
        if (!audioReady) return;

        if (state.audioContext.state === 'suspended') {
            await state.audioContext.resume();
        }

        try {
            await audioElement.play();
            state.isPlaying = true;
        } catch(e) {
            console.log("Autoplay blocked, user must interact via controls");
            playPauseBtn.innerHTML = '<i class="fas fa-play"></i>';
        }

        resizeCanvas();
        renderLoop();

        startModal.classList.add('hidden-visually');
        setTimeout(() => {
            startModal.classList.add('hidden');
            controlsUI.classList.remove('hidden-visually');
        }, 500);

        setugpRecorder();
        if (state.mediaRecorder && !state.isRecording) {
            toggleRecording();
        }
    });

    recordBtn.addEventListener('click', toggleRecording);
    window.addEventListener('resize', resizeCanvas);

</script>
</body>
</html>