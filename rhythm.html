<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm King 77 - Euclidean MIDI Sequencer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for a more refined look */
        :root {
            --primary-bg: #2a2a2a;
            --secondary-bg: #3a3a3a;
            --panel-bg: #4a4a4a;
            --panel-border: #6a6a6a;
            --text-color: #e0e0e0;
            --accent-color: #f0ad4e;
            --accent-glow: rgba(240, 173, 78, 0.7);
            --control-bg: #333333;
            --control-border: #555555;
            --thumb-color: #c0b090;
            --active-toggle: #5cb85c;
            --random-btn: #337ab7;
            --learn-btn: #d9534f;
            --save-load-btn: #5bc0de;
            --midi-util-btn: #f0ad4e;
            --refine-btn: #9b59b6;
            --quantize-btn: #2ecc71;
            --status-bg: rgba(0,0,0,0.8);
            --status-text: #fff;
        }

        html {
            transition: box-shadow 0.15s ease-out;
        }

        html.randomize-flash {
            box-shadow: inset 0 0 15px 5px var(--accent-glow);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-color);
            overscroll-behavior: none;
            font-size: 11px; /* Compressed UI */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .main-container {
            margin-bottom: 2rem;
            flex-grow: 1;
        }
        /* UI Enhancement: 3D panel effect */
        .synth-panel {
            background-color: #444;
            background-image: linear-gradient(to bottom, #4f4f4f, #3a3a3a);
            border: 1px solid #222;
            border-top-color: #555;
            border-radius: 10px; /* Compressed UI */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.1);
            padding: 0.5rem; /* Compressed UI */
            transition: opacity 0.4s ease-in-out, filter 0.4s ease-in-out, border-color 0.4s ease-in-out, box-shadow 0.4s ease-in-out;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 0.4rem; /* Compressed UI */
        }
        .synth-panel h2 {
            margin-bottom: 0.2rem; /* Reduced space */
            flex-shrink: 0;
            color: var(--text-color);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            font-size: 1.1em;
            font-weight: 700;
        }

        .synth-panel.track-pulse {
            animation: trackPulse 0.2s ease-out;
        }
        @keyframes trackPulse {
            from {
                border-color: var(--flash-color, var(--accent-color));
                box-shadow: 0 0 12px 2px var(--flash-glow, var(--accent-glow)), 0 4px 12px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.1);
            }
            to {
                border-color: #222;
                box-shadow: 0 4px 12px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.1);
            }
        }

        .control-slider-container { display: flex; align-items: center; gap: 0.4rem; }
        .number-input-container { display: flex; align-items: center; gap: 0.4rem; }
        .slider-button, .number-input-button {
            background-color: var(--control-border); color: var(--text-color); border: 1px solid var(--control-bg); border-radius: 5px;
            padding: 0.1rem 0.4rem; font-size: 0.9rem; font-weight: bold; line-height: 1; cursor: pointer; user-select: none;
            transition: background-color 0.1s ease;
        }
        .slider-button:hover, .number-input-button:hover { background-color: var(--panel-border); }

        .control-slider {
            -webkit-appearance: none; appearance: none; width: 100%; height: 18px;
            background: #2a2a2a; border-radius: 8px; border: 1px solid #222;
            outline: none; cursor: pointer; flex-grow: 1; box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }
        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 24px; height: 24px;
            background-image: linear-gradient(to bottom, #e0e0e0, #a0a0a0);
            border-radius: 6px; border: 1px solid #555; cursor: grab;
            box-shadow: 0 2px 2px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
            transition: all 0.1s ease;
        }
        .control-slider::-moz-range-thumb {
            width: 24px; height: 24px;
            background-image: linear-gradient(to bottom, #e0e0e0, #a0a0a0);
            border-radius: 6px; border: 1px solid #555; cursor: grab;
            box-shadow: 0 2px 2px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
            transition: all 0.1s ease;
        }
        .control-slider:hover::-webkit-slider-thumb, .control-slider:hover::-moz-range-thumb {
            background-image: linear-gradient(to bottom, var(--accent-color), #d88c1b);
            box-shadow: 0 0 6px var(--accent-glow), 0 2px 2px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
        }

        .push-button {
            font-family: 'Inter', sans-serif; background-color: #585858; background-image: linear-gradient(to bottom, #6a6a6a, #4a4a4a);
            color: var(--text-color); border: 1px solid #333; border-top-color: #777; padding: 0.2rem 0.6rem;
            border-radius: 6px; text-transform: capitalize; font-weight: bold; font-size: 0.65rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.15);
            transition: all 0.1s ease-in-out; height: 28px; display: inline-flex; align-items: center; justify-content: center;
        }
        .push-button.icon-button { font-size: 1rem; padding: 0.3rem; width: 28px; height: 28px; }
        .push-button:active, .push-button.active {
            background-image: linear-gradient(to top, #6a6a6a, #4a4a4a); box-shadow: 0 1px 1px rgba(0,0,0,0.4), inset 0 2px 3px rgba(0,0,0,0.4);
            transform: translateY(1px); border-top-color: #333;
        }
        .push-button.active { background-image: linear-gradient(to top, var(--accent-color), #d88c1b); color: #333; }
        .push-button:disabled { opacity: 0.5; cursor: not-allowed; background-image: none; box-shadow: none; }

        #playStopButton { background-color: #5cb85c; background-image: linear-gradient(to bottom, #7fdf7f, #5cb85c); color: white; }
        #playStopButton.stop-state { background-color: #d9534f; background-image: linear-gradient(to bottom, #e47875, #d9534f); }
        #playStopButton:active { background-image: linear-gradient(to top, #7fdf7f, #5cb85c); }
        #playStopButton.stop-state:active { background-image: linear-gradient(to top, #e47875, #d9534f); }

        .learn-cc-button, .note-learn-button {
            background-color: var(--learn-btn); color: white; flex-shrink: 0; padding: 0.1rem 0.4rem; font-size: 0.65rem;
            border-radius: 5px; border: 1px solid #c9302c; box-shadow: 0 1px 1px rgba(0,0,0,0.3);
        }
        .learn-cc-button:hover, .note-learn-button:hover { background-color: #c9302c; }
        .learn-cc-button.learning, .note-learn-button.learning { background-color: #ffc107; color: #333; animation: pulseLearn 1s infinite alternate; }
        @keyframes pulseLearn { from { box-shadow: 0 0 4px #ffc107; } to { box-shadow: 0 0 12px #ffc107; } }
        .learn-cc-button.mapped { background-color: #4CAF50; border-color: #337a36; }

        .randomize-button { background-color: var(--random-btn); color: white; background-image: linear-gradient(to bottom, #5d9cec, #337ab7);}
        .master-randomize-button { background-color: #f0ad4e; color: #333; background-image: linear-gradient(to bottom, #f3c27a, #f0ad4e);}
        .re-init-midi-button { background-color: #6c757d; background-image: linear-gradient(to bottom, #868e96, #6c757d);}
        .save-load-button { background-color: var(--save-load-btn); color: white; background-image: linear-gradient(to bottom, #81d4fa, #5bc0de);}
        .midi-utility-button { background-color: var(--midi-util-btn); color: #333; background-image: linear-gradient(to bottom, #f3c27a, #f0ad4e);}
        .refine-button { background-color: var(--refine-btn); background-image: linear-gradient(to bottom, #af7ac5, #9b59b6); color: white; }
        .refine-button:active { background-image: linear-gradient(to top, #af7ac5, #9b59b6); }
        .quantize-button { background-color: var(--quantize-btn); background-image: linear-gradient(to bottom, #58d68d, #2ecc71); color: white; }
        .quantize-button:active { background-image: linear-gradient(to top, #58d68d, #2ecc71); }
        .try-me-button { background-color: #9b59b6; background-image: linear-gradient(to bottom, #af7ac5, #9b59b6); color:white; }

        .pattern-display { display: flex; justify-content: center; align-items: center; margin-top: 0.2rem; height: 20px; gap: 3px; }
        .pattern-step {
            width: 10px; height: 10px; background-color: #333; border-radius: 50%;
            transition: background-color 0.1s ease-out, transform 0.1s ease-out; flex-shrink: 0; border: 1px solid #222;
            box-shadow: inset 0 1px 1px rgba(0,0,0,0.5);
        }
        .pattern-step.active { background-color: var(--accent-color); box-shadow: 0 0 4px var(--accent-glow), inset 0 1px 1px rgba(255,255,255,0.3);}
        .pattern-step.current { background-color: #fff; border: 1px solid var(--accent-color); transform: scale(1.3); box-shadow: 0 0 6px rgba(255,255,255,0.9); }

        label { display: block; margin-bottom: 0.1rem; font-size: 0.7rem; font-family: 'Inter', sans-serif; white-space: nowrap; margin-right: 0.5rem; color: var(--accent-color); text-shadow: 0 1px 1px #000; text-transform: capitalize; }
        h1, h2, h3, label, .push-button { font-family: 'Inter', sans-serif; }
        h1 {font-weight: 700;}
        label[for="scaleRootSelect"], label[for="scaleTypeSelect"] {text-transform: uppercase;}
        select, input[type="number"], input[type="text"] {
            background-color: var(--control-bg); border: 1px solid #222; color: var(--text-color); padding: 0.3rem; border-radius: 5px; width: 100%; font-size: 0.75rem;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }
        input[type="number"] { text-align: center; }

        .value-display { font-family: 'Inter', sans-serif; color: var(--text-color); font-size: 0.75rem; min-width: 25px; text-align: right; flex-grow: 1; text-shadow: 0 1px 1px #000; }
        .control-group { display: flex; flex-direction: column; margin-bottom: 0; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.2rem; }
        .checkbox-label-container { display: flex; align-items: center; gap: 0.4rem; font-size: 0.75rem; margin-top: 0.2rem; cursor: pointer; color: var(--text-color); }
        .checkbox-label-container input[type="checkbox"] { width: 14px; height: 14px; accent-color: var(--accent-color); border-radius: 3px; }

        #sequencerWrapperPanel { width: 100%; }
        #sequencerTracksContainer { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.5rem; padding: 0.5rem 0; margin-left: auto; margin-right: auto; }
        #sequencerTracksContainer > .synth-panel { margin-bottom: 0; min-width: 280px; max-width: 320px; flex: 1 1 280px; }

        .explanation-text-footer { font-size: 0.8rem; line-height: 1.4; color: #b0b0b0; text-align: center; padding: 1rem; max-width: 700px; margin: 1rem auto 0 auto; border-top: 1px solid var(--control-border); }
        .note-input-group { display: flex; align-items: center; gap: 0.25rem; }
        .note-input-group > input { flex-grow: 1; }
        .note-learn-button { padding: 0.1rem 0.3rem; }

        #musicModePanel, #channelVolumesWrapper, #midiPanel, #randomizationSettingsContainer, #hintsPanel, #helpPanel, #hotkeysPanel, #locksPanel { display: none; }
        body.music-mode-active #musicModePanel { display: flex; }
        #appContainer { display: flex; flex-direction: column; gap: 0.5rem; flex-grow: 1; }
        #mainContent { flex-grow: 1; min-width: 0; display: flex; flex-direction: column; }

        #musicModeLog {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.85rem;
            height: 90px;
            background-color: rgba(0,0,0,0.3); border-radius: 6px; padding: 0.2rem 0.3rem;
            line-height: 1.4; overflow-y: auto; display: flex; flex-direction: column-reverse; color: var(--accent-color);
        }
        #musicModeLog > div.log-entry { padding-bottom: 0.1rem; margin-bottom: 0.1rem; border-bottom: 1px solid rgba(255,255,255,0.05); word-break: break-word; }
        #musicModeLog > div.log-separator { height: 1px; background-color: var(--control-border); margin: 3px 0; border: none; }

        #channelVolumesContainer { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 0.4rem 0.6rem; padding: 0.1rem; }
        #channelVolumesContainer .control-group { margin-bottom: 0; }
        #channelVolumesContainer .control-header { margin-bottom: 0.1rem; }
        #channelVolumesContainer .control-slider { height: 10px; }
        #channelVolumesContainer .control-slider::-webkit-slider-thumb { width: 18px; height: 18px; }
        #channelVolumesContainer .control-slider::-moz-range-thumb { width: 18px; height: 18px; }
        #channelVolumesContainer label { font-size: 0.65rem; }

        #octaveSelector { display: flex; justify-content: center; }
        #musicModePresetContainer { display: grid; grid-template-columns: repeat(auto-fit, minmax(55px, 1fr)); gap: 0.25rem;}
        #musicModePresetContainer .radio-label { font-size: 0.7rem; }

        .radio-label {
            display: inline-flex; align-items: center; background-color: var(--control-bg); border: 1px solid var(--control-border);
            padding: 0.2rem 0.5rem; transition: all 0.1s ease; font-size: 0.75rem; cursor: pointer; justify-content: center;
        }
        .radio-label input { display: none; }
        .radio-label:hover { background-color: var(--panel-border); z-index: 1; position: relative; }
        .radio-label.selected { background-color: var(--accent-color); border-color: #f8c57a; z-index: 2; position: relative; }
        .radio-label.selected span { color: var(--primary-bg); font-weight: bold; }

        #octaveSelector .radio-label { padding: 0.2rem; width: 24px; text-align: center; }
        #octaveSelector .radio-label:not(:first-child) { margin-left: -1px; }
        #octaveSelector .radio-label:first-child { border-radius: 6px 0 0 6px;}
        #octaveSelector .radio-label:last-child { border-radius: 0 6px 6px 0;}

        #musicModePresetContainer .radio-label { border-radius: 6px; margin-left: 0; }

        #logSection { display: none; }
        body.music-mode-active #logSection { display: flex; }

        #bottom-panels-container { display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: stretch; }
        #bottom-panels-container > .synth-panel { flex-grow: 1; flex-shrink: 1; flex-basis: 280px; height: auto; }
        #masterControlPanel { order: 1; max-width: 350px; }
        #viewPanel { order: 2; flex: 1 1 200px; max-width: 280px; }
        #midiPanel { order: 3; flex: 1 1 200px; max-width: 280px; }
        #musicModePanel { order: 4; flex: 1 1 200px; max-width: 280px; }
        #randomizationSettingsContainer { order: 5; flex: 1 1 200px; max-width: 280px; }
        #channelVolumesWrapper { order: 6; flex: 1 1 300px; max-width: 400px; }
        #hintsPanel { order: 7; flex: 1 1 280px; display: flex; flex-direction: column;}
        #helpPanel { order: 8; width: 100%; margin-top: 0.5rem; max-width: 900px; margin-left:auto; margin-right: auto;}
        #hotkeysPanel { order: 9; width: 100%; margin-top: 0.5rem; }

        #hintsPanel, #helpPanel, #hotkeysPanel {
            display: flex;
            flex-direction: column;
            min-height: 150px; /* Ensure panel has some height */
        }
        #helpPanel .help-content-container, #hotkeysPanel .hotkeys-content-container {
            flex-grow: 1;
            min-height: 0; /* Allows the log to actually grow */
            display: flex; /* Make sure log section itself is a flex container */
            flex-direction: column;
        }
        #helpPanel .text-sm, #hotkeysPanel #hotkeysList {
            flex-grow: 1;
            overflow-y: auto;
            max-height: 300px;
        }
        #hintsPanel #logSection {
            flex-grow: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }
        #musicModeLog, #helpPanel .text-sm {
            flex-grow: 1;
        }

        .toggle-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; }

        #statusBar {
            position: fixed; bottom: 0; left: 0; width: 100%; background-color: var(--status-bg); color: var(--status-text);
            padding: 0.4rem 1rem; text-align: center; font-size: 0.8rem; z-index: 1000; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; border-top: 1px solid var(--accent-color);
        }
        #statusBar.visible { opacity: 1; visibility: visible; }
        #hintContent {
            background-color: var(--control-bg); border: 1px solid var(--control-border); border-radius: 6px; padding: 0.5rem;
            min-height: 60px; display: flex; align-items: center; justify-content: center; color: #b0b0b0; font-style: italic;
        }

        #app-background {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-size: cover;
            transition: all 1s ease-in-out; opacity: 0.8; filter: grayscale(0.5);
        }
        #app-background.bg-default { background-color: var(--primary-bg); background-image: radial-gradient(circle at center, rgba(60,60,60,0.1) 1px, transparent 1px); background-size: 20px 20px; }
        #app-background.bg-music-mode {
            background-color: #3b3b3b; filter: grayscale(0);
            background-image: linear-gradient(0deg, transparent 24%, rgba(240,173,78,0.05) 25%, rgba(240,173,78,0.05) 26%, transparent 27%, transparent 74%, rgba(240,173,78,0.05) 75%, rgba(240,173,78,0.05) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(240,173,78,0.05) 25%, rgba(240,173,78,0.05) 26%, transparent 27%, transparent 74%, rgba(240,173,78,0.05) 75%, rgba(240,173,78,0.05) 76%, transparent 77%, transparent);
            background-size: 80px 80px;
        }

        #confirmationDialog {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none; justify-content: center; align-items: center;
            z-index: 2000;
        }
        #confirmationDialog.visible { display: flex; }
        .dialog-content {
            background: var(--panel-bg); border: 1px solid var(--panel-border);
            padding: 1.5rem; border-radius: 10px; text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .dialog-content p { font-size: 1rem; margin-bottom: 1.5rem; }
        .dialog-buttons button { margin: 0 0.5rem; }

        #hotkeysList {
            display: grid;
            grid-template-columns: 1fr; /* Single column */
            gap: 0.5rem;
            padding: 0.5rem;
        }
        .hotkey-item {
            display: flex;
            justify-content: space-between;
            background-color: var(--control-bg);
            padding: 0.4rem 0.6rem;
            border-radius: 5px;
            border: 1px solid var(--control-border);
        }
        .hotkey-key {
            font-weight: bold;
            color: var(--accent-color);
        }

    </style>
</head>
<body class="p-1 md:p-2">

<div id="app-background" class="bg-default"></div>

<header class="text-center mb-2">
    <h1 class="text-2xl md:text-3xl font-bold">Rhythm King 77</h1>
    <p class="text-xs md:text-sm text-gray-400">Euclidean MIDI Sequencer</p>
</header>

<div id="appContainer">
    <div id="mainContent" class="flex-grow">
        <div class="flex flex-col gap-2 main-container">
            <div id="sequencerWrapperPanel" class="w-full synth-panel">
                <h2 class="text-lg font-semibold text-center">Euclidean Sequencer Tracks</h2>
                <div id="sequencerTracksContainer"></div>
            </div>

            <div id="bottom-panels-container">
                <div id="masterControlPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center">Master Control</h2>

                    <div id="toolbar" class="flex flex-wrap items-center justify-center gap-2">
                        <button id="playStopButton" class="push-button icon-button" title="Start or stop all sequences (Spacebar)">&#x25B6;</button>
                        <button id="tryMeButton" class="push-button icon-button try-me-button" title="Try a new harmonious setup (T)">✨</button>
                        <button id="refineButton" class="push-button icon-button refine-button" title="Refine current notes (R)">⚖️</button>
                        <button id="quantizeNotesButton" class="push-button icon-button quantize-button" title="Quantize all notes to scale (Q)">🎼</button>
                        <button id="saveStateButton" class="push-button save-load-button icon-button" title="Save current state (S)">&#128190;</button>
                        <button id="loadStateButton" class="push-button save-load-button icon-button" title="Load last saved state (L)">&#128193;</button>
                    </div>

                    <div class="control-group">
                        <label for="numTracksInput">Number of Tracks:</label>
                        <div class="number-input-container">
                            <button class="number-input-button" data-target="numTracksInput" data-action="decrement" title="Decrease number of tracks">&minus;</button>
                            <input type="number" id="numTracksInput" min="1" max="12" value="4" title="Set the total number of sequencer tracks (1-12)">
                            <button class="number-input-button" data-target="numTracksInput" data-action="increment" title="Increase number of tracks">+</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-header">
                            <label for="bpmSlider">Tempo (BPM):</label> <span id="bpmValue" class="value-display">45</span>
                            <button id="bpmSliderLearnCc" class="learn-cc-button ml-2" data-param-id="bpmSlider" title="Map Master Tempo to a MIDI CC knob/fader">L</button>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="bpmSlider" data-action="decrement" title="Decrease Tempo">&minus;</button>
                            <input type="range" id="bpmSlider" min="20" max="240" value="45" class="control-slider" title="Adjust master tempo (20-240 BPM)">
                            <button class="slider-button" data-target="bpmSlider" data-action="increment" title="Increase Tempo">+</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-header">
                            <label for="masterVolumeSlider">Master Volume:</label> <span id="masterVolumeValue" class="value-display">100</span>
                            <button id="masterVolumeLearnCc" class="learn-cc-button ml-2" data-param-id="masterVolumeSlider" title="Map Master Volume to a MIDI CC knob/fader">L</button>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="masterVolumeSlider" data-action="decrement" title="Decrease Volume">&minus;</button>
                            <input type="range" id="masterVolumeSlider" min="0" max="127" value="100" class="control-slider" title="Adjust master output volume (scales all note velocities)">
                            <button class="slider-button" data-target="masterVolumeSlider" data-action="increment" title="Increase Volume">+</button>
                        </div>
                    </div>
                </div>

                <div id="viewPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center">Panel Toggles</h2>
                    <div id="viewTogglesContainer" class="toggle-grid">
                        <label class="checkbox-label-container" title="Show/Hide the Sound Setup panel"><input type="checkbox" data-view-toggle="midiPanel" id="showMidiPanel" checked> Sound</label>
                        <label class="checkbox-label-container" title="Show/Hide the Randomization panel"><input type="checkbox" data-view-toggle="randomizationSettingsContainer" id="showRandomizePanel" checked> Randomize</label>
                        <label class="checkbox-label-container" title="Show/Hide the Channel Volumes panel"><input type="checkbox" data-view-toggle="channelVolumesWrapper" id="showVolumesPanel"> Volumes</label>
                        <label class="checkbox-label-container" title="Show/Hide the Hints & Log panel"><input type="checkbox" data-view-toggle="hintsPanel" id="showHintsLogPanel" checked> Hints & Log</label>
                        <label class="checkbox-label-container" title="Toggle Music Mode for automatic, generative patterns (M)"><input type="checkbox" id="musicModeToggle"> Music Mode</label>
                        <label class="checkbox-label-container" title="Show/Hide the Help panel"><input type="checkbox" data-view-toggle="helpPanel" id="showHelpPanel"> Help</label>
                        <label class="checkbox-label-container" title="Show/Hide the Hotkeys panel"><input type="checkbox" data-view-toggle="hotkeysPanel" id="showHotkeysPanel"> Hotkeys</label>
                    </div>
                </div>

                <div id="midiPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center">Sound Setup</h2>
                    <div class="control-group">
                        <div class="grid grid-cols-2 gap-2">
                            <button id="reInitMidiButton" class="push-button w-full" title="Rescan for MIDI devices if you plugged one in after loading the page">Reset MIDI</button>
                            <button id="allNotesOffButton" class="push-button midi-utility-button w-full" title="Sends an 'All Notes Off' panic message on all channels to stop stuck notes">Stop Notes</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="midiOutSelect">Output Device:</label>
                        <select id="midiOutSelect" title="Select the device or virtual synth to send notes to"></select>
                    </div>
                    <div class="control-group">
                        <label for="midiChannelSelect">Global Channel:</label>
                        <select id="midiChannelSelect" title="Select the default MIDI channel (1-16) for all tracks set to 'Global'"></select>
                    </div>
                    <div class="control-group mt-2">
                        <button id="setAllToGlobal" class="push-button w-full" title="Set all tracks to use the Global Channel">Set All To Global</button>
                    </div>
                </div>

                <div id="randomizationSettingsContainer" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center">Randomization</h2>
                    <div class="control-group">
                        <button id="masterRandomizeButton" class="push-button master-randomize-button w-full" title="Randomize all enabled parameters on all active tracks (R)">Randomize All Active</button>
                    </div>

                    <div class="control-group border-t border-b border-gray-700 py-1 my-1">
                        <label class="font-bold text-xs uppercase text-center">Global Scale</label>
                        <div class="grid grid-cols-2 gap-2 mt-1">
                            <div>
                                <label for="scaleRootSelect">Root</label>
                                <select id="scaleRootSelect" title="Set the root note for the global scale"></select>
                            </div>
                            <div>
                                <label for="scaleTypeSelect">Type</label>
                                <select id="scaleTypeSelect" title="Set the type of the global scale"></select>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label for="octaveSelector" class="text-center">Base Octave</label>
                        <div id="octaveSelector" title="Set the base octave for randomized notes"></div>
                    </div>
                    <div id="randomizeOptionsContainer" class="control-group toggle-grid">
                        <label class="checkbox-label-container" title="Randomize the MIDI note of each track"><input type="checkbox" class="randomize-option" id="randomizeNoteCheck" checked> Notes</label>
                        <label class="checkbox-label-container" title="Randomize the number of beats (pulses) in each track"><input type="checkbox" class="randomize-option" id="randomizePulsesCheck" checked> Pulses</label>
                        <label class="checkbox-label-container" title="Randomize the pattern's starting point (rotation)"><input type="checkbox" class="randomize-option" id="randomizeRotationCheck" checked> Rotation</label>
                        <label class="checkbox-label-container" title="Randomize the musical scale for all tracks"><input type="checkbox" class="randomize-option" id="randomizeScaleCheck" checked> Scale</label>
                        <label class="checkbox-label-container" title="Randomize the velocity (loudness) of each track"><input type="checkbox" class="randomize-option" id="randomizeVelocityCheck" checked> Velocity</label>
                        <label class="checkbox-label-container" title="Randomize the base octave during generative changes"><input type="checkbox" class="randomize-option" id="randomizeOctaveCheck"> Octave</label>
                        <label class="checkbox-label-container" title="Allow the chord type to be randomized for Jazz/Rock modes"><input type="checkbox" class="randomize-option" id="randomizeChordCheck"> Chord</label>
                        <label class="checkbox-label-container" id="randomizeInstrumentsContainer" title="Randomize the internal synth instrument for each track" style="display: none;"><input type="checkbox" class="randomize-option" id="randomizeInstrumentsCheck"> Instruments</label>
                    </div>
                </div>

                <div id="musicModePanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center">Music Mode</h2>
                    <div class="control-group">
                        <div class="control-header">
                            <label for="randomIntervalSlider">Interval (Bars):</label>
                            <span id="randomIntervalValue" class="value-display">4</span>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="randomIntervalSlider" data-action="decrement" title="Decrease randomization interval">&minus;</button>
                            <input type="range" id="randomIntervalSlider" min="1" max="16" value="4" class="control-slider" title="Set how often Music Mode triggers a change (in musical bars)">
                            <button class="slider-button" data-target="randomIntervalSlider" data-action="increment" title="Increase randomization interval">+</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label class="text-center">Mode</label>
                        <div id="musicModePresetContainer"></div>
                    </div>
                    <div class="control-group">
                        <label for="chordTypeSelect">Chord Type</label>
                        <select id="chordTypeSelect" title="Select the chord type for applicable modes"></select>
                    </div>

                    <div class="control-group">
                        <button id="musicModeNextButton" class="push-button w-full" title="Manually trigger the next generative change (N)">Trigger Next</button>
                    </div>
                    <div class="control-group border-t border-gray-700 pt-2 mt-1 toggle-grid">
                        <label class="checkbox-label-container" title="Apply the Refine algorithm after each generative change to improve musicality"><input type="checkbox" id="musicModeRefineCheck"> Auto-Refine</label>
                        <label class="checkbox-label-container" title="Automatically quantize notes to the selected scale after each generative change"><input type="checkbox" id="musicModeQuantizeCheck"> Auto-Quantize</label>
                    </div>
                </div>

                <div id="channelVolumesWrapper" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center">Channel Volumes</h2>
                    <div id="channelVolumesContainer"></div>
                </div>

                <div id="locksPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center">Parameter Locks</h2>
                    <div class="toggle-grid">
                        <label class="checkbox-label-container" title="Lock all 'Steps' sliders so they move together. The first track's value becomes the master value."><input type="checkbox" id="lockStepsCheckbox"> Lock All Steps</label>
                        <label class="checkbox-label-container" title="Prevent Pulses from being randomized"><input type="checkbox" id="lockPulsesCheckbox"> Lock Pulses</label>
                        <label class="checkbox-label-container" title="Prevent Rotation from being randomized"><input type="checkbox" id="lockRotationCheckbox"> Lock Rotation</label>
                        <label class="checkbox-label-container" title="Prevent Velocity from being randomized"><input type="checkbox" id="lockVelocityCheckbox"> Lock Velocity</label>
                        <label class="checkbox-label-container" title="Prevent Instruments from being randomized"><input type="checkbox" id="lockInstrumentsCheckbox"> Lock Instruments</label>
                    </div>
                </div>

                <div id="hintsPanel" class="synth-panel">
                    <div id="logSection" class="control-group">
                        <label class="font-bold text-xs">Music Mode Log</label>
                        <div id="musicModeLog"></div>
                    </div>
                </div>

                <div id="helpPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center">Instructions</h2>
                    <div class="help-content-container">
                        <div class="text-sm px-4 space-y-2">
                            <p><strong>Welcome to Rhythm King 77!</strong> This is a generative music sequencer. It creates rhythms and melodies that you can send to its internal synthesizer or your own MIDI hardware/software.</p>
                            <p><strong>Getting Started (Internal Synth):</strong> Just press the <strong>Play button (or Spacebar)</strong> to hear the default pattern. The app defaults to its built-in synth, so no setup is needed. Each of the 16 channels has a different instrument sound.</p>
                            <p><strong>Exploring Tracks:</strong> Each grey box at the top is a "track". You can change a track's rhythm using the "Steps" (pattern length) and "Pulses" (number of notes) sliders. Use the "Note" input to set its pitch. Select a specific instrument for a track using the "Channel" dropdown.</p>
                            <p><strong>Music Mode & Randomization:</strong> The real power is in generating new ideas. <strong>Music Mode</strong> is on by default and will automatically change the pattern every few bars. Use the main <strong>"Randomize All Active"</strong> button (hotkey: R) to create a completely new sequence instantly. Tweak the options in the "Randomization" panel to control what gets changed.</p>
                            <p><strong>Background Operation:</strong> Please note that to save system resources, most modern browsers will pause audio and visual updates when this tab is not in the foreground. Generative changes from Music Mode will not occur while the tab is in the background.</p>
                        </div>
                    </div>
                    <div id="hintContainer" class="control-group mt-2 pt-2 border-t border-gray-700">
                        <label class="font-bold text-xs">Helpful Hint</label>
                        <div id="hintContent"></div>
                    </div>
                </div>
                <div id="hotkeysPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center">Hotkeys</h2>
                    <div id="hotkeysList"></div>
                </div>
            </div>
        </div>

        <footer id="explanationContainer" class="explanation-text-footer">
            <p>Euclidean rhythms are generated by distributing beats as evenly as possible over a set number of time steps.</p>
        </footer>
    </div>
</div>
<div id="statusBar"><div id="statusBar-content"></div></div>
<div id="confirmationDialog">
    <div class="dialog-content">
        <p id="dialogMessage">Are you sure?</p>
        <div class="dialog-buttons">
            <button id="dialogConfirm" class="push-button reset-button">Confirm</button>
            <button id="dialogCancel" class="push-button">Cancel</button>
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        const RhythmKingApp = {
            // --- CONSTANTS AND CONFIGURATION ---
            MAX_TRACKS: 12,
            MANUAL_SAVE_KEY: 'rhythmKing77_manualSave_v34',
            AUTOSAVE_KEY: 'rhythmKing77_autoSave_v34',
            APP_RUN_COUNT_KEY: 'rhythmKing77_runCount',
            SCALES: { 'Major': [0, 2, 4, 5, 7, 9, 11], 'Minor': [0, 2, 3, 5, 7, 8, 10], 'Dorian': [0, 2, 3, 5, 7, 9, 10], 'Phrygian': [0, 1, 3, 5, 7, 8, 10], 'Lydian': [0, 2, 4, 6, 7, 9, 11], 'Mixolydian': [0, 2, 4, 5, 7, 9, 10], 'Locrian': [0, 1, 3, 5, 6, 8, 10], 'Major Pentatonic': [0, 2, 4, 7, 9], 'Minor Pentatonic': [0, 3, 5, 7, 10], 'Blues': [0, 3, 5, 6, 7, 10], 'Harmonic Minor': [0, 2, 3, 5, 7, 8, 11], 'Whole Tone': [0, 2, 4, 6, 8, 10], 'Chromatic': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] },
            NOTE_NAMES: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
            CHORD_TYPES: { 'Random': null, 'Maj7': [0, 4, 7, 11], 'min7': [0, 3, 7, 10], 'Dom7': [0, 4, 7, 10], 'min7b5': [0, 3, 6, 10], 'dim7': [0, 3, 6, 9], 'Power': [0, 7] },
            HINTS: [ "Click 'L' to map a MIDI CC. Click a green 'L' to un-map.", "Toggle 'Music Mode' for generative grooves.", "Hit 'Random' on tracks for instant variations.", "Use the 'Save' icon to create a restore point.", "Hold +/- buttons for rapid value changes.", "The 'Stop Notes' button sends an 'All Notes Off' command.", "Use the 🎼 button to snap all notes to the selected scale." ],
            VIEW_PANEL_MAP: { showMidiPanel: 'midiPanel', showRandomizePanel: 'randomizationSettingsContainer', showVolumesPanel: 'channelVolumesWrapper', showHintsLogPanel: 'hintsPanel', showHelpPanel: 'helpPanel', showHotkeysPanel: 'hotkeysPanel', showLocksPanel: 'locksPanel' },
            MUSIC_MODE_PRESETS: { off: { label: "Off", multi: false, options: { note: false, pulses: false, rotation: false, scale: false, velocity: false } }, single: { label: "Single", multi: false, options: { note: true, pulses: true, rotation: true, scale: true, velocity: true } }, multi: { label: "Multi", multi: true, options: { note: true, pulses: true, rotation: true, scale: true, velocity: true } }, melodic: { label: "Melodic", multi: true, options: { note: true, pulses: false, rotation: false, scale: true, velocity: false } }, jazz: { label: "Jazz", multi: true, options: { note: true, pulses: false, rotation: false, scale: false, velocity: true } }, rock: { label: "Rock", multi: true, options: { note: true, pulses: false, rotation: false, scale: false, velocity: true } }, baroque: { label: "Baroque", multi: true, options: { note: true, pulses: true, rotation: false, scale: true, velocity: true } }, fifths: { label: "Fifths", multi: true, options: { note: true, pulses: true, rotation: true, scale: false, velocity: true } }, berlin: { label: "Berlin", multi: true, options: { note: true, pulses: true, rotation: true, scale: false, velocity: true } }, },
            INTERNAL_SYNTH_NAMES: ['E-Piano', 'Chorus Pad', '8-bit Kick', 'Triangle Lead', 'AM Bass', 'Theremin', 'Square Pluck', 'Duo Arp', 'Synth Choir', 'Metal Synth', 'Wobble Bass', 'Flute', 'Soft Pad', 'Funky Clav', 'Distorted Lead', 'Sub Bass'],
            HOTKEYS: {'Spacebar': 'Play / Pause', 'T': 'Try Me!', 'R': 'Randomize All', 'Q': 'Quantize Notes', 'S': 'Save State', 'L': 'Load State', 'N': 'Trigger Next', 'M': 'Toggle Music Mode'},

            // --- APPLICATION STATE & CACHE ---
            dom: {},
            state: {},
            internalSynths: [],
            transportLoops: [],
            timedRandomEvent: null,
            statusTimeout: null,
            autosaveTimeout: null,
            hintInterval: null,
            activeTrackNotes: {},
            midiAccess: null,
            midiOutput: null,
            currentLearningControl: null,
            noteLearningTrack: null,
            currentRandomizationScale: [],
            baroqueProgression: [0, 7, 9, 5],
            baroqueStep: 0,
            autoRepeatTimeoutId: null,
            autoRepeatIntervalId: null,
            lastRandomizedTrackId: null,
            diatonicChordQualities: { Major: ['maj7', 'min7', 'min7', 'maj7', 'dom7', 'min7', 'min7b5'], Minor: ['min7', 'min7b5', 'maj7', 'min7', 'min7', 'maj7', 'dom7'] },
            currentChordRoot: 0,
            masterVolumeNode: null,

            // --- INITIALIZATION ---
            async init() {
                try {
                    console.log("Rhythm King 77 Initializing...");
                    this.setupDOMCache();
                    this.createInitialUI();

                    let loadedState = null;
                    try {
                        const autoSaveJSON = localStorage.getItem(this.AUTOSAVE_KEY);
                        if (autoSaveJSON) loadedState = JSON.parse(autoSaveJSON);
                    } catch (e) {
                        console.error("Could not parse autosave, starting fresh.", e);
                        localStorage.removeItem(this.AUTOSAVE_KEY);
                    }

                    await this.loadState(loadedState);

                    await this.setupMIDI();
                    this.setupToneJS();
                    this.setupEventListeners();

                    if (loadedState) {
                        this.showStatusMessage("Autosave loaded.", 2000);
                    } else if (this.state.musicMode.enabled) {
                        await this.triggerGenerativeStep(); // Initial randomization if music mode is on
                    }
                    this.setupTimedRandomization();

                    this.hintInterval = setInterval(() => this.showHint(), 25000);
                    this.showHint();
                    this.handleHelpPanelVisibility();

                    console.log("Initialization complete.");
                } catch (error) {
                    document.body.innerHTML = `<div class="text-white text-center p-8"><h1>A critical error occurred on startup.</h1><p>Please clear your browser cache/storage for this page and try again. See the console for details.</p></div>`;
                    console.error("CRITICAL STARTUP ERROR:", error);
                }
            },

            setupDOMCache() {
                const ids = [
                    'playStopButton', 'masterRandomizeButton', 'saveStateButton', 'loadStateButton', 'refineButton', 'quantizeNotesButton', 'tryMeButton',
                    'reInitMidiButton', 'allNotesOffButton', 'numTracksInput',
                    'bpmSlider', 'bpmValue', 'bpmSliderLearnCc', 'masterVolumeSlider',
                    'masterVolumeValue', 'masterVolumeLearnCc', 'midiOutSelect', 'midiChannelSelect',
                    'sequencerTracksContainer', 'channelVolumesContainer', 'channelVolumesWrapper', 'setAllToGlobal',
                    'statusBar', 'statusBar-content', 'musicModeToggle', 'randomIntervalSlider',
                    'randomIntervalValue', 'randomizeNoteCheck', 'randomizePulsesCheck', 'randomizeChordCheck', 'randomizeInstrumentsContainer', 'randomizeInstrumentsCheck',
                    'randomizeRotationCheck', 'randomizeScaleCheck', 'randomizeVelocityCheck', 'randomizeOctaveCheck',
                    'musicModeNextButton', 'musicModeLog', 'hintContent', 'app-background',
                    'octaveSelector', 'viewTogglesContainer', 'randomizationSettingsContainer',
                    'musicModePanel', 'logSection', 'midiPanel', 'hintsPanel', 'viewPanel', 'helpPanel', 'hotkeysPanel', 'hotkeysList',
                    'appContainer', 'randomizeOptionsContainer', 'musicModePresetContainer', 'musicModeRefineCheck', 'musicModeQuantizeCheck',
                    'sequencerWrapperPanel', 'hintContainer', 'showRandomizePanel', 'showHintsLogPanel','showHelpPanel','showHotkeysPanel',
                    'scaleRootSelect', 'scaleTypeSelect', 'chordTypeSelect',
                    'confirmationDialog', 'dialogMessage', 'dialogConfirm', 'dialogCancel',
                    'locksPanel', 'showLocksPanel', 'lockStepsCheckbox', 'lockPulsesCheckbox', 'lockRotationCheckbox', 'lockVelocityCheckbox', 'lockInstrumentsCheckbox'
                ];
                ids.forEach(id => {
                    try {
                        const camelCaseId = id.replace(/-([a-z])/g, g => g[1].toUpperCase());
                        this.dom[camelCaseId] = document.getElementById(id);
                    } catch (e) {
                        console.error(`Error caching DOM element #${id}:`, e);
                    }
                });
            },

            setupEventListeners() {
                this.dom.playStopButton.addEventListener('click', () => this.handlePlayStop());
                document.body.addEventListener('keydown', (e) => {
                    if (e.target.tagName.toUpperCase() === 'INPUT' || e.target.tagName.toUpperCase() === 'SELECT') return;
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.handlePlayStop();
                    }
                    if (e.key.toLowerCase() === 'r') this.handleMasterRandomize();
                    if (e.key.toLowerCase() === 's') this.manualSaveState();
                    if (e.key.toLowerCase() === 'l') this.loadManualState();
                    if (e.key.toLowerCase() === 'q') this.handleQuantizeNotes(true);
                    if (e.key.toLowerCase() === 'n') this.triggerGenerativeStep();
                    if (e.key.toLowerCase() === 'm') this.dom.musicModeToggle.click();
                    if (e.key.toLowerCase() === 't') this.tryMe();

                });

                this.dom.tryMeButton.addEventListener('click', () => this.tryMe());
                this.dom.setAllToGlobal.addEventListener('click', () => this.setAllTracksToGlobal());
                this.dom.numTracksInput.addEventListener('change', (e) => this.handleNumTracksChange(e));
                this.dom.bpmSlider.addEventListener('input', e => this.updateState({ bpm: parseInt(e.target.value, 10) }));
                this.dom.masterVolumeSlider.addEventListener('input', e => this.updateState({ masterVolume: parseInt(e.target.value, 10) }));

                this.dom.saveStateButton.addEventListener('click', () => this.manualSaveState());
                this.dom.loadStateButton.addEventListener('click', () => this.loadManualState());
                this.dom.refineButton.addEventListener('click', () => this.handleRefine(true));
                this.dom.quantizeNotesButton.addEventListener('click', () => this.handleQuantizeNotes(true));

                this.dom.reInitMidiButton.addEventListener('click', async () => {
                    await Tone.Transport.stop();
                    this.panic();
                    await this.setupMIDI();
                    this.showStatusMessage("MIDI re-initialized.", 2000);
                });
                this.dom.allNotesOffButton.addEventListener('click', () => {
                    this.panic();
                    this.showStatusMessage("Stop Notes: All notes off sent.", 1500);
                });
                this.dom.midiOutSelect.addEventListener('change', () => this.updateMidiOutput());
                this.dom.midiChannelSelect.addEventListener('change', e => {
                    this.updateState({ globalMidiChannel: parseInt(e.target.value, 10) });
                    this.rebuildAllTrackLoops();
                });

                this.dom.locksPanel.addEventListener('change', (e) => this.handleGlobalLockChange(e));

                this.dom.scaleRootSelect.addEventListener('change', () => this.handleScaleChange());
                this.dom.scaleTypeSelect.addEventListener('change', () => this.handleScaleChange());
                this.dom.chordTypeSelect.addEventListener('change', e => this.updateState({ musicMode: { ...this.state.musicMode, chordType: e.target.value } }));
                this.dom.randomizeChordCheck.addEventListener('change', e => this.updateState({ musicMode: { ...this.state.musicMode, randomizeChord: e.target.checked } }));

                this.dom.viewTogglesContainer.addEventListener('change', (e) => this.handleViewToggle(e));

                this.dom.musicModeNextButton.addEventListener('click', () => this.triggerGenerativeStep());
                this.dom.masterRandomizeButton.addEventListener('click', () => this.handleMasterRandomize());

                this.dom.randomIntervalSlider.addEventListener('input', e => this.updateState({ musicMode: {...this.state.musicMode, interval: parseInt(e.target.value, 10) }}));

                this.dom.musicModeRefineCheck.addEventListener('change', e => this.updateState({ musicMode: { ...this.state.musicMode, refine: e.target.checked } }));
                this.dom.musicModeQuantizeCheck.addEventListener('change', e => this.updateState({ musicMode: { ...this.state.musicMode, autoQuantize: e.target.checked } }));

                this.dom.sequencerTracksContainer.addEventListener('click', (e) => this.handleTrackAction(e));
                this.dom.sequencerTracksContainer.addEventListener('input', (e) => this.handleTrackAction(e));
                this.dom.sequencerTracksContainer.addEventListener('change', (e) => this.handleTrackAction(e));

                document.body.addEventListener('click', (e) => this.handleBodyClick(e), true);

                document.body.addEventListener('mousedown', (e) => this.startAutoRepeat(e));
                document.body.addEventListener('mouseup', () => this.stopAutoRepeat());
                document.body.addEventListener('mouseleave', () => this.stopAutoRepeat());
                document.body.addEventListener('touchstart', (e) => this.startAutoRepeat(e), { passive: false });
                document.body.addEventListener('touchend', () => this.stopAutoRepeat());

                this.dom.randomizeOptionsContainer.addEventListener('change', (e) => this.handleRandomizeOptionChange(e));
                this.dom.octaveSelector.addEventListener('change', (e) => {
                    if (e.target.name === 'octaveSelect') {
                        this.handleOctaveChange(parseInt(e.target.value, 10));
                    }
                });

                this.dom.musicModePresetContainer.addEventListener('click', (e) => {
                    const label = e.target.closest('.radio-label');
                    if (!label) return;
                    const radio = label.querySelector('input');
                    if (radio && radio.name === 'musicModePreset') {
                        this.updateState({ musicMode: { ...this.state.musicMode, preset: radio.value }});
                    }
                });
            },

            // --- STATE MANAGEMENT ---
            getDefaultState() {
                return {
                    numTracks: 4, bpm: 45, masterVolume: 100, globalMidiChannel: 1, midiOutputId: 'internal_synth', ccMap: {},
                    channelVolumes: Array(16).fill(100), currentScaleName: 'C Major',
                    musicMode: { enabled: true, interval: 3, preset: 'multi', refine: true, autoQuantize: true, chordType: 'Random', randomizeChord: true },
                    randomization: { note: true, pulses: true, rotation: true, scale: true, velocity: true, octave: 3, randomizeOctave: true, instruments: true },
                    locks: { steps: false, pulses: false, rotation: false, velocity: false, instruments: false },
                    view: { showMidiPanel: true, showRandomizePanel: true, showVolumesPanel: false, showHintsLogPanel: true, showHelpPanel: true, showHotkeysPanel: false, showLocksPanel: false },
                    tracks: Array.from({ length: 4 }, (_, i) => ({ id: i, active: true, pulses: [4, 3, 5, 7][i] || 4, steps: 16, rotation: [0, 2, 4, 0][i] || 0, note: [60, 64, 67, 71][i] || 60, velocity: 100, channelOverride: 'global' }))
                };
            },

            updateState(newState, callback) {
                try {
                    const prevState = this.state ? { ...this.state } : this.getDefaultState();
                    const updatedState = this.deepMerge(this.state, newState);

                    if (!prevState.tracks || JSON.stringify(updatedState.tracks) !== JSON.stringify(prevState.tracks)) {
                        updatedState.tracks.forEach(track => {
                            track.pattern = this.generateEuclideanPattern(track.pulses, track.steps);
                            track.currentStep = 0;
                        });
                    }

                    this.state = this.validateAndSanitizeState(updatedState);

                    this.syncAppWithState(this.state, prevState);
                    this.render();
                    this.requestAutoSave();

                    if (typeof callback === 'function') {
                        callback();
                    }
                } catch (error) {
                    console.error("Critical error during state update.", error);
                }
            },

            syncAppWithState(newState, prevState) {
                try {
                    if (!prevState || newState.bpm !== prevState.bpm) Tone.Transport.bpm.value = newState.bpm;
                    if (!prevState || newState.masterVolume !== prevState.masterVolume) {
                        if (this.masterVolumeNode) {
                            const dB = newState.masterVolume === 0 ? -Infinity : Tone.gainToDb(newState.masterVolume / 127);
                            this.masterVolumeNode.volume.value = dB;
                        }
                    }
                    if (!prevState || JSON.stringify(newState.musicMode) !== JSON.stringify(prevState.musicMode)) this.setupTimedRandomization();
                    if (!prevState || JSON.stringify(newState.tracks) !== JSON.stringify(prevState.tracks) || newState.globalMidiChannel !== prevState.globalMidiChannel) this.rebuildAllTrackLoops();
                } catch (error) {
                    console.error("Error during app sync:", error);
                }
            },

            updateTrackState(trackId, newTrackState) {
                const newTracks = this.state.tracks.map(t => t.id === trackId ? this.deepMerge(t, newTrackState) : t);
                this.updateState({ tracks: newTracks });
            },

            requestAutoSave() {
                if (this.autosaveTimeout) clearTimeout(this.autosaveTimeout);
                this.autosaveTimeout = setTimeout(() => {
                    try {
                        localStorage.setItem(this.AUTOSAVE_KEY, JSON.stringify(this.state));
                    } catch (e) {
                        console.error("Autosave failed:", e);
                    }
                }, 500);
            },

            manualSaveState() {
                try {
                    localStorage.setItem(this.MANUAL_SAVE_KEY, JSON.stringify(this.state));
                    this.showStatusMessage("Manual save successful!", 2000);
                } catch (e) {
                    console.error("Manual save failed:", e);
                    this.showStatusMessage("Manual save failed.", 5000);
                }
            },

            async loadState(stateToLoad) {
                try {
                    const wasPlaying = Tone.Transport.state === 'started';
                    if (wasPlaying) {
                        await Tone.Transport.stop();
                        this.panic();
                    }

                    const defaultState = this.getDefaultState();
                    const mergedState = this.deepMerge(defaultState, stateToLoad || {});
                    this.state = this.validateAndSanitizeState(mergedState);

                    this.state.tracks.forEach(track => {
                        track.pattern = this.generateEuclideanPattern(track.pulses, track.steps);
                        track.currentStep = 0;
                    });

                    Tone.Transport.bpm.value = this.state.bpm;

                    if (this.internalSynths.length === 0) this.setupToneJS();

                    if (this.midiOutput || this.state.midiOutputId === 'internal_synth') {
                        this.state.channelVolumes.forEach((volume, i) => {
                            if (this.state.midiOutputId === 'internal_synth') {
                                if(this.internalSynths[i]) this.internalSynths[i].volume.value = -24 + (24 * (volume/127));
                            } else {
                                this.sendMidiCC(7, volume, i + 1)
                            }
                        });
                    }

                    this.render();

                    if (this.dom.midiOutSelect && Array.from(this.dom.midiOutSelect.options).some(o => o.value === this.state.midiOutputId)) {
                        this.dom.midiOutSelect.value = this.state.midiOutputId;
                    }

                    this.updateMidiOutput();

                    if (wasPlaying) {
                        this.rebuildAllTrackLoops();
                        await Tone.Transport.start();
                    }
                } catch (error) {
                    console.error("Failed to load state. Resetting to default.", error);
                    this.showStatusMessage("Error loading state. Resetting.", 5000);
                    await this.loadState(this.getDefaultState());
                }
            },

            async loadManualState() {
                const savedStateJSON = localStorage.getItem(this.MANUAL_SAVE_KEY);
                if (!savedStateJSON) {
                    this.showStatusMessage("No manual save found.");
                    return;
                }
                try {
                    await this.loadState(JSON.parse(savedStateJSON));
                    this.showStatusMessage("Manual save loaded successfully!", 2000);
                } catch (e) {
                    this.showStatusMessage("Error loading manual save.", 5000);
                    console.error("Failed to parse manual save:", e);
                    localStorage.removeItem(this.MANUAL_SAVE_KEY);
                }
            },

            validateAndSanitizeState(s) {
                try {
                    const defaultState = this.getDefaultState();
                    let sanitizedState = this.deepMerge(defaultState, s);
                    sanitizedState.numTracks = Math.max(1, Math.min(this.MAX_TRACKS, parseInt(s.numTracks) || 4));
                    sanitizedState.bpm = Math.max(20, Math.min(240, parseInt(s.bpm) || 120));
                    sanitizedState.masterVolume = Math.max(0, Math.min(127, parseInt(s.masterVolume) || 100));
                    sanitizedState.globalMidiChannel = Math.max(1, Math.min(16, parseInt(s.globalMidiChannel) || 1));
                    if (!s.currentScaleName || !Object.keys(this.SCALES).includes(s.currentScaleName.split(' ').slice(1).join(' '))) {
                        sanitizedState.currentScaleName = 'C Major';
                    }
                    if (!Array.isArray(sanitizedState.tracks)) sanitizedState.tracks = defaultState.tracks;
                    sanitizedState.tracks = sanitizedState.tracks.slice(0, sanitizedState.numTracks);
                    while(sanitizedState.tracks.length < sanitizedState.numTracks) sanitizedState.tracks.push(defaultState.tracks[0]);
                    sanitizedState.tracks.forEach((track, index) => {
                        let t = { ...defaultState.tracks[0], ...track };
                        t.id = index;
                        t.steps = Math.max(1, Math.min(32, parseInt(t.steps) || 16));
                        t.pulses = Math.max(0, Math.min(t.steps, parseInt(t.pulses) || 4));
                        t.rotation = Math.max(0, Math.min(t.steps > 0 ? t.steps - 1 : 0, parseInt(t.rotation) || 0));
                        t.note = Math.max(0, Math.min(127, parseInt(t.note) || 60));
                        t.velocity = Math.max(0, Math.min(127, parseInt(t.velocity) || 100));
                        sanitizedState.tracks[index] = t;
                    });
                    return sanitizedState;
                } catch (error) {
                    console.error("Error during state sanitization. Returning default state.", error);
                    return this.getDefaultState();
                }
            },

            // --- CORE LOGIC ---
            async setupMIDI() {
                try {
                    if (!navigator.requestMIDIAccess) {
                        this.showStatusMessage('Web MIDI not supported in this browser.', 5000);
                        this.populateMidiDeviceList();
                        return;
                    }
                    if (this.midiAccess) {
                        this.midiAccess.inputs.forEach(i => i.onmidimessage = null);
                        this.midiAccess.removeEventListener('statechange', () => this.populateMidiDeviceList());
                    }
                    this.midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                    this.populateMidiDeviceList();
                    this.midiAccess.addEventListener('statechange', () => this.populateMidiDeviceList());
                    this.midiAccess.inputs.forEach(i => i.onmidimessage = (e) => this.handleMidiMessage(e));
                } catch (err) {
                    this.showStatusMessage('MIDI has been disabled by a Permissions Policy.', 5000);
                    this.populateMidiDeviceList(); // Still populate with internal synth
                    console.error("MIDI setup error:", err);
                }
            },

            handleMidiMessage(event) {
                try {
                    const [cmd, param1, param2] = event.data;
                    if (!cmd) return;
                    const channel = (cmd & 0x0F) + 1;
                    const command = cmd & 0xF0;
                    if (command === 0x90 && param2 > 0 && this.noteLearningTrack) {
                        const trackId = this.noteLearningTrack.trackId;
                        this.updateTrackState(trackId, { note: param1, channelOverride: channel });
                        this.showStatusMessage(`Track ${trackId + 1} set to Note: ${Tone.Frequency(param1, "midi").toNote()} on Ch: ${channel}.`);
                        this.cancelAllLearnModes(false);
                        return;
                    }
                    if (command === 0xB0) {
                        if (this.currentLearningControl) {
                            const { paramId } = this.currentLearningControl;
                            const newCcMap = { ...this.state.ccMap, [paramId]: { cc: param1, channel: channel } };
                            this.showStatusMessage(`${this.getReadableParamId(paramId)} mapped to CC#${param1} on Ch ${channel}.`);
                            this.cancelAllLearnModes(false);
                            this.updateState({ccMap: newCcMap});
                        } else {
                            Object.entries(this.state.ccMap).forEach(([paramId, map]) => {
                                if (map.cc === param1 && map.channel === channel) {
                                    const el = this.dom[paramId.replace(/-([a-z])/g, g => g[1].toUpperCase())] || document.getElementById(paramId);
                                    if (!el) return;
                                    const min = parseFloat(el.min ?? 0);
                                    const max = parseFloat(el.max ?? 127);
                                    const step = parseFloat(el.step ?? 1);
                                    const newValue = Math.round((min + (((max - min) * param2) / 127)) / step) * step;
                                    el.value = newValue;
                                    el.dispatchEvent(new Event('input', { bubbles: true }));
                                }
                            });
                        }
                    }
                } catch(error) {
                    console.error("Error processing MIDI message:", error, event.data);
                }
            },

            populateMidiDeviceList() {
                try {
                    const selectedId = this.state?.midiOutputId || 'internal_synth';
                    this.dom.midiOutSelect.innerHTML = '';
                    this.dom.midiOutSelect.add(new Option("Internal Synth", "internal_synth"));

                    if (this.midiAccess && this.midiAccess.outputs.size > 0) {
                        this.midiAccess.outputs.forEach(out => {
                            this.dom.midiOutSelect.add(new Option(out.name, out.id));
                        });
                    }

                    this.dom.midiOutSelect.value = selectedId;
                    this.updateMidiOutput();

                } catch (error) {
                    console.error("Error populating MIDI device list:", error);
                }
            },

            updateMidiOutput() {
                try {
                    const selectedId = this.dom.midiOutSelect.value;
                    if (selectedId === 'internal_synth') {
                        this.midiOutput = null;
                    } else {
                        this.midiOutput = this.midiAccess?.outputs.get(selectedId) || null;
                    }
                    this.populateChannelSelectors();
                    if(!this.state || this.state.midiOutputId !== selectedId) {
                        this.updateState({ midiOutputId: selectedId });
                    }
                } catch (error) {
                    console.error("Error updating MIDI output:", error);
                }
            },

            sendMidi(command) {
                if (this.midiOutput?.send) {
                    try { this.midiOutput.send(command); } catch(error) { console.error("Failed to send MIDI message:", command, error); }
                }
            },
            sendMidiNoteOn(note, vel, ch) { this.sendMidi([0x90 + (ch - 1), note, vel]); },
            sendMidiNoteOff(note, ch) { this.sendMidi([0x80 + (ch - 1), note, 0]); },
            sendMidiCC(cc, value, channel) { this.sendMidi([0xB0 + (channel - 1), cc, value]); },

            clearActiveNotes() {
                Object.values(this.activeTrackNotes).forEach(noteInfo => {
                    if (noteInfo) this.sendMidiNoteOff(noteInfo.note, noteInfo.channel);
                });
                this.activeTrackNotes = {};
            },

            panic() {
                this.clearActiveNotes();
                for (let i = 1; i <= 16; i++) {
                    this.sendMidiCC(123, 0, i);
                    this.sendMidiCC(120, 0, i);
                }
                this.internalSynths.forEach(synth => {
                    if(synth && typeof synth.releaseAll === 'function'){
                        synth.releaseAll();
                    }
                });
            },

            showStatusMessage(message, duration = 3000) {
                if (this.statusTimeout) clearTimeout(this.statusTimeout);
                this.dom.statusBarContent.textContent = message;
                this.dom.statusBar.classList.add('visible');
                this.statusTimeout = setTimeout(() => this.dom.statusBar.classList.remove('visible'), duration);
            },

            showHint() {
                this.dom.hintContent.textContent = this.HINTS[Math.floor(Math.random() * this.HINTS.length)];
            },

            deepMerge(target, source) {
                const output = { ...target };
                if (this.isObject(target) && this.isObject(source)) {
                    Object.keys(source).forEach(key => {
                        if (this.isObject(source[key]) && key in target && this.isObject(target[key]) && !Array.isArray(target[key])) {
                            output[key] = this.deepMerge(target[key], source[key]);
                        } else {
                            output[key] = source[key];
                        }
                    });
                }
                return output;
            },

            isObject(item) {
                return (item && typeof item === 'object' && !Array.isArray(item));
            },

            getReadableParamId(paramId) {
                let readable = paramId.replace(/([A-Z])/g, ' $1');
                let trackMatch = readable.match(/^(steps|pulses|rotation|velocity)\s?(\d+)$/i);
                if (trackMatch) return `${trackMatch[1].charAt(0).toUpperCase() + trackMatch[1].slice(1)} Track ${parseInt(trackMatch[2]) + 1}`;
                let channelMatch = readable.match(/^channel\s?Volume\s?(\d+)$/i);
                if (channelMatch) return `Channel ${channelMatch[1]} Volume`;
                return readable.replace(/^./, str => str.toUpperCase()).trim();
            },

            getNoteColor(note, minNote, maxNote) {
                const range = Math.max(1, maxNote - minNote);
                const normalized = (note - minNote) / range;
                const hue = 240 - (normalized * 240);
                return { color: `hsl(${hue}, 90%, 65%)`, glow: `hsla(${hue}, 90%, 65%, 0.7)` };
            },

            findClosestNoteInScale(midiNote, scale) {
                if (!scale || scale.length === 0) return midiNote;
                return scale.reduce((prev, curr) => (Math.abs(curr - midiNote) < Math.abs(prev - midiNote) ? curr : prev));
            },

            regenerateScaleFromName() {
                if (!this.state.currentScaleName) return;
                const parts = this.state.currentScaleName.split(' ');
                const rootNoteName = parts[0];
                const scaleName = parts.slice(1).join(' ');
                const rootNoteMidi = this.NOTE_NAMES.indexOf(rootNoteName);
                const scaleIntervals = this.SCALES[scaleName];
                if (rootNoteMidi === -1 || !scaleIntervals) {
                    this.currentRandomizationScale = [];
                    return;
                }
                this.currentRandomizationScale = [];
                for (let octave = 1; octave < 9; octave++) {
                    for (const interval of scaleIntervals) {
                        const midiNote = 12 * octave + rootNoteMidi + interval;
                        if (midiNote >= 0 && midiNote <= 127) {
                            this.currentRandomizationScale.push(midiNote);
                        }
                    }
                }
            },

            generateEuclideanPattern(pulses, steps) {
                if (pulses > steps || pulses < 0 || steps <= 0 || isNaN(pulses) || isNaN(steps)) return [];
                if (pulses === 0) return Array(steps).fill(0);
                try {
                    let pattern = [], counts = [], remainders = [], divisor = steps - pulses;
                    remainders.push(pulses);
                    let level = 0;
                    while (true) {
                        counts.push(Math.floor(divisor / remainders[level]));
                        remainders.push(divisor % remainders[level]);
                        divisor = remainders[level];
                        level += 1;
                        if (remainders[level] <= 1) break;
                    }
                    counts.push(divisor);
                    function build(level) {
                        if (level === -1) pattern.push(0);
                        else if (level === -2) pattern.push(1);
                        else {
                            for (let i = 0; i < counts[level]; i++) build(level - 1);
                            if (remainders[level] !== 0) build(level - 2);
                        }
                    }
                    build(level);
                    return pattern.reverse();
                } catch(e) {
                    console.error(`Error generating Euclidean pattern for p=${pulses}, s=${steps}`, e);
                    return Array(steps || 0).fill(0);
                }
            },

            rotatePattern(pattern, rotation) {
                const len = pattern.length;
                if (len === 0) return [];
                const r = ((rotation % len) + len) % len;
                return [...pattern.slice(r), ...pattern.slice(0, r)];
            },

            render() {
                try {
                    if (!this.state || !this.dom.numTracksInput) return;
                    this.regenerateScaleFromName();
                    this.dom.numTracksInput.value = this.state.numTracks;
                    this.dom.bpmSlider.value = this.state.bpm;
                    this.dom.bpmValue.textContent = this.state.bpm;
                    this.dom.masterVolumeSlider.value = this.state.masterVolume;
                    this.dom.masterVolumeValue.textContent = this.state.masterVolume;

                    this.dom.chordTypeSelect.value = this.state.musicMode.chordType;
                    this.dom.randomizeChordCheck.checked = this.state.musicMode.randomizeChord;
                    const midiAvailable = !!this.midiAccess;
                    this.dom.midiPanel.querySelectorAll('select, button').forEach(el => {
                        if (el.id !== 'reInitMidiButton' && el.id !== 'allNotesOffButton' && el.id !== 'setAllToGlobal') el.disabled = !midiAvailable && el.id !== 'midiOutSelect';
                    });
                    this.dom.reInitMidiButton.disabled = false;
                    this.dom.allNotesOffButton.disabled = !(this.midiOutput || this.state.midiOutputId === 'internal_synth');
                    document.querySelectorAll('.learn-cc-button, .note-learn-button').forEach(btn => btn.disabled = !midiAvailable);
                    Object.entries(this.VIEW_PANEL_MAP).forEach(([key, panelId]) => {
                        const checkbox = this.dom[key]
                        const panel = this.dom[panelId];
                        if (checkbox && typeof this.state.view[key] !== 'undefined') checkbox.checked = this.state.view[key];
                        if(panel) panel.style.display = this.state.view[key] ? 'flex' : 'none';
                    });
                    this.dom.musicModeToggle.checked = this.state.musicMode.enabled;
                    this.dom.musicModePanel.style.display = this.state.musicMode.enabled ? 'flex' : 'none';
                    this.dom.musicModeRefineCheck.checked = this.state.musicMode.refine;
                    this.dom.musicModeQuantizeCheck.checked = this.state.musicMode.autoQuantize;
                    document.body.classList.toggle('music-mode-active', this.state.musicMode.enabled);
                    this.dom.appBackground.classList.toggle('bg-music-mode', this.state.musicMode.enabled);
                    this.dom.appBackground.classList.toggle('bg-default', !this.state.musicMode.enabled);
                    this.dom.logSection.style.display = this.state.musicMode.enabled ? 'flex' : 'none';
                    this.dom.randomIntervalSlider.value = this.state.musicMode.interval;
                    this.dom.randomIntervalValue.textContent = this.state.musicMode.interval;
                    this.renderManualRandomizationOptions();
                    this.renderMusicModePresets();
                    this.renderAllTracks();
                    this.renderChannelVolumes();
                    this.renderCcMappings();
                    this.renderOctaveSelector();
                    this.renderScaleSelector();
                    this.populateChannelSelectors();
                    this.renderLocksPanel();
                } catch (error) {
                    console.error("A major error occurred during rendering:", error);
                    this.showStatusMessage("Render Error. Check console.", 5000);
                }
            },

            renderAllTracks() {
                this.dom.sequencerTracksContainer.querySelectorAll('.synth-panel[data-track-id]').forEach(panel => {
                    if (!this.state.tracks.some(t => t.id === parseInt(panel.dataset.trackId, 10))) {
                        panel.remove();
                    }
                });
                this.state.tracks.forEach(track => {
                    let panel = this.dom.sequencerTracksContainer.querySelector(`.synth-panel[data-track-id="${track.id}"]`);
                    if (!panel) {
                        panel = this.createSequencerTrackUI(track.id);
                        this.dom.sequencerTracksContainer.appendChild(panel);
                    }
                    this.renderTrack(track, panel);
                });
            },

            renderTrack(track, panel) {
                try {
                    if (!track || !panel) return;
                    const update = (prop, value, text) => {
                        const el = panel.querySelector(`#${prop}${track.id}`);
                        if (el) el.value = value;
                        const textEl = panel.querySelector(`#${prop}Value${track.id}`);
                        if(textEl) textEl.textContent = text ?? value;
                    };
                    const pulsesSlider = panel.querySelector(`#pulses${track.id}`);
                    if (pulsesSlider) pulsesSlider.max = track.steps;
                    update('steps', track.steps);
                    update('pulses', track.pulses);
                    update('rotation', track.rotation);
                    update('velocity', track.velocity);
                    panel.querySelector(`#note${track.id}`).value = Tone.Frequency(track.note, 'midi').toNote();
                    panel.querySelector(`#channelOverride${track.id}`).value = track.channelOverride;
                    const toggleButton = panel.querySelector(`#trackToggle${track.id}`);
                    toggleButton.textContent = track.active ? 'On' : 'Off';
                    toggleButton.classList.toggle('active', track.active);
                    this.renderPatternDisplay(track, panel);
                } catch(error) {
                    console.error(`Error rendering track ${track?.id}:`, error, track);
                }
            },

            renderPatternDisplay(track, panel) {
                const display = panel.querySelector(`#patternDisplay${track.id}`);
                if (!display) return;
                display.innerHTML = '';
                const isPlaying = Tone.Transport.state === "started";
                const pattern = track.pattern || [];
                const steps = track.steps || 0;
                for (let i = 0; i < steps; i++) {
                    const stepDot = document.createElement('div');
                    stepDot.className = 'pattern-step';
                    if (pattern[i] === 1) stepDot.classList.add('active');
                    if (isPlaying && track.active && i === track.currentStep) {
                        stepDot.classList.add('current');
                    }
                    display.appendChild(stepDot);
                }
            },

            renderScaleSelector() {
                if (!this.state || !this.state.currentScaleName) return;
                const parts = this.state.currentScaleName.split(' ');
                const root = parts[0];
                const type = parts.slice(1).join(' ');
                if (this.dom.scaleRootSelect.value !== root) this.dom.scaleRootSelect.value = root;
                if (this.dom.scaleTypeSelect.value !== type) this.dom.scaleTypeSelect.value = type;
            },

            renderChannelVolumes() {
                if (!this.state || !this.state.channelVolumes) return;
                for(let i=1; i<=16; i++) {
                    const slider = document.getElementById(`channelVolume${i}`);
                    const valueDisplay = document.getElementById(`channelVolumeValue${i}`);
                    const label = document.querySelector(`label[for="channelVolume${i}"]`);

                    if (slider && valueDisplay && label) {
                        const volume = this.state.channelVolumes[i - 1];
                        slider.value = volume;
                        valueDisplay.textContent = volume;
                        label.textContent = `Ch ${i}`;
                    }
                }
            },

            renderCcMappings() {
                document.querySelectorAll('.learn-cc-button').forEach(btn => {
                    const paramId = btn.dataset.paramId;
                    btn.classList.remove('learning', 'mapped');
                    if (this.currentLearningControl?.paramId === paramId) {
                        btn.classList.add('learning');
                        btn.textContent = '...';
                    } else {
                        btn.textContent = 'L';
                        if (this.state.ccMap && this.state.ccMap[paramId]) {
                            btn.classList.add('mapped');
                            const { cc, channel } = this.state.ccMap[paramId];
                            btn.title = `Mapped to CC #${cc} on Ch ${channel}. Click to unmap.`;
                        } else {
                            btn.title = `Map ${this.getReadableParamId(paramId)} to a MIDI CC knob/fader`;
                        }
                    }
                });
            },

            renderOctaveSelector() {
                if (!this.state || !this.state.randomization) return;
                this.dom.octaveSelector.querySelectorAll('.radio-label').forEach(label => {
                    const radio = label.querySelector('input');
                    radio.checked = parseInt(radio.value, 10) === this.state.randomization.octave;
                    label.classList.toggle('selected', radio.checked);
                });
            },

            renderMusicModePresets() {
                if (!this.state || !this.state.musicMode) return;
                this.dom.musicModePresetContainer.querySelectorAll('.radio-label').forEach(label => {
                    const radio = label.querySelector('input');
                    radio.checked = radio.value === this.state.musicMode.preset;
                    label.classList.toggle('selected', radio.checked);
                });
            },

            renderManualRandomizationOptions(){
                if (!this.state || !this.state.randomization) return;
                this.dom.randomizeNoteCheck.checked = this.state.randomization.note;
                this.dom.randomizePulsesCheck.checked = this.state.randomization.pulses;
                this.dom.randomizeRotationCheck.checked = this.state.randomization.rotation;
                this.dom.randomizeScaleCheck.checked = this.state.randomization.scale;
                this.dom.randomizeVelocityCheck.checked = this.state.randomization.velocity;
                this.dom.randomizeOctaveCheck.checked = this.state.randomization.randomizeOctave;
                this.dom.randomizeInstrumentsCheck.checked = this.state.randomization.instruments;

                this.dom.randomizeInstrumentsContainer.style.display = this.state.midiOutputId === 'internal_synth' ? 'flex' : 'none';
            },

            renderLocksPanel() {
                if (!this.state || !this.state.locks) return;
                this.dom.lockStepsCheckbox.checked = this.state.locks.steps;
                this.dom.lockPulsesCheckbox.checked = this.state.locks.pulses;
                this.dom.lockRotationCheckbox.checked = this.state.locks.rotation;
                this.dom.lockVelocityCheckbox.checked = this.state.locks.velocity;
                this.dom.lockInstrumentsCheckbox.checked = this.state.locks.instruments;
            },

            createInitialUI() {
                for (let i = 1; i <= 16; i++) {
                    const volDiv = document.createElement('div');
                    volDiv.className = 'control-group';
                    volDiv.innerHTML = `<div class="control-header"><label for="channelVolume${i}"></label><span id="channelVolumeValue${i}" class="value-display"></span><button class="learn-cc-button ml-1" data-param-id="channelVolume${i}" title="Map Ch ${i} Volume to a MIDI CC knob/fader">L</button></div><div class="control-slider-container"><input type="range" id="channelVolume${i}" min="0" max="127" value="100" class="control-slider" title="Adjust volume for MIDI Channel ${i}"></div>`;
                    this.dom.channelVolumesContainer.appendChild(volDiv);
                    volDiv.querySelector('input').addEventListener('input', e => {
                        const newVolume = parseInt(e.target.value, 10);
                        const newVolumes = [...this.state.channelVolumes];
                        newVolumes[i-1] = newVolume;
                        if (this.state.midiOutputId === 'internal_synth') {
                            const scaledVol = -24 + (24 * (newVolume / 127));
                            this.internalSynths[i-1].volume.value = scaledVol;
                        } else {
                            this.sendMidiCC(7, newVolume, i);
                        }
                        this.updateState({ channelVolumes: newVolumes });
                    });
                }
                this.NOTE_NAMES.forEach(note => this.dom.scaleRootSelect.add(new Option(note, note)));
                Object.keys(this.SCALES).forEach(scaleName => this.dom.scaleTypeSelect.add(new Option(scaleName, scaleName)));
                Object.keys(this.CHORD_TYPES).forEach(chordName => this.dom.chordTypeSelect.add(new Option(chordName, chordName)));
                this.dom.octaveSelector.innerHTML = '';
                for (let i = 1; i <= 8; i++) {
                    const label = document.createElement('label');
                    label.className = 'radio-label';
                    label.innerHTML = `<input type="radio" name="octaveSelect" value="${i}"><span>${i}</span>`;
                    label.title = `Set base octave for randomization to ${i}`;
                    this.dom.octaveSelector.appendChild(label);
                }
                this.dom.musicModePresetContainer.innerHTML = '';
                const presetTooltips = { off: "Music Mode does nothing.", single: "Changes one parameter on one random track.", multi: "Changes all enabled parameters on all active tracks.", melodic: "Changes notes and scale, but keeps rhythm the same.", jazz: "Generates diatonic 7th chords from the current scale.", rock: "Generates power chords or minor chords.", baroque: "Generates arpeggiated triads based on a I-V-vi-IV progression.", fifths: "Shifts the musical key by a perfect fifth." };
                Object.entries(this.MUSIC_MODE_PRESETS).forEach(([key, preset]) => {
                    const label = document.createElement('label');
                    label.className = 'radio-label';
                    label.innerHTML = `<input type="radio" name="musicModePreset" value="${key}"><span>${preset.label}</span>`;
                    label.title = presetTooltips[key];
                    this.dom.musicModePresetContainer.appendChild(label);
                });

                this.dom.hotkeysList.innerHTML = Object.entries(this.HOTKEYS).map(([key, desc]) => `<div class="hotkey-item"><span>${desc}</span><span class="hotkey-key">${key}</span></div>`).join('');
            },

            createSequencerTrackUI(trackId) {
                const trackDiv = document.createElement('div');
                trackDiv.className = 'synth-panel p-2 flex flex-col relative';
                trackDiv.dataset.trackId = trackId;
                trackDiv.innerHTML = `
                    <div class="flex justify-between items-center mb-1">
                        <h3 class="text-base font-semibold">Track ${trackId + 1}</h3>
                        <div>
                            <button data-action="randomize" class="push-button randomize-button text-xs py-1 px-2" title="Randomize this track's parameters">Random</button>
                            <button data-action="toggleActive" id="trackToggle${trackId}" class="push-button text-xs py-1 px-2 ml-1" title="Mute or unmute this track">On</button>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-x-2 gap-y-1 mb-1">
                        ${this.createSliderControl('steps', trackId, 'Steps', 1, 32, 16, "Number of steps in the sequence")}
                        ${this.createSliderControl('pulses', trackId, 'Pulses', 1, 16, 4, "Number of active beats")}
                        ${this.createSliderControl('rotation', trackId, 'Rotate', 0, 15, 0, "Shift pattern start point")}
                        ${this.createSliderControl('velocity', trackId, 'Velocity', 1, 127, 100, "Note loudness")}
                        ${this.createSelectControl('channelOverride', trackId, 'Channel', ['global', ...Array.from({length:16},(_,i)=>i+1)])}
                        ${this.createNoteControl(trackId)}
                    </div>
                    <div id="patternDisplay${trackId}" class="pattern-display my-1"></div>
                `;
                return trackDiv;
            },

            createSliderControl(id, trackId, label, min, max, value, title = "") {
                return `
                    <div class="control-group">
                        <div class="control-header">
                            <label for="${id}${trackId}" title="${title}">${label}:</label>
                            <span id="${id}Value${trackId}" class="value-display">${value}</span>
                            <button class="learn-cc-button ml-1" data-param-id="${id}${trackId}" title="Map ${label} to MIDI CC">L</button>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="${id}${trackId}" data-action="decrement">&minus;</button>
                            <input type="range" data-action="update" data-prop="${id}" id="${id}${trackId}" min="${min}" max="${max}" value="${value}" class="control-slider" title="${title}">
                            <button class="slider-button" data-target="${id}${trackId}" data-action="increment">+</button>
                        </div>
                    </div>
                `;
            },

            createSelectControl(id, trackId, label, options) {
                return `
                    <div class="control-group">
                        <label for="${id}${trackId}" class="mb-1">${label}:</label>
                        <select id="${id}${trackId}" data-action="update" data-prop="${id}" class="text-xs p-1 h-full" title="Set a specific output channel for this track, or use the Global setting"></select>
                    </div>
                `;
            },

            createNoteControl(trackId) {
                return `
                    <div class="control-group">
                        <label for="note${trackId}" class="mb-1">Note:</label>
                        <div class="note-input-group">
                            <input type="text" data-action="update" data-prop="note" id="note${trackId}" class="text-xs p-1" title="Set the MIDI note (e.g., C3, F#4)">
                            <button data-action="learnNote" id="noteLearn${trackId}" class="note-learn-button" title="Learn MIDI note and channel from your controller">L</button>
                        </div>
                    </div>
                `;
            },

            handleViewToggle(e) {
                if(e.target.id === 'musicModeToggle') {
                    if(e.target.checked) this.dom.musicModeLog.innerHTML = '';
                    this.updateState({ musicMode: { ...this.state.musicMode, enabled: e.target.checked } });
                } else if (e.target.dataset.viewToggle) {
                    const viewKey = e.target.id;
                    this.updateState({ view: { ...this.state.view, [viewKey]: e.target.checked } });
                }
            },

            startAutoRepeat(e) {
                const btn = e.target.closest('.slider-button, .number-input-button');
                if (!btn) return;
                if (e.type === 'touchstart') e.preventDefault();
                const targetId = btn.dataset.target;
                const action = btn.dataset.action;
                this.stopAutoRepeat();
                this.adjustControlValue(targetId, action);
                this.autoRepeatTimeoutId = setTimeout(() => {
                    this.autoRepeatIntervalId = setInterval(() => this.adjustControlValue(targetId, action), 100);
                }, 500);
            },

            stopAutoRepeat() {
                clearTimeout(this.autoRepeatTimeoutId);
                clearInterval(this.autoRepeatIntervalId);
            },

            adjustControlValue(targetId, action) {
                const el = document.getElementById(targetId);
                if (!el) return;
                let val = parseFloat(el.value);
                const step = parseFloat(el.step) || 1;
                const min = parseFloat(el.min);
                const max = parseFloat(el.max);
                el.value = Math.max(min, Math.min(max, val + (action === 'increment' ? step : -step)));
                el.dispatchEvent(new Event(el.id === 'numTracksInput' ? 'change' : 'input', { bubbles: true }));
            },

            handleScaleChange() {
                const root = this.dom.scaleRootSelect.value;
                const type = this.dom.scaleTypeSelect.value;
                const newScaleName = `${root} ${type}`;
                if (this.state.currentScaleName !== newScaleName) {
                    this.logChange(`Scale changed to: ${newScaleName}`);
                    this.updateState({ currentScaleName: newScaleName });
                }
            },

            handleQuantizeNotes(showStatus = true) {
                this.regenerateScaleFromName();
                if (this.currentRandomizationScale.length === 0) {
                    if(showStatus) this.showStatusMessage("Cannot quantize: Invalid scale selected.", 3000);
                    return;
                }
                const newTracks = this.state.tracks.map(track => {
                    if (track.active) {
                        return { ...track, note: this.findClosestNoteInScale(track.note, this.currentRandomizationScale) };
                    }
                    return track;
                });
                this.updateState({ tracks: newTracks });
                if(showStatus) this.showStatusMessage(`All notes quantized to ${this.state.currentScaleName}.`, 2500);
            },

            handleRandomizeOptionChange(e) {
                if(e.target.classList.contains('randomize-option')) {
                    const newRandomizationState = { ...this.state.randomization };
                    document.querySelectorAll('.randomize-option').forEach(el => {
                        let key = el.id.replace('randomize', '').replace('Check', '').toLowerCase();
                        if (el.id === 'randomizeOctaveCheck') key = 'randomizeOctave';
                        if (el.id === 'randomizeChordCheck') return;
                        if (el.id === 'randomizeInstrumentsCheck') key = 'instruments';
                        newRandomizationState[key] = el.checked;
                    });
                    this.updateState({ randomization: newRandomizationState });
                }
            },

            handleTrackAction(e) {
                try {
                    const target = e.target;
                    const action = target.dataset.action;
                    const trackPanel = target.closest('.synth-panel[data-track-id]');
                    if (!action || !trackPanel) return;
                    const trackId = parseInt(trackPanel.dataset.trackId, 10);
                    const track = this.state.tracks.find(t => t.id === trackId);
                    if (!track) return;
                    switch(action) {
                        case 'randomize':
                            let newTracks = this.randomizeTrackParameters(track, this.state.randomization, true, {}, JSON.parse(JSON.stringify(this.state.tracks)));
                            this.updateState({tracks: newTracks});
                            break;
                        case 'toggleActive':
                            if (track.active && this.activeTrackNotes[trackId]) {
                                this.sendMidiNoteOff(this.activeTrackNotes[trackId].note, this.activeTrackNotes[trackId].channel);
                                delete this.activeTrackNotes[trackId];
                            }
                            this.updateTrackState(trackId, { active: !track.active });
                            break;
                        case 'learnNote': this.startNoteLearn(trackId, target); break;
                        case 'update': this.handleTrackUpdate(trackId, target); break;
                    }
                } catch (error) {
                    console.error("Error handling track action:", error);
                }
            },

            handleTrackUpdate(trackId, target) {
                const prop = target.dataset.prop;
                let value = target.type === 'range' || target.type === 'number' ? parseInt(target.value, 10) : target.value;
                if (prop === 'note') {
                    try {
                        const midiValue = Tone.Frequency(value.toUpperCase()).toMidi();
                        target.value = Tone.Frequency(midiValue, 'midi').toNote();
                        value = midiValue;
                    } catch {
                        this.showStatusMessage("Invalid note format. Use C3, F#4, etc.", 2000);
                        this.renderTrack(this.state.tracks.find(t=>t.id===trackId), target.closest('.synth-panel'));
                        return;
                    }
                }
                if (prop === 'steps' && this.state.locks.steps) {
                    this.synchronizeAllTrackSteps(value);
                } else {
                    this.updateTrackState(trackId, {[prop]: value});
                }
            },

            handleBodyClick(e) {
                const isLearnButton = e.target.closest('.learn-cc-button, .note-learn-button');
                if (isLearnButton) {
                    if(e.target.classList.contains('learn-cc-button')) {
                        this.handleLearnCcClick(e.target.dataset.paramId, e.target);
                    }
                    return;
                }
                if(this.currentLearningControl || this.noteLearningTrack) {
                    this.cancelAllLearnModes(true);
                }
            },

            async handlePlayStop() {
                try {
                    if (Tone.context.state !== 'running') {
                        await Tone.start();
                        this.showStatusMessage("Audio Context Started.");
                    }
                    if (Tone.Transport.state === 'started') {
                        await Tone.Transport.stop();
                    } else {
                        this.rebuildAllTrackLoops();
                        await Tone.Transport.start();
                    }
                } catch (error) {
                    console.error("Error with Play/Stop:", error);
                }
            },

            handleNumTracksChange(e) {
                let newCount = Math.max(1, Math.min(this.MAX_TRACKS, parseInt(e.target.value, 10) || this.state.numTracks));
                if (newCount === this.state.numTracks) return;
                const currentTracks = [...this.state.tracks];
                const newTracks = [];
                for (let i = 0; i < newCount; i++) {
                    if (currentTracks[i]) {
                        newTracks.push(currentTracks[i]);
                    } else {
                        const defaultTrack = this.getDefaultState().tracks[0];
                        newTracks.push({ ...defaultTrack, id: i, steps: this.state.locks.steps ? this.state.globalLockedSteps : 16, });
                    }
                }
                this.updateState({ numTracks: newCount, tracks: newTracks });
            },

            handleGlobalLockChange(e) {
                if(e.target.id === 'lockStepsCheckbox') {
                    const stepsLocked = e.target.checked;
                    if(stepsLocked) {
                        const globalLockedSteps = this.state.tracks.length > 0 ? this.state.tracks[0].steps : 16;
                        this.updateState({ locks: {...this.state.locks, steps: stepsLocked}, globalLockedSteps });
                        this.synchronizeAllTrackSteps(globalLockedSteps);
                    } else {
                        this.updateState({ locks: {...this.state.locks, steps: stepsLocked} });
                    }
                } else {
                    const newLocks = {...this.state.locks};
                    const key = e.target.id.replace('lock', '').replace('Checkbox', '').toLowerCase();
                    newLocks[key] = e.target.checked;
                    this.updateState({locks: newLocks});
                }
            },

            synchronizeAllTrackSteps(newSteps) {
                const newTracks = this.state.tracks.map(t => {
                    const newPulses = Math.min(t.pulses, newSteps);
                    const newRotation = Math.min(t.rotation, newSteps > 0 ? newSteps - 1 : 0);
                    return {...t, steps: newSteps, pulses: newPulses, rotation: newRotation };
                });
                this.updateState({ tracks: newTracks, globalLockedSteps: newSteps });
            },

            handleLearnCcClick(paramId, button) {
                if (this.currentLearningControl?.paramId === paramId) {
                    this.cancelAllLearnModes(true);
                    return;
                }
                if (this.state.ccMap[paramId]) {
                    const newCcMap = {...this.state.ccMap};
                    delete newCcMap[paramId];
                    this.updateState({ccMap: newCcMap});
                    this.showStatusMessage(`Mapping for ${this.getReadableParamId(paramId)} cleared.`);
                } else {
                    this.cancelAllLearnModes(false);
                    this.currentLearningControl = { paramId, button };
                    this.showStatusMessage(`Listening for MIDI CC for ${this.getReadableParamId(paramId)}...`);
                    this.renderCcMappings();
                }
            },

            startNoteLearn(trackId, button) {
                if (this.noteLearningTrack?.trackId === trackId) {
                    this.cancelAllLearnModes(true);
                    return;
                }
                this.cancelAllLearnModes(false);
                this.noteLearningTrack = { trackId, button };
                button.classList.add('learning');
                button.textContent = '...';
                this.showStatusMessage(`Listening for MIDI Note for Track ${trackId + 1}.`);
            },

            cancelAllLearnModes(notify = true) {
                if (this.currentLearningControl) {
                    if (notify) this.showStatusMessage("MIDI CC Learn cancelled.");
                    this.currentLearningControl = null;
                }
                if (this.noteLearningTrack) {
                    if (notify) this.showStatusMessage("Note Learn cancelled.");
                    this.noteLearningTrack.button.classList.remove('learning');
                    this.noteLearningTrack.button.textContent = 'L';
                    this.noteLearningTrack = null;
                }
                this.renderCcMappings();
            },

            setupToneJS() {
                const masterComp = new Tone.Compressor(-12, 4).toDestination();
                const synthOptions = [
                    { synth: Tone.FMSynth, options: { volume: 0, harmonicity: 1.5, modulationIndex: 5, envelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.8 } } }, // Louder Piano
                    { synth: Tone.AMSynth, options: { volume: -4, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.8 } } },
                    { synth: Tone.MonoSynth, options: { volume: -6, envelope: { attack: 0.05, release: 0.4 } } },
                    { synth: Tone.DuoSynth, options: { volume: -6, vibratoAmount: 0.1, harmonicity: 1.5 } },
                    { synth: Tone.MembraneSynth, options: { pitchDecay: 0.01, octaves: 4, envelope: { attack: 0.001, decay: 0.5, sustain: 0, release: 0.4 }, volume: -2 } },
                    { synth: Tone.PluckSynth, options: { attackNoise: 0.5, dampening: 4000, resonance: 0.9, volume: -2 } }
                ];
                for(let i = 0; i < 16; i++) {
                    const synthDef = synthOptions[i % synthOptions.length];
                    const synth = new synthDef.synth(synthDef.options).connect(masterComp);
                    this.internalSynths.push(synth);
                }

                Tone.Transport.on('start', () => {
                    this.dom.playStopButton.innerHTML = '&#x25A0;';
                    this.dom.playStopButton.classList.add('active', 'stop-state');
                    this.rebuildAllTrackLoops();
                    this.transportLoops.forEach(loop => loop?.start(0));
                });
                Tone.Transport.on('stop', () => {
                    this.dom.playStopButton.innerHTML = '&#x25B6;';
                    this.dom.playStopButton.classList.remove('active', 'stop-state');
                    this.panic();
                    if (this.state && this.state.tracks) {
                        this.state.tracks.forEach(t => {
                            t.currentStep = 0;
                            const panel = document.querySelector(`.synth-panel[data-track-id="${t.id}"]`);
                            if (panel) this.renderPatternDisplay(t, panel);
                        });
                    }
                    this.transportLoops.forEach(loop => loop?.stop(0));
                });
            },

            rebuildAllTrackLoops() {
                this.transportLoops.forEach(l => l?.dispose());
                this.transportLoops = [];
                if(this.state && this.state.tracks) {
                    this.state.tracks.forEach(track => {
                        this.transportLoops[track.id] = this.createTrackLoop(track);
                    });
                }

                if (Tone.Transport.state === 'started') {
                    this.transportLoops.forEach(loop => loop?.start(0));
                }
            },

            createTrackLoop(track) {
                if (!track || track.steps === 0 || !track.pattern || track.pattern.length === 0) {
                    return null;
                }
                try {
                    return new Tone.Sequence((time, value) => {
                        if (!track || !this.state) return;

                        Tone.Draw.schedule(() => {
                            if (track.active && value === 1) {
                                const allNotes = this.state.tracks.filter(t => t.active).map(t => t.note);
                                const minNote = Math.min(...allNotes, Infinity);
                                const maxNote = Math.max(...allNotes, -Infinity);
                                const { color, glow } = this.getNoteColor(track.note, minNote, maxNote);
                                const panel = document.querySelector(`.synth-panel[data-track-id="${track.id}"]`);
                                if (panel) {
                                    panel.style.setProperty('--flash-color', color);
                                    panel.style.setProperty('--flash-glow', glow);
                                    panel.classList.add('track-pulse');
                                    setTimeout(() => panel.classList.remove('track-pulse'), 150);
                                }
                            }

                            const trackToUpdate = this.state.tracks.find(t => t.id === track.id);
                            if(trackToUpdate) {
                                trackToUpdate.currentStep = (trackToUpdate.currentStep + 1) % trackToUpdate.steps;
                                const panel = document.querySelector(`.synth-panel[data-track-id="${track.id}"]`);
                                if (panel) this.renderPatternDisplay(trackToUpdate, panel);
                            }
                        }, time);

                        if (track.active && value === 1) {
                            try {
                                const schedTime = time < Tone.now() ? Tone.now() : time;
                                const ch = (track.channelOverride !== 'global') ? parseInt(track.channelOverride, 10) : this.state.globalMidiChannel;
                                const isInternal = this.state.midiOutputId === 'internal_synth';
                                const channelVolume = this.state.channelVolumes[ch - 1] / 127.0;
                                const masterVol = this.state.masterVolume / 127.0;
                                const finalVelocity = Math.round(track.velocity * channelVolume * masterVol);

                                if (finalVelocity > 0) {
                                    const noteToPlay = { note: track.note, channel: ch };
                                    const noteFrequency = Tone.Frequency(noteToPlay.note, 'midi').toFrequency();
                                    const duration = Tone.Time("16n").toSeconds() * 0.9;

                                    if(isInternal){
                                        const synth = this.internalSynths[ch-1];
                                        if(synth){
                                            synth.triggerAttackRelease(noteFrequency, duration, schedTime, finalVelocity / 127);
                                        }
                                    } else {
                                        this.sendMidiNoteOn(noteToPlay.note, Math.min(127, finalVelocity), noteToPlay.channel);
                                        Tone.Transport.scheduleOnce(() => {
                                            this.sendMidiNoteOff(noteToPlay.note, noteToPlay.channel);
                                        }, schedTime + duration);
                                    }
                                }
                            } catch (e) {
                                console.warn(`Tone.js scheduling error caught for track ${track.id}.`, e);
                            }
                        }
                    }, track.pattern, `${track.steps}n`);
                } catch (error) {
                    console.error(`Failed to create loop for track ${track?.id}`, error);
                    return null;
                }
            },

            setupTimedRandomization() {
                if (this.timedRandomEvent) {
                    Tone.Transport.clear(this.timedRandomEvent);
                    this.timedRandomEvent = null;
                }
                if (this.state.musicMode.enabled) {
                    const interval = `${this.state.musicMode.interval}m`;
                    this.timedRandomEvent = Tone.Transport.scheduleRepeat(time => {
                        Tone.Draw.schedule(() => this.triggerGenerativeStep(), time)
                    }, interval, "1m");
                    this.logChange(`Music Mode enabled, randomizing every ${this.state.musicMode.interval} bars.`);
                } else {
                    this.logChange("Music Mode disabled.");
                }
            },

            logChange(message, options = {}) {
                if (!this.dom.musicModeLog) return;
                if (options.separator) {
                    const separator = document.createElement('div');
                    separator.className = 'log-separator';
                    this.dom.musicModeLog.prepend(separator);
                    return;
                }
                if (this.state.musicMode && this.state.musicMode.refine && options.isGenerative && !options.forceLog) return;
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.textContent = message;
                this.dom.musicModeLog.prepend(entry);
                while (this.dom.musicModeLog.children.length > 50) {
                    this.dom.musicModeLog.removeChild(this.dom.musicModeLog.lastChild);
                }
            },

            async triggerGenerativeStep() {
                try {
                    const presetKey = this.state.musicMode.preset;
                    if(presetKey === 'off') return;

                    const preset = this.MUSIC_MODE_PRESETS[presetKey];
                    if (!preset) return;

                    const activeTracks = this.state.tracks.filter(t => t.active);
                    if (activeTracks.length === 0) return;

                    this.logChange(null, { separator: true });

                    let nextStateChanges = {};

                    const randomizerOptions = preset.options;

                    if(this.state.randomization.randomizeOctave && !this.state.locks.octave) {
                        const newOctave = Math.max(1, Math.min(8, this.state.randomization.octave + (Math.floor(Math.random() * 3) - 1)));
                        if (newOctave !== this.state.randomization.octave) {
                            if (!nextStateChanges.randomization) nextStateChanges.randomization = {...this.state.randomization};
                            nextStateChanges.randomization.octave = newOctave;
                            this.logChange(`New base octave: ${newOctave}`, { isGenerative: true, forceLog: true });
                        }
                    }

                    if (randomizerOptions.scale && !this.state.locks.scale) {
                        const scaleNames = Object.keys(this.SCALES);
                        const randomScaleName = scaleNames[Math.floor(Math.random() * scaleNames.length)];
                        const randomRootNote = Math.floor(Math.random() * 12);
                        nextStateChanges.currentScaleName = `${this.NOTE_NAMES[randomRootNote]} ${randomScaleName}`;
                        this.logChange(`Scale: ${nextStateChanges.currentScaleName}`, { isGenerative: true, forceLog: true });
                    }

                    if (Object.keys(nextStateChanges).length > 0) {
                        this.updateState(nextStateChanges);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }

                    let newTracks = JSON.parse(JSON.stringify(this.state.tracks));
                    const assignedNotesByChannel = {};

                    if (presetKey === 'jazz' || presetKey === 'rock') {
                        this.handleChordalMode(presetKey, newTracks);
                    } else if (presetKey === 'fifths') {
                        this.handleFifthsMode(newTracks);
                    } else if (presetKey === 'berlin') {
                        this.handleBerlinMode(true);
                        return; // Berlin mode is a full setup, so we exit
                    }
                    else if (preset.multi) {
                        newTracks.forEach(t => {
                            if(t.active) newTracks = this.randomizeTrackParameters(t, randomizerOptions, true, assignedNotesByChannel, newTracks);
                        });
                    } else if (preset.options.note || preset.options.pulses || preset.options.rotation || preset.options.velocity) {
                        let availableTracks = activeTracks.filter(t => t.id !== this.lastRandomizedTrackId);
                        if(availableTracks.length === 0) availableTracks = activeTracks;
                        const trackToRandomize = availableTracks[Math.floor(Math.random() * availableTracks.length)];
                        if (trackToRandomize) {
                            this.lastRandomizedTrackId = trackToRandomize.id;
                            newTracks = this.randomizeTrackParameters(trackToRandomize, randomizerOptions, true, assignedNotesByChannel, newTracks);
                        }
                    }
                    this.updateState({tracks: newTracks});

                    if (this.state.musicMode.refine) {
                        setTimeout(() => this.handleRefine(false), 50);
                    }
                    if (this.state.musicMode.autoQuantize) {
                        setTimeout(() => this.handleQuantizeNotes(false), 60);
                    }
                } catch (error) {
                    console.error("Error during generative step:", error);
                }
            },

            handleChordalMode(modeName, tracks) {
                const requiredScale = modeName === 'jazz' ? 'Major' : 'Minor';
                const parts = this.state.currentScaleName.split(' ');
                const rootNote = this.NOTE_NAMES.indexOf(parts[0]);
                const scaleName = parts.slice(1).join(' ');

                if (scaleName !== requiredScale) {
                    this.logChange(`${modeName} Mode needs ${requiredScale} scale.`, { isGenerative: true, forceLog: true });
                    return;
                }

                const scaleIntervals = this.SCALES[scaleName];
                const diatonicMap = modeName === 'jazz'
                    ? { 0: [0,4,7,11], 2: [0,3,7,10], 4: [0,3,7,10], 5: [0,4,7,11], 7: [0,4,7,10], 9: [0,3,7,10], 11: [0,3,6,10] }
                    : {0:[0,7], 2:[0,7], 3:[0,7], 5:[0,7], 7:[0,7], 8:[0,7], 10:[0,7]};

                let chordIntervals;
                let chordName;

                const randomDegreeIndex = Math.floor(Math.random() * 7);
                const degreeRoot = scaleIntervals[randomDegreeIndex];
                chordIntervals = diatonicMap[degreeRoot] || [0, 7]; // Fallback
                const chordRootNote = rootNote + degreeRoot;
                chordName = `${this.NOTE_NAMES[chordRootNote % 12]}${modeName === 'jazz' ? 'maj7' : 'm'}`; // Simplified chord name

                if(this.state.musicMode.randomizeChord || this.state.musicMode.chordType === 'Random') {
                    this.logChange(`Generative Chord: ${chordName} (${modeName})`, { isGenerative: true, forceLog: true });
                } else {
                    chordIntervals = this.CHORD_TYPES[this.state.musicMode.chordType] || [0,7];
                    const chordRoot = rootNote + scaleIntervals[Math.floor(Math.random() * 7)];
                    chordName = `${this.NOTE_NAMES[chordRoot % 12]}${this.state.musicMode.chordType}`;
                    this.logChange(`Generative Chord: ${chordName} (${modeName})`, { isGenerative: true, forceLog: true });
                }

                const chordRootMidi = rootNote + (scaleIntervals[Math.floor(Math.random() * 7)]);
                const chordNotes = chordIntervals.map(i => chordRootMidi + i + (this.state.randomization.octave * 12));

                const activeTracks = tracks.filter(t => t.active);
                activeTracks.forEach((track, i) => {
                    const trackIndex = tracks.findIndex(t => t.id === track.id);
                    if(trackIndex !== -1) {
                        tracks[trackIndex].note = chordNotes[i % chordNotes.length];
                    }
                });
            },

            handleFifthsMode(tracks) {
                const parts = this.state.currentScaleName.split(' ');
                let rootNote = this.NOTE_NAMES.indexOf(parts[0]);
                const scaleName = parts.slice(1).join(' ');
                const oldRootName = this.NOTE_NAMES[rootNote];

                rootNote = (rootNote + 7) % 12; // Move up a perfect fifth
                const newRootName = this.NOTE_NAMES[rootNote];

                const newScale = `${newRootName} ${scaleName}`;
                this.logChange(`Fifths Walk: ${oldRootName} -> ${newRootName}`, { isGenerative: true, forceLog: true });
                this.updateState({ currentScaleName: newScale });
            },

            randomizeTrackParameters(track, options, shouldLog = true, assignedNotesByChannel = {}, tracks) {
                let changes = [];
                let newTrackState = {...track};

                if (options.pulses && !this.state.locks.pulses) {
                    const old = track.pulses;
                    const maxPulses = this.state.locks.steps ? this.state.globalLockedSteps : track.steps;
                    newTrackState.pulses = maxPulses > 0 ? Math.floor(Math.pow(Math.random(), 2) * (maxPulses - 1)) + 1 : 0;
                    changes.push(`P:${old}→${newTrackState.pulses}`);
                }
                if (options.rotation && !this.state.locks.rotation) {
                    const old = track.rotation;
                    newTrackState.rotation = track.steps > 0 ? Math.floor(Math.random() * track.steps) : 0;
                    changes.push(`R:${old}→${newTrackState.rotation}`);
                }
                if (options.note) {
                    const baseOctave = this.state.randomization.octave;
                    const minMidi = Math.max(12, (baseOctave - 1) * 12);
                    const maxMidi = Math.min(127, (baseOctave + 1) * 12 + 11);

                    let octaveFilteredScale = this.currentRandomizationScale.filter(note => note >= minMidi && note <= maxMidi);
                    if (octaveFilteredScale.length === 0) octaveFilteredScale = this.currentRandomizationScale;

                    const trackChannel = track.channelOverride === 'global' ? this.state.globalMidiChannel : parseInt(track.channelOverride, 10);
                    const usedNotesOnChannel = assignedNotesByChannel[trackChannel] || [];
                    let availableNotes = octaveFilteredScale.filter(n => !usedNotesOnChannel.includes(n));
                    if(availableNotes.length === 0) availableNotes = octaveFilteredScale;

                    if (availableNotes.length > 0) {
                        const newNote = availableNotes[Math.floor(Math.random() * availableNotes.length)];
                        changes.push(`N:${Tone.Frequency(track.note, "midi").toNote()}→${Tone.Frequency(newNote, "midi").toNote()}`);
                        newTrackState.note = newNote;
                        if (!assignedNotesByChannel[trackChannel]) assignedNotesByChannel[trackChannel] = [];
                        assignedNotesByChannel[trackChannel].push(newNote);
                    }
                }
                if (options.velocity && !this.state.locks.velocity) {
                    newTrackState.velocity = Math.floor(Math.random() * 48) + 80; // Range 80-127
                    changes.push(`V:${track.velocity}→${newTrackState.velocity}`);
                }

                if (options.instruments && this.state.midiOutputId === 'internal_synth' && !this.state.locks.instruments) {
                    const newChannel = Math.floor(Math.random() * 16) + 1;
                    newTrackState.channelOverride = newChannel;
                    changes.push(`Inst: → ${this.INTERNAL_SYNTH_NAMES[newChannel-1]}`);
                }

                const trackIndex = tracks.findIndex(t => t.id === track.id);
                if(trackIndex !== -1) {
                    tracks[trackIndex] = newTrackState;
                }

                const changesString = changes.length > 0 ? `T${track.id + 1}: ${changes.join(', ')}` : null;
                if (shouldLog && changesString) this.logChange(changesString, { isGenerative: true });

                return tracks;
            },

            handleMasterRandomize() {
                let changesToMake = {};
                this.logChange(null, { separator: true });

                if(this.state.randomization.randomizeOctave) {
                    const newOctave = Math.max(1, Math.min(8, this.state.randomization.octave + (Math.floor(Math.random() * 3) - 1)));
                    changesToMake.randomization = { ...this.state.randomization, octave: newOctave };
                    this.logChange(`New base octave: ${newOctave}`);
                }

                if(this.state.randomization.scale) {
                    const scaleNames = Object.keys(this.SCALES);
                    const randomScaleName = scaleNames[Math.floor(Math.random() * scaleNames.length)];
                    const newScale = `${this.NOTE_NAMES[Math.floor(Math.random() * 12)]} ${randomScaleName}`;
                    changesToMake.currentScaleName = newScale;
                    this.logChange(`Scale: ${newScale}`);
                }

                let newTracks = JSON.parse(JSON.stringify(this.state.tracks));
                const assignedNotesByChannel = {};

                const options = {...this.state.randomization};

                newTracks.forEach(t => {
                    if(t.active) this.randomizeTrackParameters(t, options, true, assignedNotesByChannel, newTracks);
                });
                changesToMake.tracks = newTracks;

                this.updateState(changesToMake);

                this.showStatusMessage("All Active Tracks Randomized!", 2500);
                document.documentElement.classList.add('randomize-flash');
                setTimeout(() => document.documentElement.classList.remove('randomize-flash'), 200);
            },

            handleRefine(showStatus = true) {
                const activeTracks = this.state.tracks.filter(t => t.active);
                if (activeTracks.length < 2) {
                    if(showStatus) {
                        this.logChange("Need at least 2 active tracks to refine.");
                        this.showStatusMessage("Refinement requires at least 2 active tracks.", 3000);
                    }
                    return;
                }

                let newTracks = JSON.parse(JSON.stringify(this.state.tracks));
                let refinementLogs = [];

                const rootNoteMidi = this.NOTE_NAMES.indexOf(this.state.currentScaleName.split(' ')[0]);
                let notes = activeTracks.map(t => ({ note: t.note, id: t.id, isRoot: (t.note % 12) === rootNoteMidi }));
                notes.sort((a, b) => a.note - b.note);

                const lowestNote = notes[0];
                if (!lowestNote.isRoot) {
                    const lowestTrackIndex = newTracks.findIndex(t => t.id === lowestNote.id);
                    if (lowestTrackIndex !== -1) {
                        const currentOctave = Math.floor(newTracks[lowestTrackIndex].note / 12);
                        newTracks[lowestTrackIndex].note = (currentOctave -1) * 12 + rootNoteMidi;
                    }
                }

                let currentNotes = newTracks.filter(t => t.active).map(t => t.note);
                for (let i = 0; i < currentNotes.length; i++) {
                    for (let j = i + 1; j < currentNotes.length; j++) {
                        if (Math.abs(currentNotes[i] - currentNotes[j]) % 12 === 1) { // Minor second clash
                            const trackToChangeId = newTracks.filter(t => t.active)[j].id;
                            const trackIndex = newTracks.findIndex(t => t.id === trackToChangeId);
                            const oldNote = newTracks[trackIndex].note;

                            let newNote = this.findClosestNoteInScale(oldNote + 1, this.currentRandomizationScale);
                            if (newNote === oldNote || currentNotes.includes(newNote)) {
                                newNote = this.findClosestNoteInScale(oldNote - 1, this.currentRandomizationScale);
                            }
                            if (newNote === oldNote || currentNotes.includes(newNote)) {
                                newNote = this.findClosestNoteInScale(oldNote + 2, this.currentRandomizationScale);
                            }

                            if (newNote !== oldNote && !currentNotes.includes(newNote)) {
                                newTracks[trackIndex].note = newNote;
                                currentNotes[j] = newNote;
                                refinementLogs.push(`Resolved M2: ${Tone.Frequency(oldNote, 'midi').toNote()}→${Tone.Frequency(newNote, 'midi').toNote()}`);
                            }
                        }
                    }
                }

                if (refinementLogs.length > 0) {
                    this.logChange(`Refined: ${refinementLogs.join(' | ')}`);
                } else if (showStatus) {
                    this.logChange("Refined: No changes needed.");
                }

                this.updateState({ tracks: newTracks });
                if(showStatus) this.showStatusMessage("Sequence refined!", 2000);
            },
            populateChannelSelectors() {
                const isInternal = this.state.midiOutputId === 'internal_synth';
                const selects = [this.dom.midiChannelSelect, ...document.querySelectorAll('select[id^="channelOverride"]')];

                selects.forEach(select => {
                    if(!select) return;
                    const currentVal = select.value;
                    let optionsHtml = '';
                    if(select.id.includes('channelOverride')){
                        optionsHtml += `<option value="global">Global</option>`;
                    }
                    for(let i = 1; i <= 16; i++){
                        const name = isInternal ? `(${this.INTERNAL_SYNTH_NAMES[i-1]})` : '';
                        optionsHtml += `<option value="${i}">Ch ${i} ${name}</option>`;
                    }
                    select.innerHTML = optionsHtml;
                    select.value = currentVal;
                });
            },
            confirmReset() {
                this.dom.dialogMessage.textContent = "Are you sure you want to reset all settings to their defaults? This cannot be undone.";
                this.dom.confirmationDialog.classList.add('visible');

                const confirmHandler = async () => {
                    const currentDevice = this.state.midiOutputId;
                    await this.loadState(this.getDefaultState());
                    this.updateState({ midiOutputId: currentDevice });
                    this.showStatusMessage("Application reset to defaults.", 2000);
                    cleanup();
                };

                const cancelHandler = () => {
                    cleanup();
                };

                const cleanup = () => {
                    this.dom.confirmationDialog.classList.remove('visible');
                    this.dom.dialogConfirm.removeEventListener('click', confirmHandler);
                    this.dom.dialogCancel.removeEventListener('click', cancelHandler);
                };

                this.dom.dialogConfirm.addEventListener('click', confirmHandler, { once: true });
                this.dom.dialogCancel.addEventListener('click', cancelHandler, { once: true });
            },
            setAllTracksToGlobal() {
                const newTracks = this.state.tracks.map(t => ({...t, channelOverride: 'global'}));
                this.updateState({tracks: newTracks});
                this.showStatusMessage("All tracks set to Global Channel.", 2000);
            },
            handleHelpPanelVisibility() {
                let runCount = parseInt(localStorage.getItem(this.APP_RUN_COUNT_KEY) || '0');
                if (runCount < 10) {
                    this.updateState({view: {...this.state.view, showHelpPanel: true}});
                    runCount++;
                    localStorage.setItem(this.APP_RUN_COUNT_KEY, runCount.toString());
                } else {
                    this.updateState({view: {...this.state.view, showHelpPanel: false}});
                }
            },
            handleOctaveChange(newOctave) {
                this.updateState({ randomization: { ...this.state.randomization, octave: newOctave }}, () => {
                    if (this.state.randomization.note) {
                        let newTracks = JSON.parse(JSON.stringify(this.state.tracks));
                        const assignedNotesByChannel = {};
                        newTracks.forEach(t => {
                            if (t.active) {
                                this.randomizeTrackParameters(t, { note: true }, false, assignedNotesByChannel, newTracks);
                            }
                        });
                        this.updateState({ tracks: newTracks });
                        this.showStatusMessage("Notes Randomized to New Octave", 1500);
                    }
                });
            },
            tryMe() {
                const root = Math.floor(Math.random() * 12);
                const scaleType = Math.random() > 0.5 ? 'Major' : 'Minor';
                const scale = this.SCALES[scaleType];

                const newTracks = this.state.tracks.map((track, i) => {
                    let newTrack = {...track};
                    newTrack.active = true;
                    if(i === 0) { // Bass
                        newTrack.note = 12 * 2 + root; // C2
                        newTrack.pulses = 4;
                        newTrack.steps = 16;
                        newTrack.rotation = 0;
                        newTrack.channelOverride = 16; // Sub Bass
                    } else if (i === 1) { // Pad
                        newTrack.note = 12 * 4 + root + scale[2]; // E4
                        newTrack.pulses = 2;
                        newTrack.steps = 16;
                        newTrack.rotation = 4;
                        newTrack.channelOverride = 13; // Soft Pad
                    } else if (i === 2) { // Melody
                        newTrack.note = 12 * 5 + root + scale[4]; // G5
                        newTrack.pulses = 7;
                        newTrack.steps = 16;
                        newTrack.rotation = Math.floor(Math.random() * 16);
                        newTrack.channelOverride = 1; // Piano
                    } else { // Perc/Accent
                        newTrack.note = 12 * 6 + root + scale[6];
                        newTrack.pulses = 3;
                        newTrack.steps = 16;
                        newTrack.rotation = Math.floor(Math.random() * 16);
                        newTrack.channelOverride = 10; // Metallic Perc
                    }
                    return newTrack;
                });

                this.updateState({
                    tracks: newTracks,
                    currentScaleName: `${this.NOTE_NAMES[root]} ${scaleType}`,
                    randomization: {...this.state.randomization, octave: 3 }
                });
                this.showStatusMessage("Try Me! A new setup has been created.", 2500);
            },
            handleBerlinMode(isGenerative = false) {
                if(!isGenerative) {
                    this.updateState({musicMode: {...this.state.musicMode, preset: 'berlin'}});
                }
                const root = 0; // C
                const scale = this.SCALES['Minor Pentatonic'];
                const newTracks = this.state.tracks.map((track, i) => {
                    let newTrack = {...track};
                    newTrack.active = true;
                    switch(i) {
                        case 0: // Bass Sequence
                            newTrack.note = 12 * 2 + root; // C2
                            newTrack.pulses = 8;
                            newTrack.steps = 16;
                            newTrack.rotation = 0;
                            newTrack.channelOverride = 16; // Sub Bass
                            newTrack.velocity = 110;
                            break;
                        case 1: // Main Arp
                            newTrack.note = 12 * 4 + root; // C4
                            newTrack.pulses = 12;
                            newTrack.steps = 16;
                            newTrack.rotation = 2;
                            newTrack.channelOverride = 7; // Square Pluck
                            newTrack.velocity = 90;
                            break;
                        case 2: // Counter Arp
                            newTrack.note = 12 * 5 + root + scale[3]; // G5
                            newTrack.pulses = 7;
                            newTrack.steps = 16;
                            newTrack.rotation = 8;
                            newTrack.channelOverride = 8; // Duo Arp
                            newTrack.velocity = 80;
                            break;
                        case 3: // High Pad/FX
                            newTrack.note = 12 * 6 + root; // C6
                            newTrack.pulses = 1;
                            newTrack.steps = 32;
                            newTrack.rotation = 16;
                            newTrack.channelOverride = 2; // Bright Pad
                            newTrack.velocity = 70;
                            break;
                        default:
                            newTrack.active = false;
                    }
                    return newTrack;
                });
                this.updateState({
                    bpm: 135,
                    tracks: newTracks,
                    currentScaleName: 'C Minor Pentatonic',
                    randomization: {...this.state.randomization, octave: 4 }
                });
                this.showStatusMessage("Berlin School mode activated!", 2500);
            }
        };

        // --- APPLICATION KICK-OFF ---
        RhythmKingApp.init();

    });
</script>
</body>
</html>
