<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm King 77 - Euclidean MIDI Sequencer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for a more refined look */
        :root {
            --primary-bg: #2a2a2a;
            --secondary-bg: #3a3a3a;
            --panel-bg: #4a4a4a;
            --panel-border: #6a6a6a;
            --text-color: #e0e0e0;
            --accent-color: #f0ad4e;
            --accent-glow: rgba(240, 173, 78, 0.7);
            --control-bg: #333333;
            --control-border: #555555;
            --thumb-color: #c0b090;
            --active-toggle: #5cb85c;
            --random-btn: #337ab7;
            --learn-btn: #d9534f;
            --save-load-btn: #5bc0de;
            --midi-util-btn: #f0ad4e;
            --refine-btn: #9b59b6;
            --quantize-btn: #2ecc71;
            --status-bg: rgba(0,0,0,0.8);
            --status-text: #fff;
        }

        html {
            transition: box-shadow 0.15s ease-out;
        }

        html.randomize-flash {
            box-shadow: inset 0 0 15px 5px var(--accent-glow);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-color);
            overscroll-behavior: none;
            font-size: 11px; /* Compressed UI */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .main-container {
            margin-bottom: 2rem;
            flex-grow: 1;
        }
        /* UI Enhancement: 3D panel effect */
        .synth-panel {
            background-color: #444;
            background-image: linear-gradient(to bottom, #4f4f4f, #3a3a3a);
            border: 1px solid #222;
            border-top-color: #555;
            border-radius: 10px; /* Compressed UI */
            box-shadow: 0 4px 12px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.1);
            padding: 0.5rem; /* Compressed UI */
            transition: opacity 0.4s ease-in-out, filter 0.4s ease-in-out, border-color 0.4s ease-in-out, box-shadow 0.4s ease-in-out;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 0.4rem; /* Compressed UI */
        }
        .synth-panel h2 {
            margin-bottom: 0.4rem; /* Compressed UI */
            flex-shrink: 0;
            color: var(--text-color);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            font-size: 1.1em;
        }

        .synth-panel.track-pulse {
            animation: trackPulse 0.2s ease-out;
        }
        @keyframes trackPulse {
            from {
                border-color: var(--flash-color, var(--accent-color));
                box-shadow: 0 0 12px 2px var(--flash-glow, var(--accent-glow)), 0 4px 12px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.1);
            }
            to {
                border-color: #222;
                box-shadow: 0 4px 12px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.1);
            }
        }

        .control-slider-container { display: flex; align-items: center; gap: 0.4rem; }
        .number-input-container { display: flex; align-items: center; gap: 0.4rem; }
        .slider-button, .number-input-button {
            background-color: var(--control-border); color: var(--text-color); border: 1px solid var(--control-bg); border-radius: 5px;
            padding: 0.1rem 0.4rem; font-size: 0.9rem; font-weight: bold; line-height: 1; cursor: pointer; user-select: none;
            transition: background-color 0.1s ease;
        }
        .slider-button:hover, .number-input-button:hover { background-color: var(--panel-border); }

        .control-slider {
            -webkit-appearance: none; appearance: none; width: 100%; height: 18px;
            background: #2a2a2a; border-radius: 8px; border: 1px solid #222;
            outline: none; cursor: pointer; flex-grow: 1; box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }
        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 24px; height: 24px;
            background-image: linear-gradient(to bottom, #e0e0e0, #a0a0a0);
            border-radius: 6px; border: 1px solid #555; cursor: grab;
            box-shadow: 0 2px 2px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
            transition: all 0.1s ease;
        }
        .control-slider::-moz-range-thumb {
            width: 24px; height: 24px;
            background-image: linear-gradient(to bottom, #e0e0e0, #a0a0a0);
            border-radius: 6px; border: 1px solid #555; cursor: grab;
            box-shadow: 0 2px 2px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
            transition: all 0.1s ease;
        }
        .control-slider:hover::-webkit-slider-thumb, .control-slider:hover::-moz-range-thumb {
            background-image: linear-gradient(to bottom, var(--accent-color), #d88c1b);
            box-shadow: 0 0 6px var(--accent-glow), 0 2px 2px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
        }

        .push-button {
            font-family: 'Orbitron', sans-serif; background-color: #585858; background-image: linear-gradient(to bottom, #6a6a6a, #4a4a4a);
            color: var(--text-color); border: 1px solid #333; border-top-color: #777; padding: 0.2rem 0.6rem;
            border-radius: 6px; text-transform: capitalize; font-weight: bold; font-size: 0.65rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.15);
            transition: all 0.1s ease-in-out; height: 28px; display: inline-flex; align-items: center; justify-content: center;
        }
        .push-button.icon-button { font-size: 1rem; padding: 0.3rem; width: 28px; height: 28px; }
        .push-button:active, .push-button.active {
            background-image: linear-gradient(to top, #6a6a6a, #4a4a4a); box-shadow: 0 1px 1px rgba(0,0,0,0.4), inset 0 2px 3px rgba(0,0,0,0.4);
            transform: translateY(1px); border-top-color: #333;
        }
        .push-button.active { background-image: linear-gradient(to top, var(--accent-color), #d88c1b); color: #333; }
        .push-button:disabled { opacity: 0.5; cursor: not-allowed; background-image: none; box-shadow: none; }

        #playStopButton { background-color: #5cb85c; background-image: linear-gradient(to bottom, #7fdf7f, #5cb85c); color: white; }
        #playStopButton.stop-state { background-color: #d9534f; background-image: linear-gradient(to bottom, #e47875, #d9534f); }
        #playStopButton:active { background-image: linear-gradient(to top, #7fdf7f, #5cb85c); }
        #playStopButton.stop-state:active { background-image: linear-gradient(to top, #e47875, #d9534f); }

        .learn-cc-button, .note-learn-button {
            background-color: var(--learn-btn); color: white; flex-shrink: 0; padding: 0.1rem 0.4rem; font-size: 0.65rem;
            border-radius: 5px; border: 1px solid #c9302c; box-shadow: 0 1px 1px rgba(0,0,0,0.3);
        }
        .learn-cc-button:hover, .note-learn-button:hover { background-color: #c9302c; }
        .learn-cc-button.learning, .note-learn-button.learning { background-color: #ffc107; color: #333; animation: pulseLearn 1s infinite alternate; }
        @keyframes pulseLearn { from { box-shadow: 0 0 4px #ffc107; } to { box-shadow: 0 0 12px #ffc107; } }
        .learn-cc-button.mapped { background-color: #4CAF50; border-color: #337a36; }

        .randomize-button { background-color: var(--random-btn); color: white; background-image: linear-gradient(to bottom, #5d9cec, #337ab7);}
        .master-randomize-button { background-color: #f0ad4e; color: #333; background-image: linear-gradient(to bottom, #f3c27a, #f0ad4e);}
        .re-init-midi-button { background-color: #6c757d; background-image: linear-gradient(to bottom, #868e96, #6c757d);}
        .save-load-button { background-color: var(--save-load-btn); color: white; background-image: linear-gradient(to bottom, #81d4fa, #5bc0de);}
        .midi-utility-button { background-color: var(--midi-util-btn); color: #333; background-image: linear-gradient(to bottom, #f3c27a, #f0ad4e);}
        .refine-button { background-color: var(--refine-btn); background-image: linear-gradient(to bottom, #af7ac5, #9b59b6); color: white; }
        .refine-button:active { background-image: linear-gradient(to top, #af7ac5, #9b59b6); }
        .quantize-button { background-color: var(--quantize-btn); background-image: linear-gradient(to bottom, #58d68d, #2ecc71); color: white; }
        .quantize-button:active { background-image: linear-gradient(to top, #58d68d, #2ecc71); }

        .pattern-display { display: flex; justify-content: center; align-items: center; margin-top: 0.2rem; height: 20px; gap: 3px; }
        .pattern-step {
            width: 10px; height: 10px; background-color: #333; border-radius: 50%;
            transition: background-color 0.1s ease-out, transform 0.1s ease-out; flex-shrink: 0; border: 1px solid #222;
            box-shadow: inset 0 1px 1px rgba(0,0,0,0.5);
        }
        .pattern-step.active { background-color: var(--accent-color); box-shadow: 0 0 4px var(--accent-glow), inset 0 1px 1px rgba(255,255,255,0.3);}
        .pattern-step.current { background-color: #fff; border: 1px solid var(--accent-color); transform: scale(1.3); box-shadow: 0 0 6px rgba(255,255,255,0.9); }

        label { display: block; margin-bottom: 0.1rem; font-size: 0.7rem; text-transform: uppercase; font-family: 'Orbitron', sans-serif; white-space: nowrap; margin-right: 0.5rem; color: var(--accent-color); text-shadow: 0 1px 1px #000; }
        select, input[type="number"], input[type="text"] {
            background-color: var(--control-bg); border: 1px solid #222; color: var(--text-color); padding: 0.3rem; border-radius: 5px; width: 100%; font-size: 0.75rem;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }
        input[type="number"] { text-align: center; }

        .value-display { font-family: 'Orbitron', sans-serif; color: var(--text-color); font-size: 0.75rem; min-width: 25px; text-align: right; flex-grow: 1; text-shadow: 0 1px 1px #000; }
        .control-group { display: flex; flex-direction: column; margin-bottom: 0; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.2rem; }
        .checkbox-label-container { display: flex; align-items: center; gap: 0.4rem; font-size: 0.75rem; margin-top: 0.2rem; cursor: pointer; color: var(--text-color); }
        .checkbox-label-container input[type="checkbox"] { width: 14px; height: 14px; accent-color: var(--accent-color); border-radius: 3px; }

        #sequencerWrapperPanel { width: 100%; }
        #sequencerTracksContainer { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.5rem; padding: 0.5rem 0; margin-left: auto; margin-right: auto; }
        #sequencerTracksContainer > .synth-panel { margin-bottom: 0; min-width: 280px; max-width: 320px; flex: 1 1 280px; }

        .explanation-text-footer { font-size: 0.8rem; line-height: 1.4; color: #b0b0b0; text-align: center; padding: 1rem; max-width: 700px; margin: 1rem auto 0 auto; border-top: 1px solid var(--control-border); }
        .note-input-group { display: flex; align-items: center; gap: 0.25rem; }
        .note-input-group > input { flex-grow: 1; }
        .note-learn-button { padding: 0.1rem 0.3rem; }

        #musicModePanel, #channelVolumesWrapper, #midiPanel, #randomizationSettingsContainer, #hintsPanel { display: none; }
        body.music-mode-active #musicModePanel { display: flex; }
        #appContainer { display: flex; flex-direction: column; gap: 0.5rem; flex-grow: 1; }
        #mainContent { flex-grow: 1; min-width: 0; display: flex; flex-direction: column; }

        #musicModeLog {
            height: 100%; background-color: rgba(0,0,0,0.3); border-radius: 6px; padding: 0.2rem 0.3rem;
            font-size: 0.6rem; line-height: 1.4; overflow-y: auto; display: flex; flex-direction: column-reverse; color: var(--accent-color);
        }
        #musicModeLog > div.log-entry { padding-bottom: 0.1rem; margin-bottom: 0.1rem; border-bottom: 1px solid rgba(255,255,255,0.05); word-break: break-word; }
        #musicModeLog > div.log-separator { height: 1px; background-color: var(--control-border); margin: 3px 0; border: none; }

        #channelVolumesContainer { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 0.4rem 0.6rem; padding: 0.1rem; }
        #channelVolumesContainer .control-group { margin-bottom: 0; }
        #channelVolumesContainer .control-header { margin-bottom: 0.1rem; }
        #channelVolumesContainer .control-slider { height: 10px; }
        #channelVolumesContainer .control-slider::-webkit-slider-thumb { width: 18px; height: 18px; }
        #channelVolumesContainer .control-slider::-moz-range-thumb { width: 18px; height: 18px; }
        #channelVolumesContainer label { font-size: 0.65rem; }

        #octaveSelector { display: flex; justify-content: center; }
        #musicModePresetContainer { display: grid; grid-template-columns: repeat(auto-fit, minmax(55px, 1fr)); gap: 0.25rem;}
        #musicModePresetContainer .radio-label { font-size: 0.7rem; }

        .radio-label {
            display: inline-flex; align-items: center; background-color: var(--control-bg); border: 1px solid var(--control-border);
            padding: 0.2rem 0.5rem; transition: all 0.1s ease; font-size: 0.75rem; cursor: pointer; justify-content: center;
        }
        .radio-label input { display: none; }
        .radio-label:hover { background-color: var(--panel-border); z-index: 1; position: relative; }
        .radio-label.selected { background-color: var(--accent-color); border-color: #f8c57a; z-index: 2; position: relative; }
        .radio-label.selected span { color: var(--primary-bg); font-weight: bold; }

        #octaveSelector .radio-label { padding: 0.2rem; width: 24px; text-align: center; }
        #octaveSelector .radio-label:not(:first-child) { margin-left: -1px; }
        #octaveSelector .radio-label:first-child { border-radius: 6px 0 0 6px;}
        #octaveSelector .radio-label:last-child { border-radius: 0 6px 6px 0;}

        #musicModePresetContainer .radio-label { border-radius: 6px; margin-left: 0; }

        #logSection { display: none; }
        body.music-mode-active #logSection { display: flex; }

        #bottom-panels-container { display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: stretch; }
        #bottom-panels-container > .synth-panel { flex-grow: 1; flex-shrink: 1; flex-basis: 280px; height: auto; }
        #masterControlPanel { max-width: 350px; }
        #viewPanel, #midiPanel, #randomizationSettingsContainer, #musicModePanel { flex: 1 1 200px; max-width: 280px; }
        #channelVolumesWrapper { flex: 1 1 300px; max-width: 400px; }

        #hintsPanel { flex: 1 1 280px; display: flex; flex-direction: column;}
        #hintsPanel .control-group { display: flex; flex-direction: column; }
        #hintsPanel .control-group#hintContainer { flex-shrink: 0; }
        #hintsPanel #logSection { flex-grow: 1; }

        .toggle-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.25rem; }

        #statusBar {
            position: fixed; bottom: 0; left: 0; width: 100%; background-color: var(--status-bg); color: var(--status-text);
            padding: 0.4rem 1rem; text-align: center; font-size: 0.8rem; z-index: 1000; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; border-top: 1px solid var(--accent-color);
        }
        #statusBar.visible { opacity: 1; visibility: visible; }
        #hintContent {
            background-color: var(--control-bg); border: 1px solid var(--control-border); border-radius: 6px; padding: 0.5rem;
            min-height: 60px; display: flex; align-items: center; justify-content: center; color: #b0b0b0; font-style: italic;
        }

        #app-background {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-size: cover;
            transition: all 1s ease-in-out; opacity: 0.8; filter: grayscale(0.5);
        }
        #app-background.bg-default { background-color: var(--primary-bg); background-image: radial-gradient(circle at center, rgba(60,60,60,0.1) 1px, transparent 1px); background-size: 20px 20px; }
        #app-background.bg-music-mode {
            background-color: #3b3b3b; filter: grayscale(0);
            background-image: linear-gradient(0deg, transparent 24%, rgba(240,173,78,0.05) 25%, rgba(240,173,78,0.05) 26%, transparent 27%, transparent 74%, rgba(240,173,78,0.05) 75%, rgba(240,173,78,0.05) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(240,173,78,0.05) 25%, rgba(240,173,78,0.05) 26%, transparent 27%, transparent 74%, rgba(240,173,78,0.05) 75%, rgba(240,173,78,0.05) 76%, transparent 77%, transparent);
            background-size: 80px 80px;
        }
    </style>
</head>
<body class="p-1 md:p-2">

<div id="app-background" class="bg-default"></div>

<header class="text-center mb-2">
    <h1 class="text-2xl md:text-3xl font-bold" style="font-family: 'Orbitron', sans-serif; color: var(--accent-color);">Rhythm King 77</h1>
    <p class="text-xs md:text-sm text-gray-400">Euclidean MIDI Sequencer</p>
</header>

<div id="appContainer">
    <div id="mainContent" class="flex-grow">
        <div class="flex flex-col gap-2 main-container">
            <div id="sequencerWrapperPanel" class="w-full synth-panel">
                <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Euclidean Sequencer Tracks</h2>
                <div id="sequencerTracksContainer"></div>
            </div>

            <div id="bottom-panels-container">
                <div id="masterControlPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Master Control</h2>

                    <div id="toolbar" class="flex flex-wrap items-center justify-center gap-2">
                        <button id="playStopButton" class="push-button icon-button" title="Start or stop all sequences">&#x25B6;</button>
                        <button id="refineButton" class="push-button icon-button refine-button" title="Use a musical algorithm to refine the current notes and velocities">‚öñÔ∏è</button>
                        <button id="quantizeNotesButton" class="push-button icon-button quantize-button" title="Quantize all track notes to the selected scale">üéº</button>
                        <button id="saveStateButton" class="push-button save-load-button icon-button" title="Save current state as a manual restore point">&#128190;</button>
                        <button id="loadStateButton" class="push-button save-load-button icon-button" title="Load the last manually saved state">&#128193;</button>
                    </div>

                    <div class="control-group">
                        <label for="numTracksInput">Number of Tracks:</label>
                        <div class="number-input-container">
                            <button class="number-input-button" data-target="numTracksInput" data-action="decrement" title="Decrease number of tracks">&minus;</button>
                            <input type="number" id="numTracksInput" min="1" max="12" value="4" title="Set the total number of sequencer tracks (1-12)">
                            <button class="number-input-button" data-target="numTracksInput" data-action="increment" title="Increase number of tracks">+</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-header">
                            <label for="bpmSlider">Tempo (BPM):</label> <span id="bpmValue" class="value-display">45</span>
                            <button id="bpmSliderLearnCc" class="learn-cc-button ml-2" data-param-id="bpmSlider" title="Map Master Tempo to a MIDI CC knob/fader">L</button>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="bpmSlider" data-action="decrement" title="Decrease Tempo">&minus;</button>
                            <input type="range" id="bpmSlider" min="20" max="240" value="45" class="control-slider" title="Adjust master tempo (20-240 BPM)">
                            <button class="slider-button" data-target="bpmSlider" data-action="increment" title="Increase Tempo">+</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-header">
                            <label for="masterVolumeSlider">Master Volume:</label> <span id="masterVolumeValue" class="value-display">100</span>
                            <button id="masterVolumeLearnCc" class="learn-cc-button ml-2" data-param-id="masterVolumeSlider" title="Map Master Volume to a MIDI CC knob/fader">L</button>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="masterVolumeSlider" data-action="decrement" title="Decrease Volume">&minus;</button>
                            <input type="range" id="masterVolumeSlider" min="0" max="127" value="100" class="control-slider" title="Adjust master output volume (scales all note velocities)">
                            <button class="slider-button" data-target="masterVolumeSlider" data-action="increment" title="Increase Volume">+</button>
                        </div>
                    </div>

                    <div class="control-group border-t border-gray-700 pt-2 mt-2">
                        <label class="font-bold text-xs" style="font-family: 'Orbitron', sans-serif;">Global Controls</label>
                        <div class="toggle-grid">
                            <label class="checkbox-label-container" title="Lock all 'Steps' sliders so they move together. The first track's value becomes the master value."><input type="checkbox" id="lockStepsCheckbox"> Lock All Steps</label>
                        </div>
                    </div>
                </div>

                <div id="viewPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Panel Toggles</h2>
                    <div id="viewTogglesContainer" class="toggle-grid">
                        <label class="checkbox-label-container" title="Show/Hide the MIDI Setup panel"><input type="checkbox" data-view-toggle="midiPanel" id="showMidiPanel" checked> MIDI</label>
                        <label class="checkbox-label-container" title="Show/Hide the Randomization panel"><input type="checkbox" data-view-toggle="randomizationSettingsContainer" id="showRandomizePanel" checked> Randomize</label>
                        <label class="checkbox-label-container" title="Show/Hide the Channel Volumes panel"><input type="checkbox" data-view-toggle="channelVolumesWrapper" id="showVolumesPanel" checked> Volumes</label>
                        <label class="checkbox-label-container" title="Show/Hide the Hints & Log panel"><input type="checkbox" data-view-toggle="hintsPanel" id="showHintsLogPanel" checked> Hints & Log</label>
                        <label class="checkbox-label-container" title="Toggle Music Mode for automatic, generative patterns"><input type="checkbox" id="musicModeToggle"> Music Mode</label>
                    </div>
                </div>

                <div id="midiPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">MIDI Setup</h2>
                    <div class="control-group">
                        <div class="grid grid-cols-2 gap-2">
                            <button id="reInitMidiButton" class="push-button w-full" title="Rescan for MIDI devices if you plugged one in after loading the page">Reset MIDI</button>
                            <button id="allNotesOffButton" class="push-button midi-utility-button w-full" title="Sends an 'All Notes Off' panic message on all channels to stop stuck notes">Stop Notes</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="midiOutSelect">Output Device:</label>
                        <select id="midiOutSelect" title="Select the device or virtual synth to send notes to"></select>
                    </div>
                    <div class="control-group">
                        <label for="midiChannelSelect">Global MIDI Channel:</label>
                        <select id="midiChannelSelect" title="Select the default MIDI channel (1-16) for all tracks set to 'Global'"></select>
                    </div>
                </div>

                <div id="randomizationSettingsContainer" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Randomization</h2>
                    <div class="control-group">
                        <button id="masterRandomizeButton" class="push-button master-randomize-button w-full" title="Randomize all enabled parameters on all active tracks">Randomize All Active</button>
                    </div>

                    <div class="control-group border-t border-b border-gray-700 py-1 my-1">
                        <label class="font-bold text-xs uppercase text-center" style="font-family: 'Orbitron', sans-serif;">Global Scale</label>
                        <div class="grid grid-cols-2 gap-2 mt-1">
                            <div>
                                <label for="scaleRootSelect">Root</label>
                                <select id="scaleRootSelect" title="Set the root note for the global scale"></select>
                            </div>
                            <div>
                                <label for="scaleTypeSelect">Type</label>
                                <select id="scaleTypeSelect" title="Set the type of the global scale"></select>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label for="octaveSelector" class="text-center">Base Octave</label>
                        <div id="octaveSelector" title="Set the base octave for randomized notes"></div>
                    </div>
                    <div id="randomizeOptionsContainer" class="control-group toggle-grid">
                        <label class="checkbox-label-container" title="Randomize the MIDI note of each track"><input type="checkbox" class="randomize-option" id="randomizeNoteCheck" checked> Notes</label>
                        <label class="checkbox-label-container" title="Randomize the number of beats (pulses) in each track"><input type="checkbox" class="randomize-option" id="randomizePulsesCheck" checked> Pulses</label>
                        <label class="checkbox-label-container" title="Randomize the pattern's starting point (rotation)"><input type="checkbox" class="randomize-option" id="randomizeRotationCheck" checked> Rotation</label>
                        <label class="checkbox-label-container" title="Randomize the musical scale for all tracks"><input type="checkbox" class="randomize-option" id="randomizeScaleCheck" checked> Scale</label>
                        <label class="checkbox-label-container" title="Randomize the velocity (loudness) of each track"><input type="checkbox" class="randomize-option" id="randomizeVelocityCheck" checked> Velocity</label>
                        <label class="checkbox-label-container" title="Randomize the base octave during generative changes"><input type="checkbox" class="randomize-option" id="randomizeOctaveCheck"> Octave</label>
                        <label class="checkbox-label-container" title="Allow the chord type to be randomized for Jazz/Rock modes"><input type="checkbox" class="randomize-option" id="randomizeChordCheck"> Chord</label>
                    </div>
                </div>

                <div id="musicModePanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Music Mode</h2>
                    <div class="control-group">
                        <div class="control-header">
                            <label for="randomIntervalSlider">Interval (Bars):</label>
                            <span id="randomIntervalValue" class="value-display">4</span>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="randomIntervalSlider" data-action="decrement" title="Decrease randomization interval">&minus;</button>
                            <input type="range" id="randomIntervalSlider" min="1" max="16" value="4" class="control-slider" title="Set how often Music Mode triggers a change (in musical bars)">
                            <button class="slider-button" data-target="randomIntervalSlider" data-action="increment" title="Increase randomization interval">+</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label class="text-center">Mode</label>
                        <div id="musicModePresetContainer"></div>
                    </div>
                    <div class="control-group">
                        <label for="chordTypeSelect">Chord Type</label>
                        <select id="chordTypeSelect" title="Select the chord type for applicable modes"></select>
                    </div>

                    <div class="control-group">
                        <button id="musicModeNextButton" class="push-button w-full" title="Manually trigger the next generative change">Trigger Next</button>
                    </div>
                    <div class="control-group border-t border-gray-700 pt-2 mt-1 toggle-grid">
                        <label class="checkbox-label-container" title="Apply the Refine algorithm after each generative change to improve musicality"><input type="checkbox" id="musicModeRefineCheck"> Auto-Refine</label>
                        <label class="checkbox-label-container" title="Automatically quantize notes to the selected scale after each generative change"><input type="checkbox" id="musicModeQuantizeCheck"> Auto-Quantize</label>
                    </div>
                </div>

                <div id="channelVolumesWrapper" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Channel Volumes</h2>
                    <div id="channelVolumesContainer"></div>
                </div>

                <div id="hintsPanel" class="synth-panel">
                    <div id="hintContainer" class="control-group">
                        <label class="font-bold text-xs" style="font-family: 'Orbitron', sans-serif;">Helpful Hint</label>
                        <div id="hintContent"></div>
                    </div>
                    <div id="logSection" class="control-group">
                        <label class="font-bold text-xs" style="font-family: 'Orbitron', sans-serif;">Music Mode Log</label>
                        <div id="musicModeLog"></div>
                    </div>
                </div>
            </div>
        </div>

        <footer id="explanationContainer" class="explanation-text-footer">
            <p>Euclidean rhythms are generated by distributing beats as evenly as possible over a set number of time steps.</p>
        </footer>
    </div>
</div>
<div id="statusBar"><div id="statusBar-content"></div></div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // =========================================================================
        // RHYTHM KING APPLICATION OBJECT
        // Encapsulates all application logic to prevent global namespace pollution
        // and to create a more resilient, modular architecture.
        // =========================================================================
        const RhythmKingApp = {
            // --- CONSTANTS AND CONFIGURATION ---
            MAX_TRACKS: 12,
            MANUAL_SAVE_KEY: 'rhythmKing77_manualSave_v33',
            AUTOSAVE_KEY: 'rhythmKing77_autoSave_v33',
            SCALES: { 'Major': [0, 2, 4, 5, 7, 9, 11], 'Minor': [0, 2, 3, 5, 7, 8, 10], 'Dorian': [0, 2, 3, 5, 7, 9, 10], 'Phrygian': [0, 1, 3, 5, 7, 8, 10], 'Lydian': [0, 2, 4, 6, 7, 9, 11], 'Mixolydian': [0, 2, 4, 5, 7, 9, 10], 'Locrian': [0, 1, 3, 5, 6, 8, 10], 'Major Pentatonic': [0, 2, 4, 7, 9], 'Minor Pentatonic': [0, 3, 5, 7, 10], 'Blues': [0, 3, 5, 6, 7, 10], 'Harmonic Minor': [0, 2, 3, 5, 7, 8, 11], 'Whole Tone': [0, 2, 4, 6, 8, 10], 'Chromatic': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] },
            NOTE_NAMES: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
            CHORD_TYPES: { 'Random': null, 'Maj7': [0, 4, 7, 11], 'min7': [0, 3, 7, 10], 'Dom7': [0, 4, 7, 10], 'min7b5': [0, 3, 6, 10], 'dim7': [0, 3, 6, 9], 'Power': [0, 7] },
            HINTS: [ "Click a red 'L' to map a MIDI CC. Click a green 'L' to un-map it.", "Toggle 'Music Mode' for generative grooves.", "Hit 'Random' on tracks for instant variations.", "Use the 'Save' icon to create a manual save point.", "Hold +/- buttons for rapid value changes.", "The 'Stop Notes' button sends an 'All Notes Off' command to your MIDI gear.", "Use the üéº button to snap all notes to the selected scale.", "Master Volume is a global velocity scaler. It won't affect tracks whose Channel Volume is set to 0.", "'Stop Notes' is your friend if notes get stuck!" ],
            VIEW_PANEL_MAP: { showMidiPanel: 'midiPanel', showRandomizePanel: 'randomizationSettingsContainer', showVolumesPanel: 'channelVolumesWrapper', showHintsLogPanel: 'hintsPanel' },
            MUSIC_MODE_PRESETS: { off: { label: "Off", multi: false, options: { note: false, pulses: false, rotation: false, scale: false, velocity: false } }, single: { label: "Single", multi: false, options: { note: true, pulses: true, rotation: true, scale: true, velocity: true } }, multi: { label: "Multi", multi: true, options: { note: true, pulses: true, rotation: true, scale: true, velocity: true } }, melodic: { label: "Melodic", multi: true, options: { note: true, pulses: false, rotation: false, scale: true, velocity: false } }, jazz: { label: "Jazz", multi: true, options: { note: true, pulses: false, rotation: false, scale: false, velocity: true } }, rock: { label: "Rock", multi: true, options: { note: true, pulses: false, rotation: false, scale: false, velocity: true } }, baroque: { label: "Baroque", multi: true, options: { note: true, pulses: true, rotation: false, scale: true, velocity: true } }, fifths: { label: "Fifths", multi: true, options: { note: true, pulses: true, rotation: true, scale: false, velocity: true } }, },
            INTERNAL_SYNTH_NAMES: ['Piano', 'Bright Pad', '8-bit Kick', 'FM Lead', 'AM Bass', 'Saw Lead', 'Square Pluck', 'Duo Arp', 'Synth Choir', 'Metallic Perc', 'Wobble Bass', 'Glassy Bell', 'Soft Pad', 'Funky Clav', 'Distorted Lead', 'Sub Bass'],

            // --- APPLICATION STATE & CACHE ---
            dom: {},
            state: {},
            internalSynths: [],
            transportLoops: [],
            timedRandomEvent: null,
            statusTimeout: null,
            autosaveTimeout: null,
            hintInterval: null,
            activeTrackNotes: {},
            midiAccess: null,
            midiOutput: null,
            currentLearningControl: null,
            noteLearningTrack: null,
            currentRandomizationScale: [],
            baroqueProgression: [0, 7, 9, 5],
            baroqueStep: 0,
            autoRepeatTimeoutId: null,
            autoRepeatIntervalId: null,

            // --- INITIALIZATION ---
            async init() {
                try {
                    console.log("Rhythm King 77 Initializing...");
                    this.setupDOMCache();

                    let loadedState = null;
                    try {
                        const autoSaveJSON = localStorage.getItem(this.AUTOSAVE_KEY);
                        if (autoSaveJSON) {
                            loadedState = JSON.parse(autoSaveJSON);
                        }
                    } catch (e) {
                        console.error("Could not parse autosave, starting fresh.", e);
                        localStorage.removeItem(this.AUTOSAVE_KEY);
                    }

                    await this.loadState(loadedState);

                    this.createInitialUI();
                    await this.setupMIDI();
                    this.setupToneJS();
                    this.setupEventListeners();

                    if (loadedState) {
                        this.showStatusMessage("Autosave loaded.", 2000);
                    }

                    this.hintInterval = setInterval(() => this.showHint(), 25000);
                    this.showHint();
                    console.log("Initialization complete.");
                } catch (error) {
                    document.body.innerHTML = `<div class="text-white text-center p-8"><h1>A critical error occurred on startup.</h1><p>Please clear your browser cache/storage for this page and try again. See the console for details.</p></div>`;
                    console.error("CRITICAL STARTUP ERROR:", error);
                }
            },

            setupDOMCache() {
                const ids = [
                    'playStopButton', 'masterRandomizeButton', 'saveStateButton', 'loadStateButton', 'refineButton', 'quantizeNotesButton',
                    'reInitMidiButton', 'allNotesOffButton', 'numTracksInput', 'lockStepsCheckbox',
                    'bpmSlider', 'bpmValue', 'bpmSliderLearnCc', 'masterVolumeSlider',
                    'masterVolumeValue', 'masterVolumeLearnCc', 'midiOutSelect', 'midiChannelSelect',
                    'sequencerTracksContainer', 'channelVolumesContainer', 'channelVolumesWrapper',
                    'statusBar', 'statusBar-content', 'musicModeToggle', 'randomIntervalSlider',
                    'randomIntervalValue', 'randomizeNoteCheck', 'randomizePulsesCheck', 'randomizeChordCheck',
                    'randomizeRotationCheck', 'randomizeScaleCheck', 'randomizeVelocityCheck', 'randomizeOctaveCheck',
                    'musicModeNextButton', 'musicModeLog', 'hintContent', 'app-background',
                    'octaveSelector', 'viewTogglesContainer', 'randomizationSettingsContainer',
                    'musicModePanel', 'logSection', 'midiPanel', 'hintsPanel', 'viewPanel',
                    'appContainer', 'randomizeOptionsContainer', 'musicModePresetContainer', 'musicModeRefineCheck', 'musicModeQuantizeCheck',
                    'sequencerWrapperPanel', 'hintContainer', 'showRandomizePanel', 'showHintsLogPanel',
                    'scaleRootSelect', 'scaleTypeSelect', 'chordTypeSelect'
                ];
                ids.forEach(id => {
                    try {
                        const camelCaseId = id.replace(/-([a-z])/g, g => g[1].toUpperCase());
                        this.dom[camelCaseId] = document.getElementById(id);
                    } catch (e) {
                        console.error(`Error caching DOM element #${id}:`, e);
                    }
                });
            },

            setupEventListeners() {
                this.dom.playStopButton.addEventListener('click', () => this.handlePlayStop());
                this.dom.numTracksInput.addEventListener('change', (e) => this.handleNumTracksChange(e));

                this.dom.bpmSlider.addEventListener('input', e => this.updateState({ bpm: parseInt(e.target.value, 10) }));
                this.dom.masterVolumeSlider.addEventListener('input', e => this.updateState({ masterVolume: parseInt(e.target.value, 10) }));

                this.dom.saveStateButton.addEventListener('click', () => this.manualSaveState());
                this.dom.loadStateButton.addEventListener('click', () => this.loadManualState());
                this.dom.refineButton.addEventListener('click', () => this.handleRefine(true));
                this.dom.quantizeNotesButton.addEventListener('click', () => this.handleQuantizeNotes(true));

                this.dom.reInitMidiButton.addEventListener('click', async () => {
                    await Tone.Transport.stop();
                    this.panic();
                    await this.setupMIDI();
                    this.showStatusMessage("MIDI re-initialized.", 2000);
                });
                this.dom.allNotesOffButton.addEventListener('click', () => {
                    this.panic();
                    this.showStatusMessage("Stop Notes: All notes off sent.", 1500);
                });
                this.dom.midiOutSelect.addEventListener('change', () => this.updateMidiOutput());
                this.dom.midiChannelSelect.addEventListener('change', e => this.updateState({ globalMidiChannel: parseInt(e.target.value, 10) }));

                this.dom.lockStepsCheckbox.addEventListener('change', (e) => this.handleLockStepsChange(e));

                this.dom.scaleRootSelect.addEventListener('change', () => this.handleScaleChange());
                this.dom.scaleTypeSelect.addEventListener('change', () => this.handleScaleChange());
                this.dom.chordTypeSelect.addEventListener('change', e => this.updateState({ musicMode: { ...this.state.musicMode, chordType: e.target.value } }));
                this.dom.randomizeChordCheck.addEventListener('change', e => this.updateState({ musicMode: { ...this.state.musicMode, randomizeChord: e.target.checked } }));

                this.dom.viewTogglesContainer.addEventListener('change', (e) => this.handleViewToggle(e));

                this.dom.musicModeNextButton.addEventListener('click', () => this.triggerGenerativeStep());
                this.dom.masterRandomizeButton.addEventListener('click', () => this.handleMasterRandomize());

                this.dom.randomIntervalSlider.addEventListener('input', e => this.updateState({ musicMode: {...this.state.musicMode, interval: parseInt(e.target.value, 10) }}));

                this.dom.musicModeRefineCheck.addEventListener('change', e => this.updateState({ musicMode: { ...this.state.musicMode, refine: e.target.checked } }));
                this.dom.musicModeQuantizeCheck.addEventListener('change', e => this.updateState({ musicMode: { ...this.state.musicMode, autoQuantize: e.target.checked } }));

                this.dom.sequencerTracksContainer.addEventListener('click', (e) => this.handleTrackAction(e));
                this.dom.sequencerTracksContainer.addEventListener('input', (e) => this.handleTrackAction(e));
                this.dom.sequencerTracksContainer.addEventListener('change', (e) => this.handleTrackAction(e));

                document.body.addEventListener('click', (e) => this.handleBodyClick(e), true);

                document.body.addEventListener('mousedown', (e) => this.startAutoRepeat(e));
                document.body.addEventListener('mouseup', () => this.stopAutoRepeat());
                document.body.addEventListener('mouseleave', () => this.stopAutoRepeat());
                document.body.addEventListener('touchstart', (e) => this.startAutoRepeat(e), { passive: false });
                document.body.addEventListener('touchend', () => this.stopAutoRepeat());

                this.dom.randomizeOptionsContainer.addEventListener('change', (e) => this.handleRandomizeOptionChange(e));

                this.dom.musicModePresetContainer.addEventListener('click', (e) => {
                    const label = e.target.closest('.radio-label');
                    if (!label) return;
                    const radio = label.querySelector('input');
                    if (radio && radio.name === 'musicModePreset') {
                        this.updateState({ musicMode: { ...this.state.musicMode, preset: radio.value }});
                    }
                });
            },

            // --- STATE MANAGEMENT ---
            getDefaultState() {
                return {
                    numTracks: 4, bpm: 45, masterVolume: 100, globalMidiChannel: 1, midiOutputId: 'internal_synth', ccMap: {},
                    stepsLocked: false, globalLockedSteps: 16, channelVolumes: Array(16).fill(100), currentScaleName: 'C Major',
                    musicMode: { enabled: false, interval: 4, preset: 'single', refine: false, autoQuantize: false, chordType: 'Random', randomizeChord: true },
                    randomization: { note: true, pulses: true, rotation: true, scale: true, velocity: true, octave: 3, randomizeOctave: false, },
                    view: { showMidiPanel: true, showRandomizePanel: true, showVolumesPanel: true, showHintsLogPanel: true },
                    tracks: Array.from({ length: 4 }, (_, i) => ({ id: i, active: true, pulses: [4, 3, 5, 7][i] || 4, steps: 16, rotation: [0, 2, 4, 0][i] || 0, note: [60, 64, 67, 71][i] || 60, velocity: 100, channelOverride: 'global' }))
                };
            },

            updateState(newState) {
                try {
                    const prevState = { ...this.state };
                    const updatedState = this.deepMerge(this.state, newState);

                    if (!prevState.tracks || JSON.stringify(updatedState.tracks) !== JSON.stringify(prevState.tracks)) {
                        updatedState.tracks.forEach(track => {
                            track.pattern = this.generateEuclideanPattern(track.pulses, track.steps);
                            track.currentStep = 0;
                        });
                    }

                    this.state = this.validateAndSanitizeState(updatedState);

                    this.syncAppWithState(this.state, prevState);
                    this.render();
                    this.requestAutoSave();
                } catch (error) {
                    console.error("Critical error during state update.", error);
                }
            },

            syncAppWithState(newState, prevState) {
                try {
                    if (!prevState || newState.bpm !== prevState.bpm) Tone.Transport.bpm.value = newState.bpm;
                    if (!prevState || JSON.stringify(newState.musicMode) !== JSON.stringify(prevState.musicMode)) this.setupTimedRandomization();
                    if (!prevState || JSON.stringify(newState.tracks) !== JSON.stringify(prevState.tracks) || newState.globalMidiChannel !== prevState.globalMidiChannel) this.rebuildAllTrackLoops();
                } catch (error) {
                    console.error("Error during app sync:", error);
                }
            },

            updateTrackState(trackId, newTrackState) {
                const newTracks = this.state.tracks.map(t => t.id === trackId ? this.deepMerge(t, newTrackState) : t);
                this.updateState({ tracks: newTracks });
            },

            requestAutoSave() {
                if (this.autosaveTimeout) clearTimeout(this.autosaveTimeout);
                this.autosaveTimeout = setTimeout(() => {
                    try {
                        localStorage.setItem(this.AUTOSAVE_KEY, JSON.stringify(this.state));
                    } catch (e) {
                        console.error("Autosave failed:", e);
                    }
                }, 500);
            },

            manualSaveState() {
                try {
                    localStorage.setItem(this.MANUAL_SAVE_KEY, JSON.stringify(this.state));
                    this.showStatusMessage("Manual save successful!", 2000);
                } catch (e) {
                    console.error("Manual save failed:", e);
                    this.showStatusMessage("Manual save failed.", 5000);
                }
            },

            async loadState(stateToLoad) {
                try {
                    const wasPlaying = Tone.Transport.state === 'started';
                    if (wasPlaying) {
                        await Tone.Transport.stop();
                        this.panic();
                    }

                    const defaultState = this.getDefaultState();
                    const mergedState = this.deepMerge(defaultState, stateToLoad || {});
                    this.state = this.validateAndSanitizeState(mergedState);

                    this.state.tracks.forEach(track => {
                        track.pattern = this.generateEuclideanPattern(track.pulses, track.steps);
                        track.currentStep = 0;
                    });

                    Tone.Transport.bpm.value = this.state.bpm;
                    this.setupTimedRandomization();

                    if (this.midiOutput || this.state.midiOutputId === 'internal_synth') {
                        this.state.channelVolumes.forEach((volume, i) => this.sendMidiCC(7, volume, i + 1));
                    }

                    this.render();

                    if (this.state.midiOutputId && Array.from(this.dom.midiOutSelect.options).some(o => o.value === this.state.midiOutputId)) {
                        this.dom.midiOutSelect.value = this.state.midiOutputId;
                        this.updateMidiOutput();
                    }

                    if (wasPlaying) {
                        this.rebuildAllTrackLoops();
                        await Tone.Transport.start();
                    }
                } catch (error) {
                    console.error("Failed to load state. Resetting to default.", error);
                    this.showStatusMessage("Error loading state. Resetting.", 5000);
                    await this.loadState(this.getDefaultState());
                }
            },

            async loadManualState() {
                const savedStateJSON = localStorage.getItem(this.MANUAL_SAVE_KEY);
                if (!savedStateJSON) {
                    this.showStatusMessage("No manual save found.");
                    return;
                }
                try {
                    await this.loadState(JSON.parse(savedStateJSON));
                    this.showStatusMessage("Manual save loaded successfully!", 2000);
                } catch (e) {
                    this.showStatusMessage("Error loading manual save.", 5000);
                    console.error("Failed to parse manual save:", e);
                    localStorage.removeItem(this.MANUAL_SAVE_KEY);
                }
            },

            validateAndSanitizeState(s) {
                try {
                    const defaultState = this.getDefaultState();
                    let sanitizedState = this.deepMerge(defaultState, s);
                    sanitizedState.numTracks = Math.max(1, Math.min(this.MAX_TRACKS, parseInt(s.numTracks) || 4));
                    sanitizedState.bpm = Math.max(20, Math.min(240, parseInt(s.bpm) || 120));
                    sanitizedState.masterVolume = Math.max(0, Math.min(127, parseInt(s.masterVolume) || 100));
                    if (!s.currentScaleName || !Object.keys(this.SCALES).includes(s.currentScaleName.split(' ').slice(1).join(' '))) {
                        sanitizedState.currentScaleName = 'C Major';
                    }
                    if (!Array.isArray(sanitizedState.tracks)) sanitizedState.tracks = defaultState.tracks;
                    sanitizedState.tracks = sanitizedState.tracks.slice(0, sanitizedState.numTracks);
                    while(sanitizedState.tracks.length < sanitizedState.numTracks) sanitizedState.tracks.push(defaultState.tracks[0]);
                    sanitizedState.tracks.forEach((track, index) => {
                        let t = { ...defaultState.tracks[0], ...track };
                        t.id = index;
                        t.steps = Math.max(1, Math.min(32, parseInt(t.steps) || 16));
                        t.pulses = Math.max(0, Math.min(t.steps, parseInt(t.pulses) || 4));
                        t.rotation = Math.max(0, Math.min(t.steps > 0 ? t.steps - 1 : 0, parseInt(t.rotation) || 0));
                        t.note = Math.max(0, Math.min(127, parseInt(t.note) || 60));
                        t.velocity = Math.max(0, Math.min(127, parseInt(t.velocity) || 100));
                        sanitizedState.tracks[index] = t;
                    });
                    return sanitizedState;
                } catch (error) {
                    console.error("Error during state sanitization. Returning default state.", error);
                    return this.getDefaultState();
                }
            },

            // --- CORE LOGIC ---
            async setupMIDI() {
                try {
                    if (!navigator.requestMIDIAccess) {
                        this.showStatusMessage('Web MIDI not supported in this browser.', 5000);
                        this.populateMidiDeviceList();
                        return;
                    }
                    if (this.midiAccess) {
                        this.midiAccess.inputs.forEach(i => i.onmidimessage = null);
                        this.midiAccess.removeEventListener('statechange', () => this.populateMidiDeviceList());
                    }
                    this.midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                    this.populateMidiDeviceList();
                    this.midiAccess.addEventListener('statechange', () => this.populateMidiDeviceList());
                    this.midiAccess.inputs.forEach(i => i.onmidimessage = (e) => this.handleMidiMessage(e));
                } catch (err) {
                    this.showStatusMessage('MIDI has been disabled by a Permissions Policy.', 5000);
                    this.populateMidiDeviceList(); // Still populate with internal synth
                    console.error("MIDI setup error:", err);
                }
            },

            handleMidiMessage(event) {
                try {
                    const [cmd, param1, param2] = event.data;
                    if (!cmd) return;
                    const channel = (cmd & 0x0F) + 1;
                    const command = cmd & 0xF0;
                    if (command === 0x90 && param2 > 0 && this.noteLearningTrack) {
                        const trackId = this.noteLearningTrack.trackId;
                        this.updateTrackState(trackId, { note: param1, channelOverride: channel });
                        this.showStatusMessage(`Track ${trackId + 1} set to Note: ${Tone.Frequency(param1, "midi").toNote()} on Ch: ${channel}.`);
                        this.cancelAllLearnModes(false);
                        return;
                    }
                    if (command === 0xB0) {
                        if (this.currentLearningControl) {
                            const { paramId } = this.currentLearningControl;
                            const newCcMap = { ...this.state.ccMap, [paramId]: { cc: param1, channel: channel } };
                            this.showStatusMessage(`${this.getReadableParamId(paramId)} mapped to CC#${param1} on Ch ${channel}.`);
                            this.cancelAllLearnModes(false);
                            this.updateState({ccMap: newCcMap});
                        } else {
                            Object.entries(this.state.ccMap).forEach(([paramId, map]) => {
                                if (map.cc === param1 && map.channel === channel) {
                                    const el = this.dom[paramId.replace(/-([a-z])/g, g => g[1].toUpperCase())] || document.getElementById(paramId);
                                    if (!el) return;
                                    const min = parseFloat(el.min ?? 0);
                                    const max = parseFloat(el.max ?? 127);
                                    const step = parseFloat(el.step ?? 1);
                                    const newValue = Math.round((min + (((max - min) * param2) / 127)) / step) * step;
                                    el.value = newValue;
                                    el.dispatchEvent(new Event('input', { bubbles: true }));
                                }
                            });
                        }
                    }
                } catch(error) {
                    console.error("Error processing MIDI message:", error, event.data);
                }
            },

            populateMidiDeviceList() {
                try {
                    const selectedId = this.state?.midiOutputId || 'internal_synth';
                    this.dom.midiOutSelect.innerHTML = '';

                    // Add the internal synth as the first option
                    this.dom.midiOutSelect.add(new Option("Internal Synth", "internal_synth"));

                    if (!this.midiAccess || this.midiAccess.outputs.size === 0) {
                        if(!this.midiAccess) console.log("No MIDI access, only internal synth available.");
                    } else {
                        this.midiAccess.outputs.forEach(out => {
                            this.dom.midiOutSelect.add(new Option(out.name, out.id));
                        });
                    }

                    this.dom.midiOutSelect.value = selectedId;
                    this.updateMidiOutput();

                } catch (error) {
                    console.error("Error populating MIDI device list:", error);
                }
            },

            updateMidiOutput() {
                try {
                    const selectedId = this.dom.midiOutSelect.value;
                    if (selectedId === 'internal_synth') {
                        this.midiOutput = null; // Ensure external MIDI is cleared
                    } else {
                        this.midiOutput = this.midiAccess?.outputs.get(selectedId) || null;
                    }
                    if(!this.state || this.state.midiOutputId !== selectedId) {
                        this.updateState({ midiOutputId: selectedId });
                    }
                } catch (error) {
                    console.error("Error updating MIDI output:", error);
                }
            },

            sendMidi(command) {
                if (this.midiOutput?.send) {
                    try { this.midiOutput.send(command); } catch(error) { console.error("Failed to send MIDI message:", command, error); }
                }
            },
            sendMidiNoteOn(note, vel, ch) { this.sendMidi([0x90 + (ch - 1), note, vel]); },
            sendMidiNoteOff(note, ch) { this.sendMidi([0x80 + (ch - 1), note, 0]); },
            sendMidiCC(cc, value, channel) { this.sendMidi([0xB0 + (channel - 1), cc, value]); },

            clearActiveNotes() {
                Object.values(this.activeTrackNotes).forEach(noteInfo => {
                    if (noteInfo) this.sendMidiNoteOff(noteInfo.note, noteInfo.channel);
                });
                this.activeTrackNotes = {};
            },

            panic() {
                this.clearActiveNotes();
                for (let i = 1; i <= 16; i++) {
                    this.sendMidiCC(123, 0, i); // All notes off
                    this.sendMidiCC(120, 0, i); // All sound off
                }
                this.internalSynths.forEach(synth => {
                    if(synth && typeof synth.releaseAll === 'function'){
                        synth.releaseAll();
                    }
                });
            },

            showStatusMessage(message, duration = 3000) {
                if (this.statusTimeout) clearTimeout(this.statusTimeout);
                this.dom.statusBarContent.textContent = message;
                this.dom.statusBar.classList.add('visible');
                this.statusTimeout = setTimeout(() => this.dom.statusBar.classList.remove('visible'), duration);
            },

            showHint() {
                this.dom.hintContent.textContent = this.HINTS[Math.floor(Math.random() * this.HINTS.length)];
            },

            deepMerge(target, source) {
                const output = { ...target };
                if (this.isObject(target) && this.isObject(source)) {
                    Object.keys(source).forEach(key => {
                        if (this.isObject(source[key]) && key in target && this.isObject(target[key]) && !Array.isArray(target[key])) {
                            output[key] = this.deepMerge(target[key], source[key]);
                        } else {
                            output[key] = source[key];
                        }
                    });
                }
                return output;
            },

            isObject(item) {
                return (item && typeof item === 'object' && !Array.isArray(item));
            },

            getReadableParamId(paramId) {
                let readable = paramId.replace(/([A-Z])/g, ' $1');
                let trackMatch = readable.match(/^(steps|pulses|rotation|velocity)\s?(\d+)$/i);
                if (trackMatch) return `${trackMatch[1].charAt(0).toUpperCase() + trackMatch[1].slice(1)} Track ${parseInt(trackMatch[2]) + 1}`;
                let channelMatch = readable.match(/^channel\s?Volume\s?(\d+)$/i);
                if (channelMatch) return `Channel ${channelMatch[1]} Volume`;
                return readable.replace(/^./, str => str.toUpperCase()).trim();
            },

            getNoteColor(note, minNote, maxNote) {
                const range = Math.max(1, maxNote - minNote);
                const normalized = (note - minNote) / range;
                const hue = 240 - (normalized * 240);
                return { color: `hsl(${hue}, 90%, 65%)`, glow: `hsla(${hue}, 90%, 65%, 0.7)` };
            },

            findClosestNoteInScale(midiNote, scale) {
                if (!scale || scale.length === 0) return midiNote;
                return scale.reduce((prev, curr) => (Math.abs(curr - midiNote) < Math.abs(prev - midiNote) ? curr : prev));
            },

            regenerateScaleFromName() {
                if (!this.state.currentScaleName) return;
                const parts = this.state.currentScaleName.split(' ');
                const rootNoteName = parts[0];
                const scaleName = parts.slice(1).join(' ');
                const rootNoteMidi = this.NOTE_NAMES.indexOf(rootNoteName);
                const scaleIntervals = this.SCALES[scaleName];
                if (rootNoteMidi === -1 || !scaleIntervals) {
                    this.currentRandomizationScale = [];
                    return;
                }
                this.currentRandomizationScale = [];
                for (let octave = 0; octave < 9; octave++) {
                    for (const interval of scaleIntervals) {
                        const midiNote = 12 * octave + rootNoteMidi + interval;
                        if (midiNote >= 0 && midiNote <= 127) {
                            this.currentRandomizationScale.push(midiNote);
                        }
                    }
                }
            },

            generateEuclideanPattern(pulses, steps) {
                if (pulses > steps || pulses < 0 || steps <= 0 || isNaN(pulses) || isNaN(steps)) return [];
                if (pulses === 0) return Array(steps).fill(0);
                try {
                    let pattern = [], counts = [], remainders = [], divisor = steps - pulses;
                    remainders.push(pulses);
                    let level = 0;
                    while (true) {
                        counts.push(Math.floor(divisor / remainders[level]));
                        remainders.push(divisor % remainders[level]);
                        divisor = remainders[level];
                        level += 1;
                        if (remainders[level] <= 1) break;
                    }
                    counts.push(divisor);
                    function build(level) {
                        if (level === -1) pattern.push(0);
                        else if (level === -2) pattern.push(1);
                        else {
                            for (let i = 0; i < counts[level]; i++) build(level - 1);
                            if (remainders[level] !== 0) build(level - 2);
                        }
                    }
                    build(level);
                    return pattern.reverse();
                } catch(e) {
                    console.error(`Error generating Euclidean pattern for p=${pulses}, s=${steps}`, e);
                    return Array(steps || 0).fill(0);
                }
            },

            rotatePattern(pattern, rotation) {
                const len = pattern.length;
                if (len === 0) return [];
                const r = ((rotation % len) + len) % len;
                return [...pattern.slice(r), ...pattern.slice(0, r)];
            },

            render() {
                try {
                    if (!this.state || !this.dom.numTracksInput) return;
                    this.regenerateScaleFromName();
                    this.dom.numTracksInput.value = this.state.numTracks;
                    this.dom.bpmSlider.value = this.state.bpm;
                    this.dom.bpmValue.textContent = this.state.bpm;
                    this.dom.masterVolumeSlider.value = this.state.masterVolume;
                    this.dom.masterVolumeValue.textContent = this.state.masterVolume;
                    this.dom.lockStepsCheckbox.checked = this.state.stepsLocked;
                    this.dom.midiChannelSelect.value = this.state.globalMidiChannel;
                    this.dom.chordTypeSelect.value = this.state.musicMode.chordType;
                    this.dom.randomizeChordCheck.checked = this.state.musicMode.randomizeChord;
                    const midiAvailable = !!this.midiAccess;
                    this.dom.midiPanel.querySelectorAll('select, button').forEach(el => {
                        if (el.id !== 'reInitMidiButton' && el.id !== 'allNotesOffButton') el.disabled = !midiAvailable && el.id !== 'midiOutSelect';
                    });
                    this.dom.reInitMidiButton.disabled = false;
                    this.dom.allNotesOffButton.disabled = !(this.midiOutput || this.state.midiOutputId === 'internal_synth');
                    document.querySelectorAll('.learn-cc-button, .note-learn-button').forEach(btn => btn.disabled = !midiAvailable);
                    Object.entries(this.VIEW_PANEL_MAP).forEach(([key, panelId]) => {
                        const checkbox = this.dom[key]
                        const panel = this.dom[panelId];
                        if (checkbox && typeof this.state.view[key] !== 'undefined') checkbox.checked = this.state.view[key];
                        if(panel) panel.style.display = this.state.view[key] ? 'flex' : 'none';
                    });
                    this.dom.musicModeToggle.checked = this.state.musicMode.enabled;
                    this.dom.musicModePanel.style.display = this.state.musicMode.enabled ? 'flex' : 'none';
                    this.dom.musicModeRefineCheck.checked = this.state.musicMode.refine;
                    this.dom.musicModeQuantizeCheck.checked = this.state.musicMode.autoQuantize;
                    document.body.classList.toggle('music-mode-active', this.state.musicMode.enabled);
                    this.dom.appBackground.classList.toggle('bg-music-mode', this.state.musicMode.enabled);
                    this.dom.appBackground.classList.toggle('bg-default', !this.state.musicMode.enabled);
                    this.dom.logSection.style.display = this.state.musicMode.enabled ? 'flex' : 'none';
                    this.dom.randomIntervalSlider.value = this.state.musicMode.interval;
                    this.dom.randomIntervalValue.textContent = this.state.musicMode.interval;
                    this.renderManualRandomizationOptions();
                    this.renderMusicModePresets();
                    this.renderAllTracks();
                    this.renderChannelVolumes();
                    this.renderCcMappings();
                    this.renderOctaveSelector();
                    this.renderScaleSelector();
                } catch (error) {
                    console.error("A major error occurred during rendering:", error);
                    this.showStatusMessage("Render Error. Check console.", 5000);
                }
            },

            renderAllTracks() {
                this.dom.sequencerTracksContainer.querySelectorAll('.synth-panel[data-track-id]').forEach(panel => {
                    if (!this.state.tracks.some(t => t.id === parseInt(panel.dataset.trackId, 10))) {
                        panel.remove();
                    }
                });
                this.state.tracks.forEach(track => {
                    let panel = this.dom.sequencerTracksContainer.querySelector(`.synth-panel[data-track-id="${track.id}"]`);
                    if (!panel) {
                        panel = this.createSequencerTrackUI(track.id);
                        this.dom.sequencerTracksContainer.appendChild(panel);
                    }
                    this.renderTrack(track, panel);
                });
            },

            renderTrack(track, panel) {
                try {
                    if (!track || !panel) return;
                    const update = (prop, value, text) => {
                        const el = panel.querySelector(`#${prop}${track.id}`);
                        if (el) el.value = value;
                        const textEl = panel.querySelector(`#${prop}Value${track.id}`);
                        if(textEl) textEl.textContent = text ?? value;
                    };
                    const pulsesSlider = panel.querySelector(`#pulses${track.id}`);
                    if (pulsesSlider) pulsesSlider.max = track.steps;
                    update('steps', track.steps);
                    update('pulses', track.pulses);
                    update('rotation', track.rotation);
                    update('velocity', track.velocity);
                    panel.querySelector(`#note${track.id}`).value = Tone.Frequency(track.note, 'midi').toNote();
                    panel.querySelector(`#channelOverride${track.id}`).value = track.channelOverride;
                    const toggleButton = panel.querySelector(`#trackToggle${track.id}`);
                    toggleButton.textContent = track.active ? 'On' : 'Off';
                    toggleButton.classList.toggle('active', track.active);
                    this.renderPatternDisplay(track, panel);
                } catch(error) {
                    console.error(`Error rendering track ${track?.id}:`, error, track);
                }
            },

            renderPatternDisplay(track, panel) {
                const display = panel.querySelector(`#patternDisplay${track.id}`);
                if (!display) return;
                display.innerHTML = '';
                const isPlaying = Tone.Transport.state === "started";
                const pattern = track.pattern || [];
                const steps = track.steps || 0;
                for (let i = 0; i < steps; i++) {
                    const stepDot = document.createElement('div');
                    stepDot.className = 'pattern-step';
                    if (pattern[i] === 1) stepDot.classList.add('active');
                    if (isPlaying && track.active && i === track.currentStep) {
                        stepDot.classList.add('current');
                    }
                    display.appendChild(stepDot);
                }
            },

            renderScaleSelector() {
                if (!this.state || !this.state.currentScaleName) return;
                const parts = this.state.currentScaleName.split(' ');
                const root = parts[0];
                const type = parts.slice(1).join(' ');
                if (this.dom.scaleRootSelect.value !== root) this.dom.scaleRootSelect.value = root;
                if (this.dom.scaleTypeSelect.value !== type) this.dom.scaleTypeSelect.value = type;
            },

            renderChannelVolumes() {
                if (!this.state || !this.state.channelVolumes) return;
                for(let i=1; i<=16; i++) {
                    const slider = document.getElementById(`channelVolume${i}`);
                    const valueDisplay = document.getElementById(`channelVolumeValue${i}`);
                    const label = document.querySelector(`label[for="channelVolume${i}"]`);

                    if (slider && valueDisplay && label) {
                        const volume = this.state.channelVolumes[i - 1];
                        slider.value = volume;
                        valueDisplay.textContent = volume;
                        label.textContent = `Ch ${i} (${this.INTERNAL_SYNTH_NAMES[i-1]})`
                    }
                }
            },

            renderCcMappings() {
                document.querySelectorAll('.learn-cc-button').forEach(btn => {
                    const paramId = btn.dataset.paramId;
                    btn.classList.remove('learning', 'mapped');
                    if (this.currentLearningControl?.paramId === paramId) {
                        btn.classList.add('learning');
                        btn.textContent = '...';
                    } else {
                        btn.textContent = 'L';
                        if (this.state.ccMap && this.state.ccMap[paramId]) {
                            btn.classList.add('mapped');
                            const { cc, channel } = this.state.ccMap[paramId];
                            btn.title = `Mapped to CC #${cc} on Ch ${channel}. Click to unmap.`;
                        } else {
                            btn.title = `Map ${this.getReadableParamId(paramId)} to a MIDI CC knob/fader`;
                        }
                    }
                });
            },

            renderOctaveSelector() {
                if (!this.state || !this.state.randomization) return;
                this.dom.octaveSelector.querySelectorAll('.radio-label').forEach(label => {
                    const radio = label.querySelector('input');
                    radio.checked = parseInt(radio.value, 10) === this.state.randomization.octave;
                    label.classList.toggle('selected', radio.checked);
                });
            },

            renderMusicModePresets() {
                if (!this.state || !this.state.musicMode) return;
                this.dom.musicModePresetContainer.querySelectorAll('.radio-label').forEach(label => {
                    const radio = label.querySelector('input');
                    radio.checked = radio.value === this.state.musicMode.preset;
                    label.classList.toggle('selected', radio.checked);
                });
            },

            renderManualRandomizationOptions(){
                if (!this.state || !this.state.randomization) return;
                this.dom.randomizeNoteCheck.checked = this.state.randomization.note;
                this.dom.randomizePulsesCheck.checked = this.state.randomization.pulses;
                this.dom.randomizeRotationCheck.checked = this.state.randomization.rotation;
                this.dom.randomizeScaleCheck.checked = this.state.randomization.scale;
                this.dom.randomizeVelocityCheck.checked = this.state.randomization.velocity;
                this.dom.randomizeOctaveCheck.checked = this.state.randomization.randomizeOctave;
            },

            createInitialUI() {
                for (let i = 1; i <= 16; i++) {
                    this.dom.midiChannelSelect.add(new Option(`Ch ${i}`, i));
                    const volDiv = document.createElement('div');
                    volDiv.className = 'control-group';
                    volDiv.innerHTML = `<div class="control-header"><label for="channelVolume${i}"></label><span id="channelVolumeValue${i}" class="value-display"></span><button class="learn-cc-button ml-1" data-param-id="channelVolume${i}" title="Map Ch ${i} Volume to a MIDI CC knob/fader">L</button></div><div class="control-slider-container"><input type="range" id="channelVolume${i}" min="0" max="127" value="100" class="control-slider" title="Adjust volume for MIDI Channel ${i}"></div>`;
                    this.dom.channelVolumesContainer.appendChild(volDiv);
                    volDiv.querySelector('input').addEventListener('input', e => {
                        const newVolume = parseInt(e.target.value, 10);
                        const newVolumes = [...this.state.channelVolumes];
                        newVolumes[i-1] = newVolume;
                        if (this.state.midiOutputId === 'internal_synth') {
                            const scaledVol = -24 + (24 * (newVolume / 127));
                            this.internalSynths[i-1].volume.value = scaledVol;
                        }
                        this.updateState({ channelVolumes: newVolumes });
                    });
                }
                this.NOTE_NAMES.forEach(note => this.dom.scaleRootSelect.add(new Option(note, note)));
                Object.keys(this.SCALES).forEach(scaleName => this.dom.scaleTypeSelect.add(new Option(scaleName, scaleName)));
                Object.keys(this.CHORD_TYPES).forEach(chordName => this.dom.chordTypeSelect.add(new Option(chordName, chordName)));
                for (let i = 0; i <= 9; i++) {
                    const label = document.createElement('label');
                    label.className = 'radio-label';
                    label.innerHTML = `<input type="radio" name="octaveSelect" value="${i}"><span>${i}</span>`;
                    label.title = `Set base octave for randomization to ${i}`;
                    this.dom.octaveSelector.appendChild(label);
                }
                this.dom.musicModePresetContainer.innerHTML = '';
                const presetTooltips = { off: "Music Mode does nothing.", single: "Changes one parameter on one random track.", multi: "Changes all enabled parameters on all active tracks.", melodic: "Changes notes and scale, but keeps rhythm the same.", jazz: "Generates diatonic 7th chords from the current scale.", rock: "Generates power chords or minor chords.", baroque: "Generates arpeggiated triads based on a I-V-vi-IV progression.", fifths: "Shifts the musical key by a perfect fifth." };
                Object.entries(this.MUSIC_MODE_PRESETS).forEach(([key, preset]) => {
                    const label = document.createElement('label');
                    label.className = 'radio-label';
                    label.innerHTML = `<input type="radio" name="musicModePreset" value="${key}"><span>${preset.label}</span>`;
                    label.title = presetTooltips[key];
                    this.dom.musicModePresetContainer.appendChild(label);
                });
            },

            createSequencerTrackUI(trackId) {
                const trackDiv = document.createElement('div');
                trackDiv.className = 'synth-panel p-2 flex flex-col relative';
                trackDiv.dataset.trackId = trackId;
                trackDiv.innerHTML = `
                <div class="flex justify-between items-center mb-1">
                    <h3 class="text-base font-semibold" style="font-family: 'Orbitron', sans-serif;">Track ${trackId + 1}</h3>
                    <div>
                        <button data-action="randomize" class="push-button randomize-button text-xs py-1 px-2" title="Randomize this track's parameters">Random</button>
                        <button data-action="toggleActive" id="trackToggle${trackId}" class="push-button text-xs py-1 px-2 ml-1" title="Mute or unmute this track">On</button>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-x-2 gap-y-1 mb-1">
                    ${this.createSliderControl('steps', trackId, 'Steps', 1, 32, 16)}
                    ${this.createSliderControl('pulses', trackId, 'Pulses', 1, 16, 4)}
                    ${this.createSliderControl('rotation', trackId, 'Rotate', 0, 15, 0)}
                    ${this.createSliderControl('velocity', trackId, 'Velocity', 1, 127, 100)}
                    ${this.createSelectControl('channelOverride', trackId, 'MIDI Ch', ['global', ...Array.from({length:16},(_,i)=>i+1)])}
                    ${this.createNoteControl(trackId)}
                </div>
                <div id="patternDisplay${trackId}" class="pattern-display my-1"></div>
            `;
                return trackDiv;
            },

            createSliderControl(id, trackId, label, min, max, value) {
                return `
                <div class="control-group">
                    <div class="control-header">
                        <label for="${id}${trackId}">${label}:</label>
                        <span id="${id}Value${trackId}" class="value-display">${value}</span>
                        <button class="learn-cc-button ml-1" data-param-id="${id}${trackId}">L</button>
                    </div>
                    <div class="control-slider-container">
                        <button class="slider-button" data-target="${id}${trackId}" data-action="decrement">&minus;</button>
                        <input type="range" data-action="update" data-prop="${id}" id="${id}${trackId}" min="${min}" max="${max}" value="${value}" class="control-slider">
                        <button class="slider-button" data-target="${id}${trackId}" data-action="increment">+</button>
                    </div>
                </div>
            `;
            },

            createSelectControl(id, trackId, label, options) {
                return `
                <div class="control-group">
                    <label for="${id}${trackId}" class="mb-1">${label}:</label>
                    <select id="${id}${trackId}" data-action="update" data-prop="${id}" class="text-xs p-1 h-full">
                        ${options.map(o => `<option value="${o}">${o === 'global' ? 'Global' : o}</option>`).join('')}
                    </select>
                </div>
            `;
            },

            createNoteControl(trackId) {
                return `
                <div class="control-group">
                    <label for="note${trackId}" class="mb-1">Note:</label>
                    <div class="note-input-group">
                        <input type="text" data-action="update" data-prop="note" id="note${trackId}" class="text-xs p-1">
                        <button data-action="learnNote" id="noteLearn${trackId}" class="note-learn-button">L</button>
                    </div>
                </div>
            `;
            },

            handleViewToggle(e) {
                if(e.target.id === 'musicModeToggle') {
                    if(e.target.checked) this.dom.musicModeLog.innerHTML = '';
                    this.updateState({ musicMode: { ...this.state.musicMode, enabled: e.target.checked } });
                } else if (e.target.dataset.viewToggle) {
                    const viewKey = e.target.id;
                    this.updateState({ view: { ...this.state.view, [viewKey]: e.target.checked } });
                }
            },

            startAutoRepeat(e) {
                const btn = e.target.closest('.slider-button, .number-input-button');
                if (!btn) return;
                if (e.type === 'touchstart') e.preventDefault();
                const targetId = btn.dataset.target;
                const action = btn.dataset.action;
                this.stopAutoRepeat();
                this.adjustControlValue(targetId, action);
                this.autoRepeatTimeoutId = setTimeout(() => {
                    this.autoRepeatIntervalId = setInterval(() => this.adjustControlValue(targetId, action), 100);
                }, 500);
            },

            stopAutoRepeat() {
                clearTimeout(this.autoRepeatTimeoutId);
                clearInterval(this.autoRepeatIntervalId);
            },

            adjustControlValue(targetId, action) {
                const el = document.getElementById(targetId);
                if (!el) return;
                let val = parseFloat(el.value);
                const step = parseFloat(el.step) || 1;
                const min = parseFloat(el.min);
                const max = parseFloat(el.max);
                el.value = Math.max(min, Math.min(max, val + (action === 'increment' ? step : -step)));
                el.dispatchEvent(new Event(el.id === 'numTracksInput' ? 'change' : 'input', { bubbles: true }));
            },

            handleScaleChange() {
                const root = this.dom.scaleRootSelect.value;
                const type = this.dom.scaleTypeSelect.value;
                const newScaleName = `${root} ${type}`;
                if (this.state.currentScaleName !== newScaleName) {
                    this.logChange(`Scale changed to: ${newScaleName}`);
                    this.updateState({ currentScaleName: newScaleName });
                }
            },

            handleQuantizeNotes(showStatus = true) {
                this.regenerateScaleFromName();
                if (this.currentRandomizationScale.length === 0) {
                    if(showStatus) this.showStatusMessage("Cannot quantize: Invalid scale selected.", 3000);
                    return;
                }
                const newTracks = this.state.tracks.map(track => {
                    if (track.active) {
                        return { ...track, note: this.findClosestNoteInScale(track.note, this.currentRandomizationScale) };
                    }
                    return track;
                });
                this.updateState({ tracks: newTracks });
                if(showStatus) this.showStatusMessage(`All notes quantized to ${this.state.currentScaleName}.`, 2500);
            },

            handleRandomizeOptionChange(e) {
                if(e.target.classList.contains('randomize-option')) {
                    const newRandomizationState = { ...this.state.randomization };
                    document.querySelectorAll('.randomize-option').forEach(el => {
                        let key = el.id.replace('randomize', '').replace('Check', '').toLowerCase();
                        if (el.id === 'randomizeOctaveCheck') key = 'randomizeOctave';
                        if (el.id === 'randomizeChordCheck') return;
                        newRandomizationState[key] = el.checked;
                    });
                    this.updateState({ randomization: newRandomizationState });
                }
            },

            handleTrackAction(e) {
                try {
                    const target = e.target;
                    const action = target.dataset.action;
                    const trackPanel = target.closest('.synth-panel[data-track-id]');
                    if (!action || !trackPanel) return;
                    const trackId = parseInt(trackPanel.dataset.trackId, 10);
                    const track = this.state.tracks.find(t => t.id === trackId);
                    if (!track) return;
                    switch(action) {
                        case 'randomize': this.updateState({tracks: this.randomizeTrackParameters(track, this.state.randomization, true, {}, JSON.parse(JSON.stringify(this.state.tracks)))}); break;
                        case 'toggleActive':
                            if (track.active && this.activeTrackNotes[trackId]) {
                                this.sendMidiNoteOff(this.activeTrackNotes[trackId].note, this.activeTrackNotes[trackId].channel);
                                delete this.activeTrackNotes[trackId];
                            }
                            this.updateTrackState(trackId, { active: !track.active });
                            break;
                        case 'learnNote': this.startNoteLearn(trackId, target); break;
                        case 'update': this.handleTrackUpdate(trackId, target); break;
                    }
                } catch (error) {
                    console.error("Error handling track action:", error);
                }
            },

            handleTrackUpdate(trackId, target) {
                const prop = target.dataset.prop;
                let value = target.type === 'range' || target.type === 'number' ? parseInt(target.value, 10) : target.value;
                if (prop === 'note') {
                    try {
                        const midiValue = Tone.Frequency(value.toUpperCase()).toMidi();
                        target.value = Tone.Frequency(midiValue, 'midi').toNote();
                        value = midiValue;
                    } catch {
                        this.showStatusMessage("Invalid note format. Use C3, F#4, etc.", 2000);
                        this.renderTrack(this.state.tracks.find(t=>t.id===trackId), target.closest('.synth-panel'));
                        return;
                    }
                }
                if (prop === 'steps' && this.state.stepsLocked) {
                    this.synchronizeAllTrackSteps(value);
                } else {
                    this.updateTrackState(trackId, {[prop]: value});
                }
            },

            handleBodyClick(e) {
                const isLearnButton = e.target.closest('.learn-cc-button, .note-learn-button');
                if (isLearnButton) {
                    if(e.target.classList.contains('learn-cc-button')) {
                        this.handleLearnCcClick(e.target.dataset.paramId, e.target);
                    }
                    return;
                }
                if(this.currentLearningControl || this.noteLearningTrack) {
                    this.cancelAllLearnModes(true);
                }
            },

            async handlePlayStop() {
                try {
                    if (Tone.context.state !== 'running') {
                        await Tone.start();
                        this.showStatusMessage("Audio Context Started.");
                    }
                    if (Tone.Transport.state === 'started') {
                        await Tone.Transport.stop();
                    } else {
                        this.rebuildAllTrackLoops();
                        await Tone.Transport.start();
                    }
                } catch (error) {
                    console.error("Error with Play/Stop:", error);
                }
            },

            handleNumTracksChange(e) {
                let newCount = Math.max(1, Math.min(this.MAX_TRACKS, parseInt(e.target.value, 10) || this.state.numTracks));
                if (newCount === this.state.numTracks) return;
                const currentTracks = [...this.state.tracks];
                const newTracks = [];
                for (let i = 0; i < newCount; i++) {
                    if (currentTracks[i]) {
                        newTracks.push(currentTracks[i]);
                    } else {
                        const defaultTrack = this.getDefaultState().tracks[0];
                        newTracks.push({ ...defaultTrack, id: i, steps: this.state.stepsLocked ? this.state.globalLockedSteps : 16, });
                    }
                }
                this.updateState({ numTracks: newCount, tracks: newTracks });
            },

            handleLockStepsChange(e) {
                const stepsLocked = e.target.checked;
                if(stepsLocked) {
                    const globalLockedSteps = this.state.tracks.length > 0 ? this.state.tracks[0].steps : 16;
                    this.updateState({ stepsLocked, globalLockedSteps });
                    this.synchronizeAllTrackSteps(globalLockedSteps);
                } else {
                    this.updateState({ stepsLocked });
                }
            },

            synchronizeAllTrackSteps(newSteps) {
                const newTracks = this.state.tracks.map(t => {
                    const newPulses = Math.min(t.pulses, newSteps);
                    const newRotation = Math.min(t.rotation, newSteps > 0 ? newSteps - 1 : 0);
                    return {...t, steps: newSteps, pulses: newPulses, rotation: newRotation };
                });
                this.updateState({ tracks: newTracks, globalLockedSteps: newSteps });
            },

            handleLearnCcClick(paramId, button) {
                if (this.currentLearningControl?.paramId === paramId) {
                    this.cancelAllLearnModes(true);
                    return;
                }
                if (this.state.ccMap[paramId]) {
                    const newCcMap = {...this.state.ccMap};
                    delete newCcMap[paramId];
                    this.updateState({ccMap: newCcMap});
                    this.showStatusMessage(`Mapping for ${this.getReadableParamId(paramId)} cleared.`);
                } else {
                    this.cancelAllLearnModes(false);
                    this.currentLearningControl = { paramId, button };
                    this.showStatusMessage(`Listening for MIDI CC for ${this.getReadableParamId(paramId)}...`);
                    this.renderCcMappings();
                }
            },

            startNoteLearn(trackId, button) {
                if (this.noteLearningTrack?.trackId === trackId) {
                    this.cancelAllLearnModes(true);
                    return;
                }
                this.cancelAllLearnModes(false);
                this.noteLearningTrack = { trackId, button };
                button.classList.add('learning');
                button.textContent = '...';
                this.showStatusMessage(`Listening for MIDI Note for Track ${trackId + 1}.`);
            },

            cancelAllLearnModes(notify = true) {
                if (this.currentLearningControl) {
                    if (notify) this.showStatusMessage("MIDI CC Learn cancelled.");
                    this.currentLearningControl = null;
                }
                if (this.noteLearningTrack) {
                    if (notify) this.showStatusMessage("Note Learn cancelled.");
                    this.noteLearningTrack.button.classList.remove('learning');
                    this.noteLearningTrack.button.textContent = 'L';
                    this.noteLearningTrack = null;
                }
                this.renderCcMappings();
            },

            setupToneJS() {
                // Setup the internal synths
                const synthTypes = [Tone.FMSynth, Tone.AMSynth, Tone.MonoSynth, Tone.DuoSynth];
                for(let i = 0; i < 16; i++) {
                    const synthType = synthTypes[i % synthTypes.length];
                    const synth = new synthType().toDestination();
                    // Basic effects chain
                    const dist = new Tone.Distortion(0.1).toDestination();
                    const reverb = new Tone.Reverb(0.5).toDestination();
                    synth.chain(dist, reverb);
                    this.internalSynths.push(synth);
                }

                Tone.Transport.on('start', () => {
                    this.dom.playStopButton.innerHTML = '&#x25A0;';
                    this.dom.playStopButton.classList.add('active', 'stop-state');
                    this.transportLoops.forEach(loop => loop?.start(0));
                });
                Tone.Transport.on('stop', () => {
                    this.dom.playStopButton.innerHTML = '&#x25B6;';
                    this.dom.playStopButton.classList.remove('active', 'stop-state');
                    this.panic();
                    if (this.state && this.state.tracks) {
                        this.state.tracks.forEach(t => {
                            t.currentStep = 0;
                            const panel = document.querySelector(`.synth-panel[data-track-id="${t.id}"]`);
                            if (panel) this.renderPatternDisplay(t, panel);
                        });
                    }
                    this.transportLoops.forEach(loop => loop?.stop(0));
                });
            },

            rebuildAllTrackLoops() {
                this.transportLoops.forEach(l => l?.dispose());
                this.transportLoops = [];
                if(this.state && this.state.tracks) {
                    this.state.tracks.forEach(track => {
                        this.transportLoops[track.id] = this.createTrackLoop(track);
                    });
                }

                if (Tone.Transport.state === 'started') {
                    this.transportLoops.forEach(loop => loop?.start(0));
                }
            },

            createTrackLoop(track) {
                if (!track || track.steps === 0 || !track.pattern || track.pattern.length === 0) {
                    return null;
                }
                try {
                    return new Tone.Sequence((time, value) => {
                        if (!track || !this.state) return;
                        const ch = (track.channelOverride !== 'global') ? parseInt(track.channelOverride, 10) : this.state.globalMidiChannel;
                        const isInternal = this.state.midiOutputId === 'internal_synth';

                        if (!isInternal && this.activeTrackNotes[track.id]) {
                            this.sendMidiNoteOff(this.activeTrackNotes[track.id].note, this.activeTrackNotes[track.id].channel);
                            delete this.activeTrackNotes[track.id];
                        }

                        if (track.active && value === 1) {
                            const channelVolume = this.state.channelVolumes[ch - 1] / 127.0;
                            const masterVol = this.state.masterVolume / 127.0;
                            const finalVelocity = Math.round(track.velocity * channelVolume * masterVol);

                            if (finalVelocity > 0) {
                                const noteToPlay = { note: track.note, channel: ch };
                                if(isInternal){
                                    const synth = this.internalSynths[ch-1];
                                    if(synth){
                                        const noteFrequency = Tone.Frequency(noteToPlay.note, 'midi').toFrequency();
                                        synth.triggerAttackRelease(noteFrequency, "16n", time, finalVelocity / 127);
                                    }
                                } else {
                                    this.sendMidiNoteOn(noteToPlay.note, Math.min(127, finalVelocity), noteToPlay.channel);
                                    this.activeTrackNotes[track.id] = noteToPlay;
                                }
                            }
                            Tone.Draw.schedule(() => {
                                const allNotes = this.state.tracks.filter(t => t.active).map(t => t.note);
                                const minNote = Math.min(...allNotes, Infinity);
                                const maxNote = Math.max(...allNotes, -Infinity);
                                const { color, glow } = this.getNoteColor(track.note, minNote, maxNote);
                                const panel = document.querySelector(`.synth-panel[data-track-id="${track.id}"]`);
                                if (panel) {
                                    panel.style.setProperty('--flash-color', color);
                                    panel.style.setProperty('--flash-glow', glow);
                                    panel.classList.add('track-pulse');
                                    setTimeout(() => panel.classList.remove('track-pulse'), 150);
                                }
                            }, time);
                        }
                        Tone.Draw.schedule(() => {
                            const trackToUpdate = this.state.tracks.find(t => t.id === track.id);
                            if(trackToUpdate) {
                                trackToUpdate.currentStep = (trackToUpdate.currentStep + 1) % trackToUpdate.steps;
                                const panel = document.querySelector(`.synth-panel[data-track-id="${track.id}"]`);
                                if (panel) this.renderPatternDisplay(trackToUpdate, panel);
                            }
                        }, time);
                    }, track.pattern, `${track.steps}n`);
                } catch (error) {
                    console.error(`Failed to create loop for track ${track?.id}`, error);
                    return null;
                }
            },

            setupTimedRandomization() {
                if (this.timedRandomEvent) {
                    Tone.Transport.clear(this.timedRandomEvent);
                    this.timedRandomEvent = null;
                }
                if (this.state.musicMode.enabled) {
                    const interval = `${this.state.musicMode.interval}m`;
                    this.timedRandomEvent = Tone.Transport.scheduleRepeat(time => {
                        Tone.Draw.schedule(() => this.triggerGenerativeStep(), time)
                    }, interval, "1m");
                    this.logChange(`Music Mode enabled, randomizing every ${this.state.musicMode.interval} bars.`);
                } else {
                    this.logChange("Music Mode disabled.");
                }
            },

            logChange(message, options = {}) {
                if (!this.dom.musicModeLog) return;
                if (options.separator) {
                    const separator = document.createElement('div');
                    separator.className = 'log-separator';
                    this.dom.musicModeLog.prepend(separator);
                    return;
                }
                if (this.state.musicMode && this.state.musicMode.refine && options.isGenerative) return;
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.textContent = message;
                this.dom.musicModeLog.prepend(entry);
                while (this.dom.musicModeLog.children.length > 50) {
                    this.dom.musicModeLog.removeChild(this.dom.musicModeLog.lastChild);
                }
            },

            async triggerGenerativeStep() {
                try {
                    const presetKey = this.state.musicMode.preset;
                    if(presetKey === 'off') return;

                    const preset = this.MUSIC_MODE_PRESETS[presetKey];
                    if (!preset) return;

                    const activeTracks = this.state.tracks.filter(t => t.active);
                    if (activeTracks.length === 0) return;

                    this.logChange(null, { separator: true });

                    let nextStateChanges = {};

                    const randomizerOptions = preset.options;
                    const shouldLogGenerativeStep = !this.state.musicMode.refine;

                    if(this.state.randomization.randomizeOctave) {
                        const newOctave = Math.max(2, Math.min(5, this.state.randomization.octave + (Math.floor(Math.random() * 3) - 1)));
                        if (newOctave !== this.state.randomization.octave) {
                            if (!nextStateChanges.randomization) nextStateChanges.randomization = {...this.state.randomization};
                            nextStateChanges.randomization.octave = newOctave;
                            if(shouldLogGenerativeStep) this.logChange(`New base octave: ${newOctave}`, { isGenerative: true });
                        }
                    }

                    if (randomizerOptions.scale) {
                        const scaleNames = Object.keys(this.SCALES);
                        const randomScaleName = scaleNames[Math.floor(Math.random() * scaleNames.length)];
                        const randomRootNote = Math.floor(Math.random() * 12);
                        nextStateChanges.currentScaleName = `${this.NOTE_NAMES[randomRootNote]} ${randomScaleName}`;
                        if(shouldLogGenerativeStep) this.logChange(`Scale: ${nextStateChanges.currentScaleName}`, { isGenerative: true });
                    }

                    if (Object.keys(nextStateChanges).length > 0) {
                        this.updateState(nextStateChanges);
                        // Give the state a moment to update before proceeding
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }

                    let newTracks = JSON.parse(JSON.stringify(this.state.tracks));
                    const assignedNotesByChannel = {};

                    if (presetKey === 'jazz' || presetKey === 'rock') {
                        this.handleChordalMode(presetKey, newTracks);
                    }
                    else if (preset.multi) {
                        newTracks.forEach(t => {
                            if(t.active) this.randomizeTrackParameters(t, randomizerOptions, true, assignedNotesByChannel, newTracks);
                        });
                    } else if (preset.options.note || preset.options.pulses || preset.options.rotation || preset.options.velocity) {
                        const trackToRandomize = activeTracks[Math.floor(Math.random() * activeTracks.length)];
                        if (trackToRandomize) {
                            this.randomizeTrackParameters(trackToRandomize, randomizerOptions, true, assignedNotesByChannel, newTracks);
                        }
                    }
                    this.updateState({tracks: newTracks});

                    if (this.state.musicMode.refine) {
                        setTimeout(() => this.handleRefine(false), 50);
                    }
                    if (this.state.musicMode.autoQuantize) {
                        setTimeout(() => this.handleQuantizeNotes(false), 60);
                    }
                } catch (error) {
                    console.error("Error during generative step:", error);
                }
            },

            handleChordalMode(modeName, tracks) {
                const requiredScale = modeName === 'jazz' ? 'Major' : 'Minor';
                const parts = this.state.currentScaleName.split(' ');
                const rootNote = this.NOTE_NAMES.indexOf(parts[0]);
                const scaleName = parts.slice(1).join(' ');

                if (scaleName !== requiredScale) {
                    this.logChange(`${modeName} Mode needs ${requiredScale} scale.`, { isGenerative: true });
                    return; // Don't change the scale automatically, just log a warning
                }

                const scaleIntervals = this.SCALES[scaleName];
                const diatonicMap = modeName === 'jazz'
                    ? { 0: [0,4,7,11], 2: [0,3,7,10], 4: [0,3,7,10], 5: [0,4,7,11], 7: [0,4,7,10], 9: [0,3,7,10], 11: [0,3,6,10] }
                    : {0:[0,7], 2:[0,7], 3:[0,7], 5:[0,7], 7:[0,7], 8:[0,7], 10:[0,7]};

                let chordIntervals;
                let chordName;

                const randomDegreeIndex = Math.floor(Math.random() * 7);
                const degreeRoot = scaleIntervals[randomDegreeIndex];
                chordIntervals = diatonicMap[degreeRoot] || [0, 7]; // Fallback
                const chordRootNote = rootNote + degreeRoot;
                chordName = `${this.NOTE_NAMES[chordRootNote % 12]}${modeName === 'jazz' ? 'maj7' : 'm'}`; // Simplified chord name

                if(this.state.musicMode.randomizeChord || this.state.musicMode.chordType === 'Random') {
                    this.logChange(`${modeName} Chord: ${chordName}`, { isGenerative: true });
                } else {
                    chordIntervals = this.CHORD_TYPES[this.state.musicMode.chordType] || [0,7];
                    const chordRoot = rootNote + scaleIntervals[Math.floor(Math.random() * 7)];
                    chordName = `${this.NOTE_NAMES[chordRoot % 12]}${this.state.musicMode.chordType}`;
                    this.logChange(`${modeName} Chord: ${chordName}`, { isGenerative: true });
                }

                const chordRootMidi = rootNote + (scaleIntervals[Math.floor(Math.random() * 7)]);
                const chordNotes = chordIntervals.map(i => chordRootMidi + i + (this.state.randomization.octave * 12));

                const activeTracks = tracks.filter(t => t.active);
                activeTracks.forEach((track, i) => {
                    const trackIndex = tracks.findIndex(t => t.id === track.id);
                    if(trackIndex !== -1) {
                        tracks[trackIndex].note = chordNotes[i % chordNotes.length];
                    }
                });
            },

            randomizeTrackParameters(track, options, shouldLog = true, assignedNotesByChannel = {}, tracks) {
                let changes = [];
                let newTrackState = {...track};

                if (options.pulses) {
                    const old = track.pulses;
                    const maxPulses = this.state.stepsLocked ? this.state.globalLockedSteps : track.steps;
                    newTrackState.pulses = maxPulses > 0 ? Math.floor(Math.pow(Math.random(), 2) * (maxPulses - 1)) + 1 : 0;
                    changes.push(`P:${old}‚Üí${newTrackState.pulses}`);
                }
                if (options.rotation) {
                    const old = track.rotation;
                    newTrackState.rotation = track.steps > 0 ? Math.floor(Math.random() * track.steps) : 0;
                    changes.push(`R:${old}‚Üí${newTrackState.rotation}`);
                }
                if (options.note) {
                    const baseOctave = this.state.randomization.octave;
                    const minMidi = Math.max(0, (baseOctave - 1) * 12);
                    const maxMidi = Math.min(127, (baseOctave + 1) * 12 + 11);

                    let octaveFilteredScale = this.currentRandomizationScale.filter(note => note >= minMidi && note <= maxMidi);
                    if (octaveFilteredScale.length === 0) octaveFilteredScale = this.currentRandomizationScale;

                    const trackChannel = track.channelOverride === 'global' ? this.state.globalMidiChannel : parseInt(track.channelOverride, 10);
                    const usedNotesOnChannel = assignedNotesByChannel[trackChannel] || [];
                    let availableNotes = octaveFilteredScale.filter(n => !usedNotesOnChannel.includes(n));
                    if(availableNotes.length === 0) availableNotes = octaveFilteredScale;

                    if (availableNotes.length > 0) {
                        const newNote = availableNotes[Math.floor(Math.random() * availableNotes.length)];
                        changes.push(`N:${Tone.Frequency(track.note, "midi").toNote()}‚Üí${Tone.Frequency(newNote, "midi").toNote()}`);
                        newTrackState.note = newNote;
                        if (!assignedNotesByChannel[trackChannel]) assignedNotesByChannel[trackChannel] = [];
                        assignedNotesByChannel[trackChannel].push(newNote);
                    }
                }
                if (options.velocity) {
                    newTrackState.velocity = Math.floor(Math.random() * 78) + 50; // Range 50-127
                    changes.push(`V:${track.velocity}‚Üí${newTrackState.velocity}`);
                }

                const trackIndex = tracks.findIndex(t => t.id === track.id);
                if(trackIndex !== -1) {
                    tracks[trackIndex] = newTrackState;
                }

                const changesString = changes.length > 0 ? `T${track.id + 1}: ${changes.join(', ')}` : null;
                if (shouldLog && changesString) this.logChange(changesString, { isGenerative: true });

                return tracks;
            },

            handleMasterRandomize() {
                let changesToMake = {};
                this.logChange(null, { separator: true });

                if(this.state.randomization.randomizeOctave) {
                    const newOctave = Math.floor(Math.random() * 4) + 2; // Octaves 2-5
                    changesToMake.randomization = { ...this.state.randomization, octave: newOctave };
                    this.logChange(`New base octave: ${newOctave}`);
                }

                if(this.state.randomization.scale) {
                    const scaleNames = Object.keys(this.SCALES);
                    const randomScaleName = scaleNames[Math.floor(Math.random() * scaleNames.length)];
                    const newScale = `${this.NOTE_NAMES[Math.floor(Math.random() * 12)]} ${randomScaleName}`;
                    changesToMake.currentScaleName = newScale;
                    this.logChange(`Scale: ${newScale}`);
                }

                let newTracks = JSON.parse(JSON.stringify(this.state.tracks));
                const assignedNotesByChannel = {};

                const options = {...this.state.randomization, note: this.state.randomization.note, scale: false}; // don't randomize scale per-track

                newTracks.forEach(t => {
                    if(t.active) this.randomizeTrackParameters(t, options, true, assignedNotesByChannel, newTracks);
                });
                changesToMake.tracks = newTracks;

                this.updateState(changesToMake);

                this.showStatusMessage("All Active Tracks Randomized!", 2500);
                document.documentElement.classList.add('randomize-flash');
                setTimeout(() => document.documentElement.classList.remove('randomize-flash'), 200);
            },

            handleRefine(showStatus = true) {
                const activeTracks = this.state.tracks.filter(t => t.active);
                if (activeTracks.length < 2) {
                    if(showStatus) {
                        this.logChange("Need at least 2 active tracks to refine.");
                        this.showStatusMessage("Refinement requires at least 2 active tracks.", 3000);
                    }
                    return;
                }

                let newTracks = JSON.parse(JSON.stringify(this.state.tracks));
                let refinementLogs = [];

                const rootNoteMidi = this.NOTE_NAMES.indexOf(this.state.currentScaleName.split(' ')[0]);
                let notes = activeTracks.map(t => ({ note: t.note, id: t.id, isRoot: (t.note % 12) === rootNoteMidi }));
                notes.sort((a, b) => a.note - b.note);

                const lowestNote = notes[0];
                if (!lowestNote.isRoot) {
                    const lowestTrackIndex = newTracks.findIndex(t => t.id === lowestNote.id);
                    if (lowestTrackIndex !== -1) {
                        const currentOctave = Math.floor(newTracks[lowestTrackIndex].note / 12);
                        newTracks[lowestTrackIndex].note = (currentOctave -1) * 12 + rootNoteMidi;
                    }
                }

                let currentNotes = newTracks.filter(t => t.active).map(t => t.note);
                for (let i = 0; i < currentNotes.length; i++) {
                    for (let j = i + 1; j < currentNotes.length; j++) {
                        if (Math.abs(currentNotes[i] - currentNotes[j]) % 12 === 1) { // Minor second clash
                            const trackToChangeId = newTracks.filter(t => t.active)[j].id;
                            const trackIndex = newTracks.findIndex(t => t.id === trackToChangeId);
                            const oldNote = newTracks[trackIndex].note;

                            let newNote = this.findClosestNoteInScale(oldNote + 1, this.currentRandomizationScale);
                            if (newNote === oldNote || currentNotes.includes(newNote)) {
                                newNote = this.findClosestNoteInScale(oldNote - 1, this.currentRandomizationScale);
                            }
                            if (newNote === oldNote || currentNotes.includes(newNote)) {
                                newNote = this.findClosestNoteInScale(oldNote + 2, this.currentRandomizationScale);
                            }

                            if (newNote !== oldNote && !currentNotes.includes(newNote)) {
                                newTracks[trackIndex].note = newNote;
                                currentNotes[j] = newNote;
                                refinementLogs.push(`Resolved M2: ${Tone.Frequency(oldNote, 'midi').toNote()}‚Üí${Tone.Frequency(newNote, 'midi').toNote()}`);
                            }
                        }
                    }
                }

                if (refinementLogs.length > 0) {
                    this.logChange(`Refined: ${refinementLogs.join(' | ')}`);
                } else if (showStatus) {
                    this.logChange("Refined: No changes needed.");
                }

                this.updateState({ tracks: newTracks });
                if(showStatus) this.showStatusMessage("Sequence refined!", 2000);
            }
        };

        // --- APPLICATION KICK-OFF ---
        RhythmKingApp.init();

    });
</script>
</body>
</html>

