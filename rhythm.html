<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm King 77 - Websynth (MIDI Only)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for a more refined look */
        :root {
            --primary-bg: #2a2a2a;
            --secondary-bg: #3a3a3a;
            --panel-bg: #4a4a4a; /* Darker panel for contrast */
            --panel-border: #6a6a6a;
            --text-color: #e0e0e0;
            --accent-color: #f0ad4e; /* Orange-yellow accent */
            --control-bg: #333333;
            --control-border: #555555;
            --thumb-color: #c0b090; /* Muted gold/silver for sliders */
            --active-toggle: #5cb85c; /* Green for ON */
            --random-btn: #337ab7; /* Blue for Random */
            --learn-btn: #d9534f; /* Red for Learn */
            --save-load-btn: #5bc0de; /* Light blue */
            --midi-util-btn: #f0ad4e; /* Orange for MIDI utilities */
            --status-bg: rgba(0,0,0,0.8);
            --status-text: #fff;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-color);
            overscroll-behavior: none;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            min-height: 100vh; /* Ensure full viewport height */
        }
        .main-container {
            margin-bottom: 2rem;
            flex-grow: 1; /* Allow content to grow */
        }
        .synth-panel {
            background-color: var(--panel-bg);
            border: 2px solid var(--panel-border);
            border-radius: 12px;
            box-shadow: 5px 5px 12px rgba(0,0,0,0.6), -3px -3px 8px rgba(255,255,255,0.07), inset 2px 2px 5px rgba(255,255,255,0.05), inset -2px -2px 5px rgba(0,0,0,0.2);
            padding: 0.5rem;
            transition: opacity 0.4s ease-in-out, filter 0.4s ease-in-out, border-color 0.4s ease-in-out, box-shadow 0.4s ease-in-out;
            position: relative;
            display: flex; /* Use flex for all panels */
            flex-direction: column;
            gap: 0.5rem;
        }
        .synth-panel h2 {
            margin-bottom: 0.5rem;
            flex-shrink: 0;
        }

        .synth-panel.track-pulse {
            animation: trackPulse 0.15s ease-out;
        }
        @keyframes trackPulse {
            from {
                border-color: var(--accent-color);
                filter: brightness(1.2);
            }
            to {
                border-color: var(--panel-border);
                filter: brightness(1);
            }
        }
        .control-flash {
            transition: box-shadow 0.5s ease-out;
            box-shadow: 0 0 10px 4px var(--accent-color);
        }

        .control-slider-container { display: flex; align-items: center; gap: 0.5rem; }
        .number-input-container { display: flex; align-items: center; gap: 0.5rem; }
        .slider-button, .number-input-button {
            background-color: var(--control-border); color: var(--text-color); border: 1px solid var(--control-bg); border-radius: 6px;
            padding: 0.2rem 0.5rem; font-size: 0.9rem; font-weight: bold; line-height: 1; cursor: pointer; user-select: none;
            transition: background-color 0.1s ease;
        }
        .slider-button:hover, .number-input-button:hover { background-color: var(--panel-border); }

        .control-slider {
            -webkit-appearance: none; appearance: none; width: 100%; height: 20px; background: var(--control-bg);
            border-radius: 10px; border: 1px solid var(--control-border); outline: none; cursor: pointer; flex-grow: 1;
            transition: background-color 0.1s ease;
        }
        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 28px; height: 28px; background: var(--thumb-color);
            border-radius: 8px; border: 2px solid var(--control-border); cursor: grab; box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: background-color 0.1s ease, box-shadow 0.1s ease;
        }
        .control-slider::-moz-range-thumb {
            width: 28px; height: 28px; background: var(--thumb-color); border-radius: 8px; border: 2px solid var(--control-border);
            cursor: grab; box-shadow: 0 2px 4px rgba(0,0,0,0.3); transition: background-color 0.1s ease, box-shadow 0.1s ease;
        }
        .control-slider:hover::-webkit-slider-thumb, .control-slider:hover::-moz-range-thumb {
            background-color: var(--accent-color); box-shadow: 0 0 8px var(--accent-color);
        }

        .push-button {
            font-family: 'Orbitron', sans-serif; background-color: var(--panel-border); color: var(--text-color);
            border: 2px solid var(--control-bg); padding: 0.3rem 0.8rem; border-radius: 8px; text-transform: uppercase;
            font-weight: bold; font-size: 0.7rem; box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.1);
            transition: all 0.1s ease-in-out; height: 32px; display: inline-flex; align-items: center; justify-content: center;
        }
        .push-button.icon-button { font-size: 1.1rem; padding: 0.4rem; width: 32px; height: 32px; }
        .push-button:active, .push-button.active {
            background-color: var(--accent-color); color: #333;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.4), inset 2px 2px 5px rgba(0,0,0,0.3), inset -1px -1px 2px rgba(255,255,255,0.1);
            transform: translateY(1px);
        }
        .push-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #playStopButton { background-color: #5cb85c; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2); }
        #playStopButton.stop-state { background-color: #d9534f; }
        #playStopButton:active { background-color: #4cae4c; }
        #playStopButton.stop-state:active { background-color: #c9302c; }

        .learn-cc-button, .note-learn-button {
            background-color: var(--learn-btn); color: white; flex-shrink: 0; padding: 0.15rem 0.5rem; font-size: 0.7rem;
            border-radius: 6px; border: 1px solid #c9302c; box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .learn-cc-button:hover, .note-learn-button:hover { background-color: #c9302c; }
        .learn-cc-button.learning, .note-learn-button.learning {
            background-color: #ffc107; color: #333; animation: pulseLearn 1s infinite alternate;
        }
        @keyframes pulseLearn { from { box-shadow: 0 0 5px #ffc107; } to { box-shadow: 0 0 15px #ffc107; } }
        .learn-cc-button.mapped { background-color: #4CAF50; border-color: #337a36; }

        .randomize-button { background-color: var(--random-btn); color: white; }
        .master-randomize-button { background-color: #f0ad4e; color: #333; }
        .re-init-midi-button { background-color: #6c757d; }
        .save-load-button { background-color: var(--save-load-btn); color: white; }
        .midi-utility-button { background-color: var(--midi-util-btn); color: #333; }

        .pattern-display { display: flex; justify-content: center; align-items: center; margin-top: 0.2rem; height: 24px; gap: 4px; }
        .pattern-step {
            width: 12px; height: 12px; background-color: var(--control-bg); border-radius: 50%;
            transition: background-color 0.1s ease-out, transform 0.1s ease-out; flex-shrink: 0; border: 1px solid var(--control-border);
        }
        .pattern-step.active { background-color: var(--accent-color); }
        .pattern-step.current { background-color: #fff; border: 2px solid var(--accent-color); transform: scale(1.3); box-shadow: 0 0 8px rgba(255,255,255,0.9); }

        label { display: block; margin-bottom: 0.1rem; font-size: 0.75rem; text-transform: uppercase; font-family: 'Orbitron', sans-serif; white-space: nowrap; margin-right: 0.5rem; color: var(--accent-color); }
        select, input[type="number"], input[type="text"] {
            background-color: var(--control-bg); border: 1px solid var(--control-border); color: var(--text-color); padding: 0.4rem; border-radius: 6px; width: 100%; font-size: 0.8rem;
        }
        input[type="number"] { text-align: center; }

        .value-display { font-family: 'Orbitron', sans-serif; color: var(--text-color); font-size: 0.8rem; min-width: 30px; text-align: right; flex-grow: 1; }
        .control-group { display: flex; flex-direction: column; margin-bottom: 0; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.2rem; }
        .checkbox-label-container { display: flex; align-items: center; gap: 0.5rem; font-size: 0.8rem; margin-top: 0.3rem; cursor: pointer; color: var(--text-color); }
        .checkbox-label-container input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--accent-color); border-radius: 4px; }

        #sequencerWrapperPanel { width: 100%; }
        #sequencerTracksContainer { display: flex; flex-wrap: wrap; justify-content: flex-start; gap: 0.75rem; padding: 0.5rem 0; }
        #sequencerTracksContainer > .synth-panel {
            margin-bottom: 0;
            min-width: 300px;
            max-width: 340px;
            flex: 1 1 300px;
        }

        .explanation-text-footer { font-size: 0.85rem; line-height: 1.5; color: #b0b0b0; text-align: center; padding: 1.5rem 1rem; max-width: 700px; margin: 1rem auto 0 auto; border-top: 1px solid var(--control-border); }
        .note-input-group { display: flex; align-items: center; gap: 0.25rem; }
        .note-input-group > input { flex-grow: 1; }

        #musicModePanel, #channelVolumesWrapper, #midiPanel, #randomizationSettingsContainer, #hintsPanel { display: none; }
        body.music-mode-active #musicModePanel { display: flex; }
        #appContainer { display: flex; flex-direction: column; gap: 0.75rem; flex-grow: 1; }
        #mainContent { flex-grow: 1; min-width: 0; display: flex; flex-direction: column; }
        #musicModeLog {
            height: 100%; min-height: 100px; background-color: rgba(0,0,0,0.3); border-radius: 8px; padding: 0.5rem;
            font-size: 0.7rem; line-height: 1.4; overflow-y: auto; display: flex; flex-direction: column-reverse; color: var(--accent-color);
        }
        #musicModeLog > div { padding: 0 0.25rem; margin-bottom: 0.2rem; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 0.2rem; word-break: break-word; }
        #channelVolumesContainer { display: grid; grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)); gap: 0.75rem; padding: 0.2rem; }
        #channelVolumesContainer .control-group { margin-bottom: 0; }
        #channelVolumesContainer .control-header { margin-bottom: 0.1rem; }
        #channelVolumesContainer .control-slider { height: 16px; }
        #channelVolumesContainer .control-slider::-webkit-slider-thumb, #channelVolumesContainer .control-slider::-moz-range-thumb { width: 24px; height: 24px; }
        #channelVolumesContainer label { font-size: 0.7rem; }

        #octaveSelector, #musicModePresetContainer { display: flex; justify-content: center; }
        .radio-label {
            display: inline-flex; align-items: center; background-color: var(--control-bg); border: 1px solid var(--control-border);
            padding: 0.2rem 0.6rem; transition: all 0.1s ease; font-size: 0.8rem; cursor: pointer;
        }
        .radio-label:not(:first-child) { margin-left: -1px; }
        .radio-label:first-child { border-top-left-radius: 6px; border-bottom-left-radius: 6px;}
        .radio-label:last-child { border-top-right-radius: 6px; border-bottom-right-radius: 6px;}
        .radio-label input { display: none; }
        .radio-label:hover { background-color: var(--panel-border); z-index: 1; position: relative; }
        .radio-label.selected { background-color: var(--accent-color); border-color: #f8c57a; z-index: 2; position: relative; }
        .radio-label.selected span { color: var(--primary-bg); font-weight: bold; }

        #logSection { display: none; }
        body.music-mode-active #logSection { display: flex; }

        #bottom-panels-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: stretch; /* Stretch panels to fill height */
        }
        #bottom-panels-container > .synth-panel {
            flex: 1 1 280px;
            height: auto;
        }

        /* Shrink Music Mode panel */
        #musicModePanel {
            flex-grow: 0.5;
        }

        #randomizeOptionsContainer, #viewTogglesContainer {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 0 1rem;
        }

        #statusBar {
            position: fixed; bottom: 0; left: 0; width: 100%; background-color: var(--status-bg); color: var(--status-text);
            padding: 0.5rem 1rem; text-align: center; font-size: 0.9rem; z-index: 1000; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; border-top: 2px solid var(--accent-color);
        }
        #statusBar.visible { opacity: 1; visibility: visible; }

        #hintsPanel {
            aspect-ratio: 1 / 1;
            max-height: 250px;
            max-width: 250px;
        }
        #hintContent {
            background-color: var(--control-bg); border: 1px solid var(--control-border); border-radius: 8px; padding: 0.75rem;
            min-height: 80px; display: flex; align-items: center; justify-content: center; color: #b0b0b0; font-style: italic;
            height: 100%;
        }

        #app-background {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-size: cover;
            transition: all 1s ease-in-out; opacity: 0.8; filter: grayscale(0.5);
        }
        #app-background.bg-default { background-color: var(--primary-bg); background-image: radial-gradient(circle at center, rgba(60,60,60,0.1) 1px, transparent 1px); background-size: 20px 20px; }
        #app-background.bg-music-mode {
            background-color: #3b3b3b; filter: grayscale(0);
            background-image: linear-gradient(0deg, transparent 24%, rgba(240,173,78,0.05) 25%, rgba(240,173,78,0.05) 26%, transparent 27%, transparent 74%, rgba(240,173,78,0.05) 75%, rgba(240,173,78,0.05) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(240,173,78,0.05) 25%, rgba(240,173,78,0.05) 26%, transparent 27%, transparent 74%, rgba(240,173,78,0.05) 75%, rgba(240,173,78,0.05) 76%, transparent 77%, transparent);
            background-size: 80px 80px;
        }
    </style>
</head>
<body class="p-1 md:p-4">

<div id="app-background" class="bg-default"></div>

<header class="text-center mb-4">
    <h1 class="text-3xl md:text-4xl font-bold" style="font-family: 'Orbitron', sans-serif; color: var(--accent-color);">RHYTHM KING 77</h1>
    <p class="text-sm md:text-base text-gray-400">Euclidean MIDI Sequencer</p>
</header>

<div id="appContainer">
    <div id="mainContent" class="flex-grow">
        <div class="flex flex-col gap-3 main-container">
            <div id="sequencerWrapperPanel" class="w-full synth-panel">
                <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Euclidean Sequencer Tracks</h2>
                <div id="sequencerTracksContainer"></div>
            </div>

            <div id="bottom-panels-container">
                <div id="masterControlPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Master Control</h2>

                    <div id="toolbar" class="flex flex-wrap items-center justify-center gap-3">
                        <button id="playStopButton" class="push-button icon-button" title="Start or stop all sequences">&#x25B6;</button>
                        <button id="saveStateButton" class="push-button save-load-button icon-button" title="Save the current session to browser storage">&#128190;</button>
                        <button id="loadStateButton" class="push-button save-load-button icon-button" title="Load the last saved session from browser storage">&#128193;</button>
                    </div>

                    <div class="control-group">
                        <label for="numTracksInput">Number of Tracks:</label>
                        <div class="number-input-container">
                            <button class="number-input-button" data-target="numTracksInput" data-action="decrement" title="Decrease number of tracks">&minus;</button>
                            <input type="number" id="numTracksInput" min="1" max="12" value="4" title="Set the total number of sequencer tracks (1-12).">
                            <button class="number-input-button" data-target="numTracksInput" data-action="increment" title="Increase number of tracks">+</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-header">
                            <label for="bpmSlider">Tempo (BPM):</label> <span id="bpmValue" class="value-display">45</span>
                            <button id="bpmSliderLearnCc" class="learn-cc-button ml-2" data-param-id="bpmSlider" title="Map Master Tempo to a MIDI CC">L</button>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="bpmSlider" data-action="decrement" title="Decrease Tempo">&minus;</button>
                            <input type="range" id="bpmSlider" min="20" max="240" value="45" class="control-slider" title="Adjust master tempo (20-240 BPM)">
                            <button class="slider-button" data-target="bpmSlider" data-action="increment" title="Increase Tempo">+</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-header">
                            <label for="masterVolumeSlider">Master Volume:</label> <span id="masterVolumeValue" class="value-display">100</span>
                            <button id="masterVolumeLearnCc" class="learn-cc-button ml-2" data-param-id="masterVolumeSlider" title="Map Master Volume to a MIDI CC">L</button>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="masterVolumeSlider" data-action="decrement" title="Decrease Volume">&minus;</button>
                            <input type="range" id="masterVolumeSlider" min="0" max="127" value="100" class="control-slider" title="Adjust master volume (sends CC#7 to active channels)">
                            <button class="slider-button" data-target="masterVolumeSlider" data-action="increment" title="Increase Volume">+</button>
                        </div>
                    </div>

                    <div class="control-group border-t border-gray-700 pt-2 mt-2">
                        <label class="font-bold text-xs uppercase" style="font-family: 'Orbitron', sans-serif;">Global Controls</label>
                        <label class="checkbox-label-container" title="Lock all 'Steps' sliders together."><input type="checkbox" id="lockStepsCheckbox"> Lock All Steps</label>
                    </div>
                </div>

                <div id="viewPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Views</h2>
                    <div id="viewTogglesContainer">
                        <label class="checkbox-label-container"><input type="checkbox" data-view-toggle="midiPanel" id="showMidiPanel" checked title="Show/Hide the MIDI Setup panel"> MIDI</label>
                        <label class="checkbox-label-container"><input type="checkbox" data-view-toggle="randomizationSettingsContainer" id="showRandomPanel" checked title="Show/Hide the Randomization panel"> Random</label>
                        <label class="checkbox-label-container"><input type="checkbox" data-view-toggle="channelVolumesWrapper" id="showVolumesPanel" checked title="Show/Hide the Channel Volumes panel"> Volumes</label>
                        <label class="checkbox-label-container"><input type="checkbox" data-view-toggle="hintsPanel" id="showHintsPanel" checked title="Show/Hide the Hints panel"> Hints</label>
                        <label class="checkbox-label-container" title="Toggle Music Mode for automatic generative patterns"><input type="checkbox" id="musicModeToggle"> Music Mode</label>
                    </div>
                </div>

                <div id="midiPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">MIDI Setup</h2>
                    <div class="control-group">
                        <div class="grid grid-cols-2 gap-2">
                            <button id="reInitMidiButton" class="push-button re-init-midi-button w-full" title="Rescan for MIDI devices.">RESET MIDI</button>
                            <button id="allNotesOffButton" class="push-button midi-utility-button w-full" title="Sends 'All Notes Off' messages to prevent stuck notes.">STOP NOTES</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="midiOutSelect">MIDI Output Device:</label>
                        <select id="midiOutSelect" title="Select MIDI output device."></select>
                    </div>
                    <div class="control-group">
                        <label for="midiChannelSelect">Global MIDI Channel:</label>
                        <select id="midiChannelSelect" title="Select default MIDI channel (1-16)."></select>
                    </div>
                </div>

                <div id="randomizationSettingsContainer" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Manual Randomization</h2>
                    <div class="control-group">
                        <button id="masterRandomizeButton" class="push-button master-randomize-button w-full" title="Randomize all active tracks.">RANDOMIZE ALL ACTIVE</button>
                    </div>
                    <div class="control-group">
                        <label for="octaveSelector" class="text-center">Base Octave</label>
                        <div id="octaveSelector" title="Set the base octave for notes"></div>
                    </div>
                    <div id="randomizeOptionsContainer" class="control-group">
                        <label class="font-bold text-xs uppercase col-span-full" style="font-family: 'Orbitron', sans-serif;">Randomize:</label>
                        <label class="checkbox-label-container"><input type="checkbox" class="randomize-option" id="randomizeNoteCheck" checked title="Randomize the MIDI note of tracks"> Notes</label>
                        <label class="checkbox-label-container"><input type="checkbox" class="randomize-option" id="randomizePulsesCheck" checked title="Randomize the number of pulses in tracks"> Pulses</label>
                        <label class="checkbox-label-container"><input type="checkbox" class="randomize-option" id="randomizeRotationCheck" checked title="Randomize the pattern rotation of tracks"> Rotation</label>
                        <label class="checkbox-label-container"><input type="checkbox" class="randomize-option" id="randomizeScaleCheck" checked title="Randomize the musical scale for all tracks"> Scale</label>
                        <label class="checkbox-label-container"><input type="checkbox" class="randomize-option" id="randomizeVelocityCheck" checked title="Randomize the velocity of notes in tracks"> Velocity</label>
                    </div>
                </div>

                <div id="musicModePanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Music Mode</h2>
                    <div class="control-group">
                        <div class="control-header">
                            <label for="randomIntervalSlider">Interval (Bars):</label>
                            <span id="randomIntervalValue" class="value-display">4</span>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="randomIntervalSlider" data-action="decrement" title="Decrease randomization interval">&minus;</button>
                            <input type="range" id="randomIntervalSlider" min="1" max="16" value="4" class="control-slider" title="Set how often Music Mode triggers randomization">
                            <button class="slider-button" data-target="randomIntervalSlider" data-action="increment" title="Increase randomization interval">+</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label class="text-center">Mode</label>
                        <div id="musicModePresetContainer" class="grid grid-cols-2 gap-1"></div>
                    </div>
                    <div class="control-group">
                        <button id="musicModeNextButton" class="push-button w-full" title="Manually trigger the next randomization step">TRIGGER NEXT</button>
                    </div>
                </div>

                <div id="channelVolumesWrapper" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Channel Volumes</h2>
                    <div id="channelVolumesContainer"></div>
                </div>

                <div id="hintsPanel" class="synth-panel">
                    <div class="control-group">
                        <label class="font-bold text-xs uppercase" style="font-family: 'Orbitron', sans-serif;">Helpful Hint</label>
                        <div id="hintContent"></div>
                    </div>
                    <div id="logSection" class="control-group flex-grow flex-col">
                        <label class="font-bold text-xs uppercase" style="font-family: 'Orbitron', sans-serif;">Music Mode Log</label>
                        <div id="musicModeLog"></div>
                    </div>
                </div>
            </div>
        </div>

        <footer id="explanationContainer" class="explanation-text-footer">
            <p>Euclidean rhythms are generated by distributing beats as evenly as possible over a set number of time steps.</p>
        </footer>
    </div>
</div>
<div id="statusBar"><div id="statusBar-content"></div></div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- CONSTANTS AND CONFIGURATION ---
        const MAX_TRACKS = 12;
        const MANUAL_SAVE_KEY = 'rhythmKing77_manualSave_v23';
        const AUTOSAVE_KEY = 'rhythmKing77_autoSave_v23';
        const SCALES = { 'Major': [0, 2, 4, 5, 7, 9, 11], 'Minor': [0, 2, 3, 5, 7, 8, 10], 'Dorian': [0, 2, 3, 5, 7, 9, 10], 'Phrygian': [0, 1, 3, 5, 7, 8, 10], 'Lydian': [0, 2, 4, 6, 7, 9, 11], 'Mixolydian': [0, 2, 4, 5, 7, 9, 10], 'Locrian': [0, 1, 3, 5, 6, 8, 10], 'Major Pentatonic': [0, 2, 4, 7, 9], 'Minor Pentatonic': [0, 3, 5, 7, 10], 'Blues': [0, 3, 5, 6, 7, 10], 'Harmonic Minor': [0, 2, 3, 5, 7, 8, 11], 'Whole Tone': [0, 2, 4, 6, 8, 10], 'Chromatic': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] };
        const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const HINTS = [ "Click a red 'L' to map a MIDI CC. Click a green 'L' to un-map it.", "Toggle 'Music Mode' for generative grooves.", "Hit 'Random' on tracks for instant variations.", "Use the 'Save' icon to create a manual save point.", "Hold +/- buttons for rapid value changes.", "The 'Stop Notes' button sends an 'All Notes Off' command to your MIDI gear.", "'Stop Notes' is your friend if notes get stuck!" ];
        const VIEW_PANEL_MAP = {
            showMidiPanel: 'midiPanel',
            showRandomPanel: 'randomizationSettingsContainer',
            showVolumesPanel: 'channelVolumesWrapper',
            showHintsPanel: 'hintsPanel'
        };
        const MUSIC_MODE_PRESETS = {
            single: { label: "Single Track", multi: false, options: { note: true, pulses: true, rotation: true, scale: true, velocity: true } },
            multi: { label: "Multi-Track", multi: true, options: { note: true, pulses: true, rotation: true, scale: true, velocity: true } },
            melodic: { label: "Melodic", multi: true, options: { note: true, pulses: false, rotation: false, scale: true, velocity: false } },
            musicTheory: { label: "Music Theory", multi: true, options: { note: true, pulses: true, rotation: true, scale: false, velocity: true } },
            circleOfFifths: { label: "Circle of 5ths", multi: true, options: { note: true, pulses: true, rotation: true, scale: false, velocity: true } }
        };

        // --- DOM ELEMENT CACHE ---
        const dom = {
            get: (id) => document.getElementById(id),
            query: (selector) => document.querySelector(selector),
            queryAll: (selector) => document.querySelectorAll(selector),
        };

        function setupDOMCache() {
            const ids = [
                'playStopButton', 'masterRandomizeButton', 'saveStateButton', 'loadStateButton',
                'reInitMidiButton', 'allNotesOffButton', 'numTracksInput', 'lockStepsCheckbox',
                'bpmSlider', 'bpmValue', 'bpmSliderLearnCc', 'masterVolumeSlider',
                'masterVolumeValue', 'masterVolumeLearnCc', 'midiOutSelect', 'midiChannelSelect',
                'sequencerTracksContainer', 'channelVolumesContainer', 'channelVolumesWrapper',
                'statusBar', 'statusBar-content', 'musicModeToggle', 'randomIntervalSlider',
                'randomIntervalValue', 'randomizeNoteCheck', 'randomizePulsesCheck',
                'randomizeRotationCheck', 'randomizeScaleCheck', 'randomizeVelocityCheck',
                'musicModeNextButton', 'musicModeLog', 'hintContent', 'app-background',
                'octaveSelector', 'viewTogglesContainer', 'randomizationSettingsContainer',
                'musicModePanel', 'logSection', 'midiPanel', 'hintsPanel', 'viewPanel',
                'appContainer', 'randomizeOptionsContainer', 'musicModePresetContainer',
                'sequencerWrapperPanel'
            ];
            ids.forEach(id => {
                const camelCaseId = id.replace(/-([a-z])/g, g => g[1].toUpperCase());
                dom[camelCaseId] = dom.get(id);
            });
        }

        // --- APPLICATION STATE ---
        let state = {};
        let transportLoops = [];
        let timedRandomEvent = null;
        let statusTimeout, autosaveTimeout, hintInterval;
        let activeTrackNotes = {}; // For stuck note prevention

        function getDefaultState() {
            return {
                numTracks: 4,
                bpm: 45,
                masterVolume: 100,
                globalMidiChannel: 1,
                midiOutputId: null,
                ccMap: {},
                stepsLocked: false,
                globalLockedSteps: 16,
                channelVolumes: Array(16).fill(100),
                currentScaleName: 'C Major',
                musicMode: {
                    enabled: false,
                    interval: 4,
                    preset: 'single',
                },
                randomization: {
                    note: true,
                    pulses: true,
                    rotation: true,
                    scale: true,
                    velocity: true,
                    octave: 3,
                },
                view: {
                    showMidiPanel: true,
                    showRandomPanel: true,
                    showVolumesPanel: true,
                    showHintsPanel: true
                },
                tracks: Array.from({ length: 4 }, (_, i) => ({
                    id: i,
                    active: true,
                    pulses: [4, 3, 5, 7][i] || 4,
                    steps: 16,
                    rotation: [0, 2, 4, 0][i] || 0,
                    note: [60, 64, 67, 71][i] || 60,
                    velocity: 100,
                    channelOverride: 'global',
                    pattern: [],
                    currentStep: 0,
                }))
            };
        }

        // --- STATE MANAGEMENT & PERSISTENCE ---
        function updateState(newState) {
            state = deepMerge(state, newState);
            requestAutoSave();
            render();
        }

        function updateTrackState(trackId, newTrackState) {
            const newTracks = state.tracks.map(t => t.id === trackId ? deepMerge(t, newTrackState) : t);
            updateState({ tracks: newTracks });
            updateTrackPattern(newTracks.find(t => t.id === trackId));
        }

        function requestAutoSave() {
            if (autosaveTimeout) clearTimeout(autosaveTimeout);
            autosaveTimeout = setTimeout(() => {
                try {
                    localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(state));
                } catch (e) {
                    console.error("Autosave failed. Storage might be full.", e);
                }
            }, 500);
        }

        function manualSaveState() {
            try {
                localStorage.setItem(MANUAL_SAVE_KEY, JSON.stringify(state));
                showStatusMessage("Manual save successful!", 2000);
            } catch (e) {
                console.error("Manual save failed:", e);
                showStatusMessage("Manual save failed. Storage might be full.", 5000);
            }
        }

        async function loadState(stateToLoad) {
            const wasPlaying = Tone.Transport.state === 'started';
            if (wasPlaying) {
                await Tone.Transport.stop();
                panic(); // Clear any lingering notes from the old state
            }

            state = deepMerge(getDefaultState(), stateToLoad);
            Tone.Transport.bpm.value = state.bpm;
            regenerateScaleFromName();

            transportLoops.forEach(l => l?.dispose());
            transportLoops = [];
            state.tracks.forEach(track => {
                updateTrackPattern(track);
            });

            render();

            if (state.midiOutputId && Array.from(dom.midiOutSelect.options).some(o => o.value === state.midiOutputId)) {
                dom.midiOutSelect.value = state.midiOutputId;
                updateMidiOutput();
            }

            setupTimedRandomization();

            if (wasPlaying) {
                await Tone.Transport.start();
            }
        }

        async function loadManualState() {
            const savedStateJSON = localStorage.getItem(MANUAL_SAVE_KEY);
            if (!savedStateJSON) {
                showStatusMessage("No manual save found.");
                return;
            }
            try {
                const loaded = JSON.parse(savedStateJSON);
                await loadState(loaded);
                showStatusMessage("Manual save loaded successfully!", 2000);
            } catch (e) {
                showStatusMessage("Error loading manual save. Data might be corrupt.", 5000);
                console.error("Failed to load state:", e);
            }
        }

        // --- CORE LOGIC (MIDI, EUCLIDEAN, GENERATIVE) ---
        let midiAccess = null;
        let midiOutput = null;
        let currentLearningControl = null;
        let noteLearningTrack = null;

        async function setupMIDI() {
            try {
                if (!navigator.requestMIDIAccess) {
                    showStatusMessage('Web MIDI not supported in this browser.', 5000);
                    updateState({ midi: { ...state.midi, available: false } });
                    return;
                }
                if (midiAccess) {
                    midiAccess.inputs.forEach(i => i.onmidimessage = null);
                    midiAccess.removeEventListener('statechange', populateMidiDeviceList);
                }
                midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                updateState({ midi: { ...state.midi, available: true } });
                populateMidiDeviceList();
                midiAccess.addEventListener('statechange', populateMidiDeviceList);
                midiAccess.inputs.forEach(i => i.onmidimessage = handleMidiMessage);
            } catch (err) {
                showStatusMessage('Web MIDI disabled by permissions policy.', 5000);
                console.error("MIDI setup error:", err);
                updateState({ midi: { ...state.midi, available: false } });
            }
        }

        function handleMidiMessage(event) {
            const [cmd, param1, param2] = event.data;
            const channel = (cmd & 0x0F) + 1;
            const command = cmd & 0xF0;

            // Note learning
            if (command === 0x90 && param2 > 0 && noteLearningTrack) {
                const trackId = noteLearningTrack.trackId;
                updateTrackState(trackId, { note: param1, channelOverride: channel });
                showStatusMessage(`Track ${trackId + 1} set to Note: ${Tone.Frequency(param1, "midi").toNote()} on Ch: ${channel}.`);
                cancelAllLearnModes(false);
                return;
            }

            // CC learning and mapping
            if (command === 0xB0) {
                if (currentLearningControl) {
                    const { paramId } = currentLearningControl;
                    const newCcMap = { ...state.ccMap, [paramId]: { cc: param1, channel: channel } };
                    showStatusMessage(`${getReadableParamId(paramId)} mapped to CC#${param1} on Ch ${channel}.`);
                    cancelAllLearnModes(false);
                    updateState({ccMap: newCcMap});
                } else {
                    Object.entries(state.ccMap).forEach(([paramId, map]) => {
                        if (map.cc === param1 && map.channel === channel) {
                            const el = dom.get(paramId);
                            if (!el) return;
                            const min = parseFloat(el.min ?? 0);
                            const max = parseFloat(el.max ?? 127);
                            const step = parseFloat(el.step ?? 1);
                            const newValue = Math.round((min + (((max - min) * param2) / 127)) / step) * step;
                            el.value = newValue;
                            el.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                    });
                }
            }
        }

        function populateMidiDeviceList() {
            if (!midiAccess || !state.midi?.available) {
                dom.midiOutSelect.innerHTML = '<option>MIDI Not Available</option>';
                return;
            }
            const selectedId = midiOutput?.id;
            dom.midiOutSelect.innerHTML = '';
            if (midiAccess.outputs.size === 0) {
                dom.midiOutSelect.add(new Option("No MIDI Devices Found", ""));
                midiOutput = null;
                return;
            }
            let firstOutput = null;
            midiAccess.outputs.forEach(out => {
                if (!firstOutput) firstOutput = out;
                dom.midiOutSelect.add(new Option(out.name, out.id));
            });
            dom.midiOutSelect.value = selectedId && midiAccess.outputs.has(selectedId) ? selectedId : firstOutput.id;
            updateMidiOutput();
        }

        function updateMidiOutput() {
            const selectedId = dom.midiOutSelect.value;
            midiOutput = selectedId ? midiAccess?.outputs.get(selectedId) : null;
            if(state.midi.outputId !== (midiOutput?.id ?? null)) {
                updateState({ midi: { ...state.midi, outputId: midiOutput?.id ?? null } });
            }
        }

        function sendMidi(command) { midiOutput?.send(command); }
        function sendMidiNoteOn(note, vel, ch) { sendMidi([0x90 + (ch - 1), note, vel]); }
        function sendMidiNoteOff(note, ch) { sendMidi([0x80 + (ch - 1), note, 0]); }
        function sendMidiCC(cc, value, channel) { sendMidi([0xB0 + (channel - 1), cc, value]); }

        function clearActiveNotes() {
            Object.values(activeTrackNotes).forEach(noteInfo => {
                if (noteInfo) sendMidiNoteOff(noteInfo.note, noteInfo.channel);
            });
            activeTrackNotes = {};
        }

        function panic() {
            clearActiveNotes();
            for (let i = 1; i <= 16; i++) {
                sendMidiCC(120, 0, i); // All sound off
                sendMidiCC(123, 0, i); // All notes off
            }
        }

        // FIX: Replaced with a standard, correct Euclidean algorithm (Bjorklund's)
        function generateEuclideanPattern(pulses, steps) {
            if (pulses > steps || pulses < 0 || steps <= 0) return [];
            if (pulses === 0) return Array(steps).fill(0);

            let pattern = [];
            let counts = [];
            let remainders = [];
            let divisor = steps - pulses;
            remainders.push(pulses);
            let level = 0;

            while (true) {
                counts.push(Math.floor(divisor / remainders[level]));
                remainders.push(divisor % remainders[level]);
                divisor = remainders[level];
                level += 1;
                if (remainders[level] <= 1) {
                    break;
                }
            }
            counts.push(divisor);

            function build(level) {
                if (level === -1) {
                    pattern.push(0);
                } else if (level === -2) {
                    pattern.push(1);
                } else {
                    for (let i = 0; i < counts[level]; i++) {
                        build(level - 1);
                    }
                    if (remainders[level] !== 0) {
                        build(level - 2);
                    }
                }
            }

            build(level);
            return pattern.reverse();
        }

        function rotatePattern(pattern, rotation) {
            const len = pattern.length;
            if (len === 0) return [];
            const r = ((rotation % len) + len) % len;
            return [...pattern.slice(r), ...pattern.slice(0, r)];
        }

        function updateTrackPattern(track) {
            if (!track) return;
            const rawPattern = generateEuclideanPattern(track.pulses, track.steps);
            track.pattern = rotatePattern(rawPattern, track.rotation);
            track.currentStep = 0;
            setupTrackLoop(track);
        }

        // --- UI RENDERING ---
        function render() {
            dom.numTracksInput.value = state.numTracks;
            dom.bpmSlider.value = state.bpm;
            dom.bpmValue.textContent = state.bpm;
            dom.masterVolumeSlider.value = state.masterVolume;
            dom.masterVolumeValue.textContent = state.masterVolume;
            dom.lockStepsCheckbox.checked = state.stepsLocked;
            dom.midiChannelSelect.value = state.globalMidiChannel;

            const midiAvailable = state.midi?.available ?? false;
            dom.midiPanel.querySelectorAll('select, button').forEach(el => el.disabled = !midiAvailable);
            dom.queryAll('.learn-cc-button, .note-learn-button').forEach(btn => btn.disabled = !midiAvailable);

            // View Toggles
            Object.entries(VIEW_PANEL_MAP).forEach(([key, panelId]) => {
                const checkbox = dom.get(key);
                const panel = dom.get(panelId);
                if (checkbox) checkbox.checked = state.view[key];
                if(panel) panel.style.display = state.view[key] ? 'flex' : 'none';
            });

            dom.musicModeToggle.checked = state.musicMode.enabled;
            dom.musicModePanel.style.display = state.musicMode.enabled ? 'flex' : 'none';

            document.body.classList.toggle('music-mode-active', state.musicMode.enabled);
            dom.appBackground.classList.toggle('bg-music-mode', state.musicMode.enabled);
            dom.appBackground.classList.toggle('bg-default', !state.musicMode.enabled);
            dom.logSection.style.display = state.musicMode.enabled ? 'flex' : 'none';
            dom.randomIntervalSlider.value = state.musicMode.interval;
            dom.randomIntervalValue.textContent = state.musicMode.interval;

            renderManualRandomizationOptions();
            renderMusicModePresets();
            renderAllTracks();
            renderChannelVolumes();
            renderCcMappings();
            renderOctaveSelector();
        }

        function renderAllTracks() {
            dom.queryAll('.synth-panel[data-track-id]').forEach(panel => {
                if (!state.tracks.some(t => t.id === parseInt(panel.dataset.trackId, 10))) {
                    panel.remove();
                }
            });

            state.tracks.forEach(track => {
                let panel = dom.query(`.synth-panel[data-track-id="${track.id}"]`);
                if (!panel) {
                    panel = createSequencerTrackUI(track.id);
                    dom.sequencerTracksContainer.appendChild(panel);
                }
                renderTrack(track, panel);
            });
        }

        function renderTrack(track, panel) {
            const update = (prop, value, text) => {
                const el = panel.querySelector(`#${prop}${track.id}`);
                if (el) el.value = value;
                const textEl = panel.querySelector(`#${prop}Value${track.id}`);
                if(textEl) textEl.textContent = text ?? value;
            };

            const pulsesSlider = panel.querySelector(`#pulses${track.id}`);
            if (pulsesSlider) {
                pulsesSlider.max = track.steps;
            }

            update('steps', track.steps);
            update('pulses', track.pulses);
            update('rotation', track.rotation);
            update('velocity', track.velocity);

            panel.querySelector(`#note${track.id}`).value = Tone.Frequency(track.note, 'midi').toNote();
            panel.querySelector(`#channelOverride${track.id}`).value = track.channelOverride;

            const toggleButton = panel.querySelector(`#trackToggle${track.id}`);
            toggleButton.textContent = track.active ? 'ON' : 'OFF';
            toggleButton.classList.toggle('active', track.active);

            renderPatternDisplay(track, panel);
        }

        function renderPatternDisplay(track, panel) {
            const display = panel.querySelector(`#patternDisplay${track.id}`);
            if (!display) return;
            display.innerHTML = '';
            const isPlaying = Tone.Transport.state === "started";
            for (let i = 0; i < track.steps; i++) {
                const stepDot = document.createElement('div');
                stepDot.className = 'pattern-step';
                if (track.pattern[i] === 1) stepDot.classList.add('active');
                if (isPlaying && track.active && i === track.currentStep) {
                    stepDot.classList.add('current');
                }
                display.appendChild(stepDot);
            }
        }

        function renderChannelVolumes() {
            for(let i=1; i<=16; i++) {
                const slider = dom.get(`channelVolume${i}`);
                const valueDisplay = dom.get(`channelVolumeValue${i}`);
                if (slider && valueDisplay) {
                    const volume = state.channelVolumes[i - 1];
                    slider.value = volume;
                    valueDisplay.textContent = volume;
                }
            }
        }

        function renderCcMappings() {
            dom.queryAll('.learn-cc-button').forEach(btn => {
                const paramId = btn.dataset.paramId;
                btn.classList.remove('learning', 'mapped');
                if (currentLearningControl?.paramId === paramId) {
                    btn.classList.add('learning');
                    btn.textContent = '...';
                } else {
                    btn.textContent = 'L';
                    if (state.ccMap[paramId]) {
                        btn.classList.add('mapped');
                    }
                }
            });
        }

        function renderOctaveSelector() {
            dom.octaveSelector.querySelectorAll('.radio-label').forEach(label => {
                const radio = label.querySelector('input');
                radio.checked = parseInt(radio.value, 10) === state.randomization.octave;
                label.classList.toggle('selected', radio.checked);
            });
        }

        function renderMusicModePresets() {
            dom.musicModePresetContainer.querySelectorAll('.radio-label').forEach(label => {
                const radio = label.querySelector('input');
                label.classList.toggle('selected', radio.value === state.musicMode.preset);
            });
        }

        function renderManualRandomizationOptions(){
            dom.randomizeNoteCheck.checked = state.randomization.note;
            dom.randomizePulsesCheck.checked = state.randomization.pulses;
            dom.randomizeRotationCheck.checked = state.randomization.rotation;
            dom.randomizeScaleCheck.checked = state.randomization.scale;
            dom.randomizeVelocityCheck.checked = state.randomization.velocity;
        }

        // --- UI CREATION ---
        function createSequencerTrackUI(trackId) {
            const trackDiv = document.createElement('div');
            trackDiv.className = 'synth-panel p-3 flex flex-col relative';
            trackDiv.dataset.trackId = trackId;

            trackDiv.innerHTML = `
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-base font-semibold" style="font-family: 'Orbitron', sans-serif;">Track ${trackId + 1}</h3>
                <div>
                    <button data-action="randomize" class="push-button randomize-button text-xs py-1 px-2" title="Randomize this track">RANDOM</button>
                    <button data-action="toggleActive" id="trackToggle${trackId}" class="push-button text-xs py-1 px-2 ml-1" title="Toggle this track">ON</button>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-x-3 gap-y-1 mb-2">
                ${createSliderControl('steps', trackId, 'Steps', 1, 32, 16)}
                ${createSliderControl('pulses', trackId, 'Pulses', 1, 16, 4)}
                ${createSliderControl('rotation', trackId, 'Rotate', 0, 15, 0)}
                ${createSliderControl('velocity', trackId, 'Velocity', 1, 127, 100)}
                ${createSelectControl('channelOverride', trackId, 'MIDI Ch', ['global', ...Array.from({length:16},(_,i)=>i+1)])}
                ${createNoteControl(trackId)}
            </div>
            <div id="patternDisplay${trackId}" class="pattern-display my-1"></div>
        `;
            return trackDiv;
        }

        function createSliderControl(id, trackId, label, min, max, value) {
            return `
            <div class="control-group">
                <div class="control-header">
                    <label for="${id}${trackId}">${label}:</label>
                    <span id="${id}Value${trackId}" class="value-display">${value}</span>
                    <button class="learn-cc-button ml-2" data-param-id="${id}${trackId}" title="Map ${label} to MIDI CC">L</button>
                </div>
                <div class="control-slider-container">
                    <button class="slider-button" data-target="${id}${trackId}" data-action="decrement" title="Decrease ${label}">&minus;</button>
                    <input type="range" data-action="update" data-prop="${id}" id="${id}${trackId}" min="${min}" max="${max}" value="${value}" class="control-slider" title="Adjust ${label}">
                    <button class="slider-button" data-target="${id}${trackId}" data-action="increment" title="Increase ${label}">+</button>
                </div>
            </div>
        `;
        }

        function createSelectControl(id, trackId, label, options) {
            return `
            <div class="control-group">
                <label for="${id}${trackId}" class="mb-1">${label}:</label>
                <select id="${id}${trackId}" data-action="update" data-prop="${id}" class="text-xs p-1 h-full" title="Set MIDI Channel for this track">
                    ${options.map(o => `<option value="${o}">${o === 'global' ? 'Global' : o}</option>`).join('')}
                </select>
            </div>
        `;
        }

        function createNoteControl(trackId) {
            return `
            <div class="control-group">
                <label for="note${trackId}" class="mb-1">Note:</label>
                <div class="note-input-group">
                    <input type="text" data-action="update" data-prop="note" id="note${trackId}" class="text-xs p-1" title="Set MIDI note (e.g., C3, F#4)">
                    <button data-action="learnNote" id="noteLearn${trackId}" class="note-learn-button" title="Learn MIDI Note from input">L</button>
                </div>
            </div>
        `;
        }

        // --- EVENT HANDLERS ---
        // Auto-repeat for +/- buttons
        let autoRepeatTimeoutId = null;
        let autoRepeatIntervalId = null;
        const AUTO_REPEAT_DELAY = 500;
        const AUTO_REPEAT_INTERVAL = 100;

        function adjustControlValue(targetId, action) {
            const el = dom.get(targetId);
            if (!el) return;
            let val = parseFloat(el.value);
            const step = parseFloat(el.step) || 1;
            const min = parseFloat(el.min);
            const max = parseFloat(el.max);
            el.value = Math.max(min, Math.min(max, val + (action === 'increment' ? step : -step)));
            el.dispatchEvent(new Event(el.id === 'numTracksInput' ? 'change' : 'input', { bubbles: true }));
        }

        function startAutoRepeat(e) {
            const btn = e.target.closest('.slider-button, .number-input-button');
            if (!btn) return;
            if (e.type === 'touchstart') e.preventDefault();

            const targetId = btn.dataset.target;
            const action = btn.dataset.action;

            stopAutoRepeat();
            adjustControlValue(targetId, action);

            autoRepeatTimeoutId = setTimeout(() => {
                autoRepeatIntervalId = setInterval(() => adjustControlValue(targetId, action), AUTO_REPEAT_INTERVAL);
            }, AUTO_REPEAT_DELAY);
        }

        function stopAutoRepeat() {
            clearTimeout(autoRepeatTimeoutId);
            clearInterval(autoRepeatIntervalId);
        }

        function setupGlobalListeners() {
            dom.playStopButton.addEventListener('click', handlePlayStop);
            dom.numTracksInput.addEventListener('change', handleNumTracksChange);
            dom.bpmSlider.addEventListener('input', e => {
                updateState({ bpm: parseInt(e.target.value, 10) });
                Tone.Transport.bpm.value = state.bpm;
            });
            // FIX: Master Volume now sends CC#7 to all active channels
            dom.masterVolumeSlider.addEventListener('input', e => {
                const masterVolume = parseInt(e.target.value, 10);

                const activeChannels = new Set();
                state.tracks.forEach(track => {
                    if (track.active) {
                        const ch = track.channelOverride === 'global' ? state.globalMidiChannel : parseInt(track.channelOverride, 10);
                        activeChannels.add(ch);
                    }
                });

                activeChannels.forEach(ch => {
                    sendMidiCC(7, masterVolume, ch);
                });

                updateState({ masterVolume });
            });

            dom.saveStateButton.addEventListener('click', manualSaveState);
            dom.loadStateButton.addEventListener('click', loadManualState);
            dom.reInitMidiButton.addEventListener('click', async () => {
                await Tone.Transport.stop();
                panic();
                await setupMIDI();
                showStatusMessage("MIDI re-initialized.", 2000);
            });
            dom.allNotesOffButton.addEventListener('click', () => {
                panic();
                showStatusMessage("Stop Notes: All notes off sent.", 1500);
            });
            dom.midiOutSelect.addEventListener('change', updateMidiOutput);
            dom.midiChannelSelect.addEventListener('change', e => updateState({ globalMidiChannel: parseInt(e.target.value, 10) }));

            dom.lockStepsCheckbox.addEventListener('change', handleLockStepsChange);
            dom.viewTogglesContainer.addEventListener('change', e => {
                if(e.target.id === 'musicModeToggle') {
                    updateState({ musicMode: { ...state.musicMode, enabled: e.target.checked } });
                    setupTimedRandomization();
                } else if (e.target.dataset.viewToggle) {
                    const viewKey = 'show' + e.target.id.charAt(4).toUpperCase() + e.target.id.slice(5);
                    updateState({ view: { ...state.view, [viewKey]: e.target.checked } });
                }
            });

            dom.musicModeNextButton.addEventListener('click', triggerGenerativeStep);
            dom.masterRandomizeButton.addEventListener('click', handleMasterRandomize);

            dom.randomIntervalSlider.addEventListener('input', e => {
                const newInterval = parseInt(e.target.value, 10);
                dom.randomIntervalValue.textContent = newInterval;
                updateState({ musicMode: {...state.musicMode, interval: newInterval }});
            });

            dom.randomIntervalSlider.addEventListener('change', e => {
                setupTimedRandomization();
            });

            dom.sequencerTracksContainer.addEventListener('click', handleTrackAction);
            dom.sequencerTracksContainer.addEventListener('input', handleTrackAction);
            dom.sequencerTracksContainer.addEventListener('change', handleTrackAction);

            document.body.addEventListener('click', handleBodyClick, true);

            // Listeners for +/- buttons
            document.body.addEventListener('mousedown', startAutoRepeat);
            document.body.addEventListener('mouseup', stopAutoRepeat);
            document.body.addEventListener('mouseleave', stopAutoRepeat);
            document.body.addEventListener('touchstart', startAutoRepeat, { passive: false });
            document.body.addEventListener('touchend', stopAutoRepeat);

            // Listener for individual randomize checkboxes
            dom.randomizeOptionsContainer.addEventListener('change', handleRandomizeOptionChange);
            // Listener for Music Mode presets
            dom.musicModePresetContainer.addEventListener('change', e => {
                if(e.target.name === 'musicModePreset') {
                    updateState({ musicMode: { ...state.musicMode, preset: e.target.value }});
                }
            });
        }

        function handleRandomizeOptionChange(e) {
            if(e.target.classList.contains('randomize-option')) {
                const newRandomizationState = { ...state.randomization };
                dom.queryAll('.randomize-option').forEach(el => {
                    const key = el.id.replace('randomize', '').replace('Check', '').toLowerCase();
                    newRandomizationState[key] = el.checked;
                });
                updateState({ randomization: newRandomizationState });
            }
        }

        function handleTrackAction(e) {
            const target = e.target;
            const action = target.dataset.action;
            const trackPanel = target.closest('.synth-panel[data-track-id]');
            if (!action || !trackPanel) return;

            const trackId = parseInt(trackPanel.dataset.trackId, 10);
            const track = state.tracks.find(t => t.id === trackId);
            if (!track) return;

            switch(action) {
                // FIX: Individual track random buttons now work
                case 'randomize': randomizeTrackParameters(track, state.randomization); break;
                case 'toggleActive':
                    if (track.active) {
                        const ch = (track.channelOverride !== 'global') ? parseInt(track.channelOverride) : state.globalMidiChannel;
                        sendMidiNoteOff(track.note, ch);
                        delete activeTrackNotes[trackId];
                    }
                    updateTrackState(trackId, { active: !track.active });
                    break;
                case 'learnNote': startNoteLearn(trackId, target); break;
                case 'update': handleTrackUpdate(trackId, target); break;
            }
        }

        function handleTrackUpdate(trackId, target) {
            const prop = target.dataset.prop;
            let value = target.type === 'range' || target.type === 'number' ? parseInt(target.value, 10) : target.value;

            if (prop === 'note') {
                try { value = Tone.Frequency(value.toUpperCase()).toMidi(); }
                catch {
                    showStatusMessage("Invalid note format", 2000);
                    renderTrack(state.tracks.find(t=>t.id===trackId), dom.query(`.synth-panel[data-track-id="${trackId}"]`));
                    return;
                }
            }

            const track = state.tracks.find(t => t.id === trackId);
            const newValues = {[prop]: value};

            if(prop === 'steps') {
                if(value < track.pulses) newValues.pulses = value;
                if(value <= track.rotation) newValues.rotation = value > 0 ? value - 1 : 0;
            }

            if(prop === 'pulses') {
                const maxPulses = state.stepsLocked ? state.globalLockedSteps : track.steps;
                if (value > maxPulses) {
                    value = maxPulses;
                    newValues.pulses = value;
                    target.value = value;
                }
            }

            if (prop === 'steps' && state.stepsLocked) {
                synchronizeAllTrackSteps(value);
            } else {
                updateTrackState(trackId, newValues);
            }
        }

        function handleBodyClick(e) {
            const isLearnButton = e.target.closest('.learn-cc-button, .note-learn-button');
            if (isLearnButton) {
                if(e.target.classList.contains('learn-cc-button')) {
                    handleLearnCcClick(e.target.dataset.paramId, e.target);
                }
                return;
            }

            if(currentLearningControl || noteLearningTrack) {
                cancelAllLearnModes(true);
            }
        }


        // --- INITIALIZATION ---
        async function init() {
            console.log("Rhythm King 77 Initializing...");
            setupDOMCache();

            let loadedState = null;
            try {
                const autoSaveJSON = localStorage.getItem(AUTOSAVE_KEY);
                if (autoSaveJSON) {
                    loadedState = JSON.parse(autoSaveJSON);
                    showStatusMessage("Autosave loaded.", 2000);
                }
            } catch (e) {
                console.error("Could not parse autosave:", e);
                localStorage.removeItem(AUTOSAVE_KEY);
            }

            state = getDefaultState();

            setupGlobalListeners();
            setupToneJS();
            createInitialUI();

            await loadState(loadedState || state);
            await setupMIDI();

            hintInterval = setInterval(showHint, 25000);
            showHint();
            console.log("Initialization complete.");
        }

        function createInitialUI() {
            for (let i = 1; i <= 16; i++) {
                dom.midiChannelSelect.add(new Option(`Ch ${i}`, i));

                const volDiv = document.createElement('div');
                volDiv.className = 'control-group';
                volDiv.innerHTML = `<div class="control-header"><label for="channelVolume${i}">Ch ${i}:</label><span id="channelVolumeValue${i}" class="value-display"></span><button class="learn-cc-button ml-2" data-param-id="channelVolume${i}" title="Map Ch ${i} Volume to a MIDI CC">L</button></div><div class="control-slider-container"><input type="range" id="channelVolume${i}" min="0" max="127" value="100" class="control-slider" title="Adjust volume for MIDI Channel ${i}"></div>`;
                dom.channelVolumesContainer.appendChild(volDiv);

                volDiv.querySelector('input').addEventListener('input', e => {
                    const newVolume = parseInt(e.target.value, 10);
                    const newVolumes = [...state.channelVolumes];
                    newVolumes[i-1] = newVolume;
                    sendMidiCC(7, newVolume, i);
                    updateState({ channelVolumes: newVolumes });
                });
            }

            for (let i = 0; i <= 9; i++) {
                const label = document.createElement('label');
                label.className = 'radio-label';
                label.innerHTML = `<input type="radio" name="octaveSelect" value="${i}"><span>${i}</span>`;
                dom.octaveSelector.appendChild(label);
            }
            dom.octaveSelector.addEventListener('change', e => {
                if (e.target.name === 'octaveSelect') {
                    const newOctave = parseInt(e.target.value, 10);
                    const newRandomizationState = { ...state.randomization, octave: newOctave };
                    updateState({ randomization: newRandomizationState });
                    logChange(`Base octave for randomization set to ${newOctave}.`);
                }
            });

            Object.entries(MUSIC_MODE_PRESETS).forEach(([key, preset]) => {
                const label = document.createElement('label');
                label.className = 'radio-label';
                label.innerHTML = `<input type="radio" name="musicModePreset" value="${key}"><span>${preset.label}</span>`;
                dom.musicModePresetContainer.appendChild(label);
            });
        }

        function setupToneJS() {
            Tone.Transport.on('start', () => {
                dom.playStopButton.innerHTML = '&#x25A0;';
                dom.playStopButton.classList.add('active', 'stop-state');
                transportLoops.forEach(loop => loop?.start(0));
            });
            Tone.Transport.on('stop', () => {
                dom.playStopButton.innerHTML = '&#x25B6;';
                dom.playStopButton.classList.remove('active', 'stop-state');
                panic();
                state.tracks.forEach(t => t.currentStep = 0);
                renderAllTracks();
                transportLoops.forEach(loop => loop?.stop(0));
            });
        }

        // --- UTILITY FUNCTIONS ---
        function showStatusMessage(message, duration = 3000) {
            if (statusTimeout) clearTimeout(statusTimeout);
            dom.statusBarContent.textContent = message;
            dom.statusBar.classList.add('visible');
            statusTimeout = setTimeout(() => dom.statusBar.classList.remove('visible'), duration);
        }

        function showHint() { dom.hintContent.textContent = HINTS[Math.floor(Math.random() * HINTS.length)]; }

        function deepMerge(target, source) {
            const output = { ...target };
            if (isObject(target) && isObject(source)) {
                Object.keys(source).forEach(key => {
                    if (isObject(source[key]) && !Array.isArray(source[key])) {
                        output[key] = deepMerge(target[key] || {}, source[key]);
                    } else {
                        output[key] = source[key];
                    }
                });
            }
            return output;
        }
        function isObject(item) { return (item && typeof item === 'object' && !Array.isArray(item)); }

        function setupTrackLoop(track) {
            if (transportLoops[track.id]) transportLoops[track.id].stop(0).dispose();
            if (track.steps === 0 || !track.pattern.length) {
                renderTrack(track, dom.query(`.synth-panel[data-track-id="${track.id}"]`));
                return;
            }
            transportLoops[track.id] = new Tone.Sequence((time, value) => {
                const ch = (track.channelOverride !== 'global') ? parseInt(track.channelOverride) : state.globalMidiChannel;

                if (activeTrackNotes[track.id]) {
                    const { note, channel } = activeTrackNotes[track.id];
                    sendMidiNoteOff(note, channel);
                    delete activeTrackNotes[track.id];
                }

                if (track.active && value === 1) {
                    // FIX: Velocity is now completely independent of volume controls.
                    const finalVelocity = track.velocity;
                    const noteToPlay = { note: track.note, channel: ch };

                    sendMidiNoteOn(noteToPlay.note, Math.max(1, Math.min(127, finalVelocity)), noteToPlay.channel);
                    activeTrackNotes[track.id] = noteToPlay;

                    Tone.Transport.scheduleOnce(() => {
                        const currentlyActive = activeTrackNotes[track.id];
                        if (currentlyActive && currentlyActive.note === noteToPlay.note && currentlyActive.channel === noteToPlay.channel) {
                            sendMidiNoteOff(noteToPlay.note, noteToPlay.channel);
                            delete activeTrackNotes[track.id];
                        }
                    }, time + Tone.Time("16n").toSeconds() * 0.9);

                    Tone.Draw.schedule(() => {
                        const panel = dom.query(`.synth-panel[data-track-id="${track.id}"]`);
                        if (panel) {
                            panel.classList.add('track-pulse');
                            setTimeout(() => panel.classList.remove('track-pulse'), 150);
                        }
                    }, time);
                }
                Tone.Draw.schedule(() => {
                    track.currentStep = (track.currentStep + 1) % track.steps;
                    renderPatternDisplay(track, dom.query(`.synth-panel[data-track-id="${track.id}"]`));
                }, time);
            }, track.pattern, `${track.steps}n`);

            if (Tone.Transport.state === 'started') {
                transportLoops[track.id].start(0);
            }
        }

        function handlePlayStop() {
            (async () => {
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                    showStatusMessage("Audio Context Started.");
                }
                if (Tone.Transport.state === 'started') {
                    Tone.Transport.stop();
                } else {
                    state.tracks.forEach(setupTrackLoop);
                    Tone.Transport.start();
                }
            })();
        }

        function handleNumTracksChange(e) {
            let newCount = Math.max(1, Math.min(MAX_TRACKS, parseInt(e.target.value, 10) || state.numTracks));
            if (newCount === state.numTracks) return;

            const currentTracks = [...state.tracks];
            const newTracks = [];
            for (let i = 0; i < newCount; i++) {
                if (currentTracks[i]) {
                    newTracks.push(currentTracks[i]);
                } else {
                    newTracks.push({
                        id: i, active: true, pulses: 4, steps: state.stepsLocked ? state.globalLockedSteps : 16,
                        rotation: 0, note: 60, velocity: 100, channelOverride: 'global',
                        pattern: [], currentStep: 0,
                    });
                }
            }
            transportLoops.forEach(l => l?.dispose());
            transportLoops = [];
            newTracks.forEach(updateTrackPattern);

            updateState({ numTracks: newCount, tracks: newTracks });
        }

        function handleLockStepsChange(e) {
            const stepsLocked = e.target.checked;
            if(stepsLocked) {
                const globalLockedSteps = state.tracks.length > 0 ? state.tracks[0].steps : 16;
                updateState({ stepsLocked, globalLockedSteps });
                synchronizeAllTrackSteps(globalLockedSteps);
            } else {
                updateState({ stepsLocked });
            }
        }

        function synchronizeAllTrackSteps(newSteps) {
            const newTracks = state.tracks.map(t => {
                const newPulses = Math.min(t.pulses, newSteps);
                const newRotation = Math.min(t.rotation, newSteps > 0 ? newSteps - 1 : 0);
                return {...t, steps: newSteps, pulses: newPulses, rotation: newRotation };
            });
            newTracks.forEach(updateTrackPattern);
            updateState({ tracks: newTracks, globalLockedSteps: newSteps });
        }

        function handleLearnCcClick(paramId, button) {
            if (currentLearningControl?.paramId === paramId) {
                cancelAllLearnModes(true);
                return;
            }
            if (state.ccMap[paramId]) {
                const newCcMap = {...state.ccMap};
                delete newCcMap[paramId];
                updateState({ccMap: newCcMap});
                showStatusMessage(`Mapping for ${getReadableParamId(paramId)} cleared.`);
            } else {
                cancelAllLearnModes(false);
                currentLearningControl = { paramId, button };
                showStatusMessage(`Listening for MIDI CC for ${getReadableParamId(paramId)}...`);
            }
            render();
        }

        function getReadableParamId(paramId) {
            let readable = paramId.replace(/([A-Z])/g, ' $1');
            let trackMatch = readable.match(/^(steps|pulses|rotation|velocity)\s?(\d+)$/i);
            if (trackMatch) return `${trackMatch[1].charAt(0).toUpperCase() + trackMatch[1].slice(1)} Track ${parseInt(trackMatch[2]) + 1}`;
            let channelMatch = readable.match(/^channel\s?Volume\s?(\d+)$/i);
            if (channelMatch) return `Channel ${channelMatch[1]} Volume`;
            return readable.replace(/^./, str => str.toUpperCase()).trim();
        }

        function startNoteLearn(trackId, button) {
            if (noteLearningTrack?.trackId === trackId) {
                cancelAllLearnModes(true);
                return;
            }
            cancelAllLearnModes(false);
            noteLearningTrack = { trackId, button };
            button.classList.add('learning');
            button.textContent = '...';
            showStatusMessage(`Listening for MIDI Note for Track ${trackId + 1}.`);
        }

        function cancelAllLearnModes(notify = true) {
            if (currentLearningControl) {
                if (notify) showStatusMessage("MIDI CC Learn cancelled.");
                currentLearningControl = null;
            }
            if (noteLearningTrack) {
                if (notify) showStatusMessage("Note Learn cancelled.");
                noteLearningTrack.button.classList.remove('learning');
                noteLearningTrack.button.textContent = 'L';
                noteLearningTrack = null;
            }
            render();
        }

        // --- GENERATIVE FUNCTIONS ---
        let currentRandomizationScale = [];
        function regenerateScaleFromName() {
            if (!state.currentScaleName) return;
            const parts = state.currentScaleName.split(' ');
            const rootNoteName = parts[0];
            const scaleName = parts.slice(1).join(' ');
            const rootNoteMidi = NOTE_NAMES.indexOf(rootNoteName);
            const scaleIntervals = SCALES[scaleName];
            if (rootNoteMidi === -1 || !scaleIntervals) {
                currentRandomizationScale = [];
                return;
            }
            currentRandomizationScale = [];
            for (let octave = 0; octave < 9; octave++) {
                for (const interval of scaleIntervals) {
                    const midiNote = 12 * octave + rootNoteMidi + interval;
                    if (midiNote >= 0 && midiNote <= 127) {
                        currentRandomizationScale.push(midiNote);
                    }
                }
            }
        }

        function randomizeTrackParameters(track, options, shouldLog = true, assignedNotesByChannel = {}) {
            let changes = [];
            let newTrackState = {};

            if (options.pulses) {
                const old = track.pulses;
                const maxPulses = state.stepsLocked ? state.globalLockedSteps : track.steps;
                newTrackState.pulses = maxPulses > 0 ? Math.floor(Math.pow(Math.random(), 2) * (maxPulses - 1)) + 1 : 0;
                changes.push(`P:${old}${newTrackState.pulses}`);
            }
            if (options.rotation) {
                const old = track.rotation;
                newTrackState.rotation = track.steps > 0 ? Math.floor(Math.random() * track.steps) : 0;
                changes.push(`R:${old}${newTrackState.rotation}`);
            }
            if (options.note) {
                if (currentRandomizationScale.length === 0) regenerateScaleFromName();

                const baseOctave = state.randomization.octave;
                const minMidi = Math.max(0, (baseOctave - 1) * 12);
                const maxMidi = Math.min(127, (baseOctave + 1) * 12 + 11);

                let octaveFilteredScale = currentRandomizationScale.filter(note => note >= minMidi && note <= maxMidi);

                if (octaveFilteredScale.length === 0) {
                    octaveFilteredScale = currentRandomizationScale;
                }

                const trackChannel = track.channelOverride === 'global' ? state.globalMidiChannel : parseInt(track.channelOverride, 10);
                const usedNotesOnChannel = assignedNotesByChannel[trackChannel] || [];
                let availableNotes = octaveFilteredScale.filter(n => !usedNotesOnChannel.includes(n));

                if(availableNotes.length === 0) {
                    availableNotes = octaveFilteredScale;
                }

                if (availableNotes.length > 0) {
                    const oldNote = Tone.Frequency(track.note, "midi").toNote();
                    const newNote = availableNotes[Math.floor(Math.random() * availableNotes.length)];
                    newTrackState.note = newNote;

                    if (!assignedNotesByChannel[trackChannel]) {
                        assignedNotesByChannel[trackChannel] = [];
                    }
                    assignedNotesByChannel[trackChannel].push(newNote);

                    changes.push(`N:${oldNote}${Tone.Frequency(newTrackState.note, "midi").toNote()}`);
                }
            }
            if (options.velocity) {
                const old = track.velocity;
                newTrackState.velocity = Math.floor(Math.random() * 107) + 21;
                changes.push(`V:${old}${newTrackState.velocity}`);
            }

            if (Object.keys(newTrackState).length > 0) {
                updateTrackState(track.id, newTrackState);
            }

            const changesString = changes.length > 0 ? `T${track.id + 1}: ${changes.join(', ')}` : null;
            if (shouldLog && changesString) logChange(changesString);
            return changesString;
        }

        function triggerGenerativeStep() {
            const presetKey = state.musicMode.preset;
            const preset = MUSIC_MODE_PRESETS[presetKey];
            if (!preset) return;

            const randomizerOptions = preset.options;

            if (presetKey === 'circleOfFifths') {
                const scaleParts = state.currentScaleName.split(' ');
                const rootName = scaleParts[0];
                const scaleType = scaleParts.slice(1).join(' ');
                const currentRootIndex = NOTE_NAMES.indexOf(rootName);
                const newRootIndex = (currentRootIndex + 7) % 12; // A perfect fifth is 7 semitones
                const newScaleName = `${NOTE_NAMES[newRootIndex]} ${scaleType}`;

                // updateState will trigger regenerateScaleFromName via render()
                updateState({ currentScaleName: newScaleName });
                logChange(`Key Change: ${newScaleName}`);

            } else if (randomizerOptions.scale) {
                // For other modes that change the scale
                const scaleNames = Object.keys(SCALES);
                const randomScaleName = scaleNames[Math.floor(Math.random() * scaleNames.length)];
                const randomRootNote = Math.floor(Math.random() * 12);
                const newScale = `${NOTE_NAMES[randomRootNote]} ${randomScaleName}`;
                updateState({currentScaleName: newScale});
                logChange(`Scale: ${newScale}`);
            } else {
                // For modes that don't change scale, ensure it's up to date
                regenerateScaleFromName();
            }

            const activeTracks = state.tracks.filter(t => t.active);
            if (activeTracks.length === 0) {
                logChange("Music Mode: No active tracks.");
                return;
            }

            const assignedNotesByChannel = {};
            if (preset.multi) {
                let allChanges = activeTracks.map(t => randomizeTrackParameters(t, randomizerOptions, false, assignedNotesByChannel)).filter(c => c);
                if (allChanges.length > 0) logChange(`Multi: ${allChanges.join(' | ')}`);
            } else {
                const trackToRandomize = activeTracks[Math.floor(Math.random() * activeTracks.length)];
                randomizeTrackParameters(trackToRandomize, randomizerOptions, true, assignedNotesByChannel);
            }
        }

        function setupTimedRandomization() {
            if (timedRandomEvent) {
                Tone.Transport.clear(timedRandomEvent);
                timedRandomEvent = null;
            }
            if (state.musicMode.enabled) {
                const interval = `${state.musicMode.interval}m`;
                timedRandomEvent = Tone.Transport.scheduleRepeat(time => {
                    Tone.Draw.schedule(triggerGenerativeStep, time)
                }, interval, "1m");
                logChange(`Music Mode enabled, randomizing every ${state.musicMode.interval} bars.`);
            } else {
                logChange("Music Mode disabled.");
            }
        }

        function handleMasterRandomize() {
            const options = state.randomization;

            if(options.scale) {
                let currentOctave = options.octave;
                let newOctave = currentOctave + (Math.floor(Math.random() * 3) - 1);
                newOctave = Math.max(2, Math.min(5, newOctave));

                state.randomization.octave = newOctave;
                logChange(`New base octave: ${newOctave}`);

                const scaleNames = Object.keys(SCALES);
                const randomScaleName = scaleNames[Math.floor(Math.random() * scaleNames.length)];
                const randomRootNote = Math.floor(Math.random() * 12);
                const newScale = `${NOTE_NAMES[randomRootNote]} ${randomScaleName}`;
                state.currentScaleName = newScale;
                logChange(`Scale: ${newScale}`);
            }

            regenerateScaleFromName();

            const assignedNotesByChannel = {};

            state.tracks.forEach(t => {
                if(t.active) randomizeTrackParameters(t, options, false, assignedNotesByChannel);
            });
            showStatusMessage("All active tracks randomized!", 2500);
            render();
        }

        function logChange(message) {
            if (!dom.musicModeLog) return;
            const entry = document.createElement('div');
            entry.textContent = message;
            dom.musicModeLog.prepend(entry);
            while (dom.musicModeLog.children.length > 3) {
                dom.musicModeLog.removeChild(dom.musicModeLog.lastChild);
            }
        }

        // Kick off the application
        init();
    });
</script>
</body>
</html>
