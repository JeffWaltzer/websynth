<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm King 77 - Websynth (MIDI Only)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for a more refined look */
        :root {
            --primary-bg: #2a2a2a;
            --secondary-bg: #3a3a3a;
            --panel-bg: #4a4a4a;
            --panel-border: #6a6a6a;
            --text-color: #e0e0e0;
            --accent-color: #f0ad4e;
            --accent-glow: rgba(240, 173, 78, 0.7);
            --control-bg: #333333;
            --control-border: #555555;
            --thumb-color: #c0b090;
            --active-toggle: #5cb85c;
            --random-btn: #337ab7;
            --learn-btn: #d9534f;
            --save-load-btn: #5bc0de;
            --midi-util-btn: #f0ad4e;
            --refine-btn: #9b59b6;
            --quantize-btn: #2ecc71;
            --status-bg: rgba(0,0,0,0.8);
            --status-text: #fff;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--primary-bg);
            color: var(--text-color);
            overscroll-behavior: none;
            font-size: 12px;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .main-container {
            margin-bottom: 2rem;
            flex-grow: 1;
        }
        /* UI Enhancement: 3D panel effect */
        .synth-panel {
            background-color: #444;
            background-image: linear-gradient(to bottom, #4f4f4f, #3a3a3a);
            border: 1px solid #222;
            border-top-color: #555;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.1);
            padding: 0.5rem;
            transition: opacity 0.4s ease-in-out, filter 0.4s ease-in-out, border-color 0.4s ease-in-out, box-shadow 0.4s ease-in-out;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .synth-panel h2 {
            margin-bottom: 0.5rem;
            flex-shrink: 0;
            color: var(--text-color);
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        /* UI Enhancement: More prominent activity flash */
        .synth-panel.track-pulse {
            animation: trackPulse 0.2s ease-out;
        }
        @keyframes trackPulse {
            from {
                border-color: var(--flash-color, var(--accent-color));
                box-shadow: 0 0 15px 3px var(--flash-glow, var(--accent-glow)), 0 5px 15px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.1);
            }
            to {
                border-color: #222;
                box-shadow: 0 5px 15px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.1);
            }
        }

        .control-slider-container { display: flex; align-items: center; gap: 0.5rem; }
        .number-input-container { display: flex; align-items: center; gap: 0.5rem; }
        .slider-button, .number-input-button {
            background-color: var(--control-border); color: var(--text-color); border: 1px solid var(--control-bg); border-radius: 6px;
            padding: 0.2rem 0.5rem; font-size: 0.9rem; font-weight: bold; line-height: 1; cursor: pointer; user-select: none;
            transition: background-color 0.1s ease;
        }
        .slider-button:hover, .number-input-button:hover { background-color: var(--panel-border); }

        /* UI Enhancement: 3D slider track */
        .control-slider {
            -webkit-appearance: none; appearance: none; width: 100%; height: 20px;
            background: #2a2a2a;
            border-radius: 10px;
            border: 1px solid #222;
            outline: none; cursor: pointer; flex-grow: 1;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
        }
        /* UI Enhancement: 3D slider thumb */
        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 28px; height: 28px;
            background-image: linear-gradient(to bottom, #e0e0e0, #a0a0a0);
            border-radius: 8px; border: 1px solid #555; cursor: grab;
            box-shadow: 0 2px 3px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
            transition: all 0.1s ease;
        }
        .control-slider::-moz-range-thumb {
            width: 28px; height: 28px;
            background-image: linear-gradient(to bottom, #e0e0e0, #a0a0a0);
            border-radius: 8px; border: 1px solid #555; cursor: grab;
            box-shadow: 0 2px 3px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
            transition: all 0.1s ease;
        }
        .control-slider:hover::-webkit-slider-thumb, .control-slider:hover::-moz-range-thumb {
            background-image: linear-gradient(to bottom, var(--accent-color), #d88c1b);
            box-shadow: 0 0 8px var(--accent-glow), 0 2px 3px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.2);
        }

        /* UI Enhancement: 3D button effect */
        .push-button {
            font-family: 'Orbitron', sans-serif;
            background-color: #585858;
            background-image: linear-gradient(to bottom, #6a6a6a, #4a4a4a);
            color: var(--text-color);
            border: 1px solid #333;
            border-top-color: #777;
            padding: 0.3rem 0.8rem; border-radius: 8px; text-transform: uppercase;
            font-weight: bold; font-size: 0.7rem;
            box-shadow: 0 3px 5px rgba(0,0,0,0.4), inset 0 1px 1px rgba(255,255,255,0.15);
            transition: all 0.1s ease-in-out; height: 32px; display: inline-flex; align-items: center; justify-content: center;
        }
        .push-button.icon-button { font-size: 1.1rem; padding: 0.4rem; width: 32px; height: 32px; }
        .push-button:active, .push-button.active {
            background-image: linear-gradient(to top, #6a6a6a, #4a4a4a);
            box-shadow: 0 1px 2px rgba(0,0,0,0.4), inset 0 2px 4px rgba(0,0,0,0.4);
            transform: translateY(2px);
            border-top-color: #333;
        }
        .push-button.active {
            background-image: linear-gradient(to top, var(--accent-color), #d88c1b);
            color: #333;
        }
        .push-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-image: none;
            box-shadow: none;
        }

        #playStopButton { background-color: #5cb85c; background-image: linear-gradient(to bottom, #7fdf7f, #5cb85c); color: white; }
        #playStopButton.stop-state { background-color: #d9534f; background-image: linear-gradient(to bottom, #e47875, #d9534f); }
        #playStopButton:active { background-image: linear-gradient(to top, #7fdf7f, #5cb85c); }
        #playStopButton.stop-state:active { background-image: linear-gradient(to top, #e47875, #d9534f); }

        .learn-cc-button, .note-learn-button {
            background-color: var(--learn-btn); color: white; flex-shrink: 0; padding: 0.15rem 0.5rem; font-size: 0.7rem;
            border-radius: 6px; border: 1px solid #c9302c; box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .learn-cc-button:hover, .note-learn-button:hover { background-color: #c9302c; }
        .learn-cc-button.learning, .note-learn-button.learning {
            background-color: #ffc107; color: #333; animation: pulseLearn 1s infinite alternate;
        }
        @keyframes pulseLearn { from { box-shadow: 0 0 5px #ffc107; } to { box-shadow: 0 0 15px #ffc107; } }
        .learn-cc-button.mapped { background-color: #4CAF50; border-color: #337a36; }

        .randomize-button { background-color: var(--random-btn); color: white; background-image: linear-gradient(to bottom, #5d9cec, #337ab7);}
        .master-randomize-button { background-color: #f0ad4e; color: #333; background-image: linear-gradient(to bottom, #f3c27a, #f0ad4e);}
        .re-init-midi-button { background-color: #6c757d; background-image: linear-gradient(to bottom, #868e96, #6c757d);}
        .save-load-button { background-color: var(--save-load-btn); color: white; background-image: linear-gradient(to bottom, #81d4fa, #5bc0de);}
        .midi-utility-button { background-color: var(--midi-util-btn); color: #333; background-image: linear-gradient(to bottom, #f3c27a, #f0ad4e);}
        .refine-button { background-color: var(--refine-btn); background-image: linear-gradient(to bottom, #af7ac5, #9b59b6); color: white; }
        .refine-button:active { background-image: linear-gradient(to top, #af7ac5, #9b59b6); }
        .quantize-button { background-color: var(--quantize-btn); background-image: linear-gradient(to bottom, #58d68d, #2ecc71); color: white; }
        .quantize-button:active { background-image: linear-gradient(to top, #58d68d, #2ecc71); }


        .pattern-display { display: flex; justify-content: center; align-items: center; margin-top: 0.2rem; height: 24px; gap: 4px; }
        .pattern-step {
            width: 12px; height: 12px; background-color: #333; border-radius: 50%;
            transition: background-color 0.1s ease-out, transform 0.1s ease-out; flex-shrink: 0; border: 1px solid #222;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
        }
        .pattern-step.active { background-color: var(--accent-color); box-shadow: 0 0 5px var(--accent-glow), inset 0 1px 1px rgba(255,255,255,0.3);}
        .pattern-step.current { background-color: #fff; border: 2px solid var(--accent-color); transform: scale(1.3); box-shadow: 0 0 8px rgba(255,255,255,0.9); }

        label { display: block; margin-bottom: 0.1rem; font-size: 0.75rem; text-transform: uppercase; font-family: 'Orbitron', sans-serif; white-space: nowrap; margin-right: 0.5rem; color: var(--accent-color); text-shadow: 0 1px 1px #000; }
        select, input[type="number"], input[type="text"] {
            background-color: var(--control-bg); border: 1px solid #222; color: var(--text-color); padding: 0.4rem; border-radius: 6px; width: 100%; font-size: 0.8rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.5);
        }
        input[type="number"] { text-align: center; }

        .value-display { font-family: 'Orbitron', sans-serif; color: var(--text-color); font-size: 0.8rem; min-width: 30px; text-align: right; flex-grow: 1; text-shadow: 0 1px 1px #000; }
        .control-group { display: flex; flex-direction: column; margin-bottom: 0; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.2rem; }
        .checkbox-label-container { display: flex; align-items: center; gap: 0.5rem; font-size: 0.8rem; margin-top: 0.3rem; cursor: pointer; color: var(--text-color); }
        .checkbox-label-container input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--accent-color); border-radius: 4px; }

        #sequencerWrapperPanel { width: 100%; }
        #sequencerTracksContainer { display: flex; flex-wrap: wrap; justify-content: center; gap: 0.75rem; padding: 0.5rem 0; margin-left: auto; margin-right: auto; }
        #sequencerTracksContainer > .synth-panel {
            margin-bottom: 0;
            min-width: 300px;
            max-width: 340px;
            flex: 1 1 300px;
        }

        .explanation-text-footer { font-size: 0.85rem; line-height: 1.5; color: #b0b0b0; text-align: center; padding: 1.5rem 1rem; max-width: 700px; margin: 1rem auto 0 auto; border-top: 1px solid var(--control-border); }
        .note-input-group { display: flex; align-items: center; gap: 0.25rem; }
        .note-input-group > input { flex-grow: 1; }

        #musicModePanel, #channelVolumesWrapper, #midiPanel, #randomizationSettingsContainer, #hintsPanel { display: none; }
        body.music-mode-active #musicModePanel { display: flex; }
        #appContainer { display: flex; flex-direction: column; gap: 0.75rem; flex-grow: 1; }
        #mainContent { flex-grow: 1; min-width: 0; display: flex; flex-direction: column; }

        #musicModeLog {
            height: 100%;
            background-color: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 0.25rem 0.4rem;
            font-size: 0.65rem;
            line-height: 1.5;
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse;
            color: var(--accent-color);
        }
        #musicModeLog > div {
            padding-bottom: 0.1rem;
            margin-bottom: 0.1rem;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            word-break: break-word;
        }

        #channelVolumesContainer { display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 0.5rem 0.75rem; padding: 0.2rem; }
        #channelVolumesContainer .control-group { margin-bottom: 0; }
        #channelVolumesContainer .control-header { margin-bottom: 0.1rem; }
        #channelVolumesContainer .control-slider { height: 12px; }
        #channelVolumesContainer .control-slider::-webkit-slider-thumb { width: 20px; height: 20px; }
        #channelVolumesContainer .control-slider::-moz-range-thumb { width: 20px; height: 20px; }
        #channelVolumesContainer label { font-size: 0.7rem; }

        #octaveSelector { display: flex; justify-content: center; }
        #musicModePresetContainer { display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.25rem;}

        .radio-label {
            display: inline-flex; align-items: center; background-color: var(--control-bg); border: 1px solid var(--control-border);
            padding: 0.2rem 0.6rem; transition: all 0.1s ease; font-size: 0.8rem; cursor: pointer; justify-content: center;
        }
        .radio-label input { display: none; }
        .radio-label:hover { background-color: var(--panel-border); z-index: 1; position: relative; }
        .radio-label.selected { background-color: var(--accent-color); border-color: #f8c57a; z-index: 2; position: relative; }
        .radio-label.selected span { color: var(--primary-bg); font-weight: bold; }

        #octaveSelector .radio-label {
            padding: 0.2rem;
            width: 28px;
            text-align: center;
        }
        #octaveSelector .radio-label:not(:first-child) { margin-left: -1px; }
        #octaveSelector .radio-label:first-child { border-radius: 6px 0 0 6px;}
        #octaveSelector .radio-label:last-child { border-radius: 0 6px 6px 0;}

        #musicModePresetContainer .radio-label { border-radius: 6px; margin-left: 0; }


        #logSection { display: none; }
        body.music-mode-active #logSection { display: flex; }

        #bottom-panels-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: stretch;
        }
        #bottom-panels-container > .synth-panel {
            flex-grow: 1;
            flex-shrink: 1;
            flex-basis: 300px;
            height: auto;
        }
        #masterControlPanel { max-width: 380px; }
        #viewPanel { max-width: 180px; }
        #midiPanel { max-width: 280px; }
        #randomizationSettingsContainer { max-width: 320px; }
        #musicModePanel { max-width: 320px; }
        #channelVolumesWrapper { max-width: 420px; }

        #hintsPanel { flex: 1 1 300px; display: flex; flex-direction: column;}
        #hintsPanel .control-group { display: flex; flex-direction: column; }
        #hintsPanel .control-group#hintContainer { flex-shrink: 0; }
        #hintsPanel #logSection { flex-grow: 1; }

        #statusBar {
            position: fixed; bottom: 0; left: 0; width: 100%; background-color: var(--status-bg); color: var(--status-text);
            padding: 0.5rem 1rem; text-align: center; font-size: 0.9rem; z-index: 1000; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out; border-top: 2px solid var(--accent-color);
        }
        #statusBar.visible { opacity: 1; visibility: visible; }
        #hintContent {
            background-color: var(--control-bg); border: 1px solid var(--control-border); border-radius: 8px; padding: 0.75rem;
            min-height: 80px; display: flex; align-items: center; justify-content: center; color: #b0b0b0; font-style: italic;
        }

        #app-background {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background-size: cover;
            transition: all 1s ease-in-out; opacity: 0.8; filter: grayscale(0.5);
        }
        #app-background.bg-default { background-color: var(--primary-bg); background-image: radial-gradient(circle at center, rgba(60,60,60,0.1) 1px, transparent 1px); background-size: 20px 20px; }
        #app-background.bg-music-mode {
            background-color: #3b3b3b; filter: grayscale(0);
            background-image: linear-gradient(0deg, transparent 24%, rgba(240,173,78,0.05) 25%, rgba(240,173,78,0.05) 26%, transparent 27%, transparent 74%, rgba(240,173,78,0.05) 75%, rgba(240,173,78,0.05) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(240,173,78,0.05) 25%, rgba(240,173,78,0.05) 26%, transparent 27%, transparent 74%, rgba(240,173,78,0.05) 75%, rgba(240,173,78,0.05) 76%, transparent 77%, transparent);
            background-size: 80px 80px;
        }
    </style>
</head>
<body class="p-1 md:p-4">

<div id="app-background" class="bg-default"></div>

<header class="text-center mb-4">
    <h1 class="text-3xl md:text-4xl font-bold" style="font-family: 'Orbitron', sans-serif; color: var(--accent-color);">RHYTHM KING 77</h1>
    <p class="text-sm md:text-base text-gray-400">Euclidean MIDI Sequencer</p>
</header>

<div id="appContainer">
    <div id="mainContent" class="flex-grow">
        <div class="flex flex-col gap-3 main-container">
            <div id="sequencerWrapperPanel" class="w-full synth-panel">
                <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Euclidean Sequencer Tracks</h2>
                <div id="sequencerTracksContainer"></div>
            </div>

            <div id="bottom-panels-container">
                <div id="masterControlPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Master Control</h2>

                    <div id="toolbar" class="flex flex-wrap items-center justify-center gap-3">
                        <button id="playStopButton" class="push-button icon-button" title="Start or stop all sequences">&#x25B6;</button>
                        <button id="refineButton" class="push-button icon-button refine-button" title="Use a musical algorithm to refine the current notes and velocities">⚖️</button>
                        <button id="quantizeNotesButton" class="push-button icon-button quantize-button" title="Quantize all track notes to the selected scale">🎼</button>
                        <button id="saveStateButton" class="push-button save-load-button icon-button" title="Save current state as a manual restore point">&#128190;</button>
                        <button id="loadStateButton" class="push-button save-load-button icon-button" title="Load the last manually saved state">&#128193;</button>
                    </div>

                    <div class="control-group">
                        <label for="numTracksInput">Number of Tracks:</label>
                        <div class="number-input-container">
                            <button class="number-input-button" data-target="numTracksInput" data-action="decrement" title="Decrease number of tracks">&minus;</button>
                            <input type="number" id="numTracksInput" min="1" max="12" value="4" title="Set the total number of sequencer tracks (1-12)">
                            <button class="number-input-button" data-target="numTracksInput" data-action="increment" title="Increase number of tracks">+</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-header">
                            <label for="bpmSlider">Tempo (BPM):</label> <span id="bpmValue" class="value-display">45</span>
                            <button id="bpmSliderLearnCc" class="learn-cc-button ml-2" data-param-id="bpmSlider" title="Map Master Tempo to a MIDI CC knob/fader">L</button>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="bpmSlider" data-action="decrement" title="Decrease Tempo">&minus;</button>
                            <input type="range" id="bpmSlider" min="20" max="240" value="45" class="control-slider" title="Adjust master tempo (20-240 BPM)">
                            <button class="slider-button" data-target="bpmSlider" data-action="increment" title="Increase Tempo">+</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-header">
                            <label for="masterVolumeSlider">Master Volume:</label> <span id="masterVolumeValue" class="value-display">100</span>
                            <button id="masterVolumeLearnCc" class="learn-cc-button ml-2" data-param-id="masterVolumeSlider" title="Map Master Volume to a MIDI CC knob/fader">L</button>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="masterVolumeSlider" data-action="decrement" title="Decrease Volume">&minus;</button>
                            <input type="range" id="masterVolumeSlider" min="0" max="127" value="100" class="control-slider" title="Adjust master output volume (scales all note velocities)">
                            <button class="slider-button" data-target="masterVolumeSlider" data-action="increment" title="Increase Volume">+</button>
                        </div>
                    </div>

                    <div class="control-group border-t border-gray-700 pt-2 mt-2">
                        <label class="font-bold text-xs uppercase" style="font-family: 'Orbitron', sans-serif;">Global Controls</label>
                        <label class="checkbox-label-container" title="Lock all 'Steps' sliders so they move together. The first track's value becomes the master value."><input type="checkbox" id="lockStepsCheckbox"> Lock All Steps</label>
                    </div>
                </div>

                <div id="viewPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Panel Toggles</h2>
                    <div id="viewTogglesContainer">
                        <label class="checkbox-label-container" title="Show/Hide the MIDI Setup panel"><input type="checkbox" data-view-toggle="midiPanel" id="showMidiPanel" checked> MIDI</label>
                        <label class="checkbox-label-container" title="Show/Hide the Randomization panel"><input type="checkbox" data-view-toggle="randomizationSettingsContainer" id="showRandomizePanel" checked> Randomize</label>
                        <label class="checkbox-label-container" title="Show/Hide the Channel Volumes panel"><input type="checkbox" data-view-toggle="channelVolumesWrapper" id="showVolumesPanel" checked> Volumes</label>
                        <label class="checkbox-label-container" title="Show/Hide the Hints & Log panel"><input type="checkbox" data-view-toggle="hintsPanel" id="showHintsLogPanel" checked> Hints & Log</label>
                        <label class="checkbox-label-container" title="Toggle Music Mode for automatic, generative patterns"><input type="checkbox" id="musicModeToggle"> Music Mode</label>
                    </div>
                </div>

                <div id="midiPanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">MIDI Setup</h2>
                    <div class="control-group">
                        <div class="grid grid-cols-2 gap-2">
                            <button id="reInitMidiButton" class="push-button re-init-midi-button w-full" title="Rescan for MIDI devices if you plugged one in after loading the page">RESET MIDI</button>
                            <button id="allNotesOffButton" class="push-button midi-utility-button w-full" title="Sends an 'All Notes Off' panic message on all channels to stop stuck notes">STOP NOTES</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label for="midiOutSelect">MIDI Output Device:</label>
                        <select id="midiOutSelect" title="Select the MIDI device or virtual synth to send notes to"></select>
                    </div>
                    <div class="control-group">
                        <label for="midiChannelSelect">Global MIDI Channel:</label>
                        <select id="midiChannelSelect" title="Select the default MIDI channel (1-16) for all tracks set to 'Global'"></select>
                    </div>
                </div>

                <div id="randomizationSettingsContainer" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Randomization</h2>
                    <div class="control-group">
                        <button id="masterRandomizeButton" class="push-button master-randomize-button w-full" title="Randomize all enabled parameters on all active tracks">RANDOMIZE ALL ACTIVE</button>
                    </div>

                    <div class="control-group border-t border-b border-gray-700 py-2 my-2">
                        <label class="font-bold text-xs uppercase text-center" style="font-family: 'Orbitron', sans-serif;">Global Scale</label>
                        <div class="grid grid-cols-2 gap-2 mt-1">
                            <div>
                                <label for="scaleRootSelect">Root</label>
                                <select id="scaleRootSelect" title="Set the root note for the global scale"></select>
                            </div>
                            <div>
                                <label for="scaleTypeSelect">Type</label>
                                <select id="scaleTypeSelect" title="Set the type of the global scale"></select>
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label for="octaveSelector" class="text-center">Base Octave</label>
                        <div id="octaveSelector" title="Set the base octave for randomized notes"></div>
                    </div>
                    <div id="randomizeOptionsContainer" class="control-group">
                        <label class="font-bold text-xs uppercase col-span-full" style="font-family: 'Orbitron', sans-serif;">Randomize:</label>
                        <label class="checkbox-label-container" title="Randomize the MIDI note of each track"><input type="checkbox" class="randomize-option" id="randomizeNoteCheck" checked> Notes</label>
                        <label class="checkbox-label-container" title="Randomize the number of beats (pulses) in each track"><input type="checkbox" class="randomize-option" id="randomizePulsesCheck" checked> Pulses</label>
                        <label class="checkbox-label-container" title="Randomize the pattern's starting point (rotation)"><input type="checkbox" class="randomize-option" id="randomizeRotationCheck" checked> Rotation</label>
                        <label class="checkbox-label-container" title="Randomize the musical scale for all tracks"><input type="checkbox" class="randomize-option" id="randomizeScaleCheck" checked> Scale</label>
                        <label class="checkbox-label-container" title="Randomize the velocity (loudness) of each track"><input type="checkbox" class="randomize-option" id="randomizeVelocityCheck" checked> Velocity</label>
                    </div>
                </div>

                <div id="musicModePanel" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Music Mode</h2>
                    <div class="control-group">
                        <div class="control-header">
                            <label for="randomIntervalSlider">Interval (Bars):</label>
                            <span id="randomIntervalValue" class="value-display">4</span>
                        </div>
                        <div class="control-slider-container">
                            <button class="slider-button" data-target="randomIntervalSlider" data-action="decrement" title="Decrease randomization interval">&minus;</button>
                            <input type="range" id="randomIntervalSlider" min="1" max="16" value="4" class="control-slider" title="Set how often Music Mode triggers a change (in musical bars)">
                            <button class="slider-button" data-target="randomIntervalSlider" data-action="increment" title="Increase randomization interval">+</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <label class="text-center">Mode</label>
                        <div id="musicModePresetContainer"></div>
                    </div>
                    <div class="control-group">
                        <button id="musicModeNextButton" class="push-button w-full" title="Manually trigger the next generative change">TRIGGER NEXT</button>
                    </div>
                    <div class="control-group border-t border-gray-700 pt-2 mt-2">
                        <label class="checkbox-label-container" title="Apply the Refine algorithm after each generative change to improve musicality"><input type="checkbox" id="musicModeRefineCheck"> Auto-Refine</label>
                        <label class="checkbox-label-container" title="Randomize the base octave during generative changes"><input type="checkbox" id="musicModeRandomizeOctaveCheck"> Randomize Octave</label>
                    </div>
                </div>

                <div id="channelVolumesWrapper" class="synth-panel">
                    <h2 class="text-lg font-semibold text-center" style="font-family: 'Orbitron', sans-serif;">Channel Volumes</h2>
                    <div id="channelVolumesContainer"></div>
                </div>

                <div id="hintsPanel" class="synth-panel">
                    <div id="hintContainer" class="control-group">
                        <label class="font-bold text-xs uppercase" style="font-family: 'Orbitron', sans-serif;">Helpful Hint</label>
                        <div id="hintContent"></div>
                    </div>
                    <div id="logSection" class="control-group">
                        <label class="font-bold text-xs uppercase" style="font-family: 'Orbitron', sans-serif;">Music Mode Log</label>
                        <div id="musicModeLog"></div>
                    </div>
                </div>
            </div>
        </div>

        <footer id="explanationContainer" class="explanation-text-footer">
            <p>Euclidean rhythms are generated by distributing beats as evenly as possible over a set number of time steps.</p>
        </footer>
    </div>
</div>
<div id="statusBar"><div id="statusBar-content"></div></div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- CONSTANTS AND CONFIGURATION ---
        const MAX_TRACKS = 12;
        const MANUAL_SAVE_KEY = 'rhythmKing77_manualSave_v24'; // Incremented version
        const AUTOSAVE_KEY = 'rhythmKing77_autoSave_v24'; // Incremented version
        const SCALES = { 'Major': [0, 2, 4, 5, 7, 9, 11], 'Minor': [0, 2, 3, 5, 7, 8, 10], 'Dorian': [0, 2, 3, 5, 7, 9, 10], 'Phrygian': [0, 1, 3, 5, 7, 8, 10], 'Lydian': [0, 2, 4, 6, 7, 9, 11], 'Mixolydian': [0, 2, 4, 5, 7, 9, 10], 'Locrian': [0, 1, 3, 5, 6, 8, 10], 'Major Pentatonic': [0, 2, 4, 7, 9], 'Minor Pentatonic': [0, 3, 5, 7, 10], 'Blues': [0, 3, 5, 6, 7, 10], 'Harmonic Minor': [0, 2, 3, 5, 7, 8, 11], 'Whole Tone': [0, 2, 4, 6, 8, 10], 'Chromatic': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11] };
        const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const HINTS = [ "Click a red 'L' to map a MIDI CC. Click a green 'L' to un-map it.", "Toggle 'Music Mode' for generative grooves.", "Hit 'Random' on tracks for instant variations.", "Use the 'Save' icon to create a manual save point.", "Hold +/- buttons for rapid value changes.", "The 'Stop Notes' button sends an 'All Notes Off' command to your MIDI gear.", "Use the 🎼 button to snap all notes to the selected scale.", "'Stop Notes' is your friend if notes get stuck!" ];
        const VIEW_PANEL_MAP = {
            showMidiPanel: 'midiPanel',
            showRandomizePanel: 'randomizationSettingsContainer',
            showVolumesPanel: 'channelVolumesWrapper',
            showHintsLogPanel: 'hintsPanel'
        };
        const MUSIC_MODE_PRESETS = {
            off: { label: "Off", multi: false, options: { note: false, pulses: false, rotation: false, scale: false, velocity: false } },
            single: { label: "Single", multi: false, options: { note: true, pulses: true, rotation: true, scale: true, velocity: true } },
            multi: { label: "Multi", multi: true, options: { note: true, pulses: true, rotation: true, scale: true, velocity: true } },
            melodic: { label: "Melodic", multi: true, options: { note: true, pulses: false, rotation: false, scale: true, velocity: false } },
            jazz: { label: "Jazz", multi: true, options: { note: true, pulses: false, rotation: false, scale: false, velocity: true } },
            fifths: { label: "Fifths", multi: true, options: { note: true, pulses: true, rotation: true, scale: false, velocity: true } },
            rock: { label: "Rock", multi: true, options: { note: true, pulses: true, rotation: true, scale: false, velocity: true } },
        };

        // --- DOM ELEMENT CACHE ---
        const dom = {
            get: (id) => document.getElementById(id),
            query: (selector) => document.querySelector(selector),
            queryAll: (selector) => document.querySelectorAll(selector),
        };

        function setupDOMCache() {
            const ids = [
                'playStopButton', 'masterRandomizeButton', 'saveStateButton', 'loadStateButton', 'refineButton', 'quantizeNotesButton',
                'reInitMidiButton', 'allNotesOffButton', 'numTracksInput', 'lockStepsCheckbox',
                'bpmSlider', 'bpmValue', 'bpmSliderLearnCc', 'masterVolumeSlider',
                'masterVolumeValue', 'masterVolumeLearnCc', 'midiOutSelect', 'midiChannelSelect',
                'sequencerTracksContainer', 'channelVolumesContainer', 'channelVolumesWrapper',
                'statusBar', 'statusBar-content', 'musicModeToggle', 'randomIntervalSlider',
                'randomIntervalValue', 'randomizeNoteCheck', 'randomizePulsesCheck',
                'randomizeRotationCheck', 'randomizeScaleCheck', 'randomizeVelocityCheck', 'musicModeRandomizeOctaveCheck',
                'musicModeNextButton', 'musicModeLog', 'hintContent', 'app-background',
                'octaveSelector', 'viewTogglesContainer', 'randomizationSettingsContainer',
                'musicModePanel', 'logSection', 'midiPanel', 'hintsPanel', 'viewPanel',
                'appContainer', 'randomizeOptionsContainer', 'musicModePresetContainer', 'musicModeRefineCheck',
                'sequencerWrapperPanel', 'hintContainer', 'showRandomizePanel', 'showHintsLogPanel',
                'scaleRootSelect', 'scaleTypeSelect'
            ];
            ids.forEach(id => {
                const camelCaseId = id.replace(/-([a-z])/g, g => g[1].toUpperCase());
                dom[camelCaseId] = dom.get(id);
            });
        }

        // --- APPLICATION STATE ---
        let state = {};
        let transportLoops = [];
        let timedRandomEvent = null;
        let statusTimeout, autosaveTimeout, hintInterval;
        let activeTrackNotes = {};

        function getDefaultState() {
            return {
                numTracks: 4,
                bpm: 45,
                masterVolume: 100,
                globalMidiChannel: 1,
                midiOutputId: null,
                ccMap: {},
                stepsLocked: false,
                globalLockedSteps: 16,
                channelVolumes: Array(16).fill(100),
                currentScaleName: 'C Major',
                musicMode: {
                    enabled: false,
                    interval: 4,
                    preset: 'single',
                    refine: false,
                    randomizeOctave: false
                },
                randomization: {
                    note: true,
                    pulses: true,
                    rotation: true,
                    scale: true,
                    velocity: true,
                    octave: 3,
                },
                view: {
                    showMidiPanel: true,
                    showRandomizePanel: true,
                    showVolumesPanel: true,
                    showHintsLogPanel: true
                },
                tracks: Array.from({ length: 4 }, (_, i) => ({
                    id: i,
                    active: true,
                    pulses: [4, 3, 5, 7][i] || 4,
                    steps: 16,
                    rotation: [0, 2, 4, 0][i] || 0,
                    note: [60, 64, 67, 71][i] || 60,
                    velocity: 100,
                    channelOverride: 'global'
                }))
            };
        }

        // --- STATE MANAGEMENT & PERSISTENCE ---
        function updateState(newState) {
            const prevState = state;
            const updatedState = deepMerge(state, newState);

            if (JSON.stringify(updatedState.tracks) !== JSON.stringify(prevState.tracks)) {
                updatedState.tracks.forEach(track => {
                    const rawPattern = generateEuclideanPattern(track.pulses, track.steps);
                    track.pattern = rotatePattern(rawPattern, track.rotation);
                    track.currentStep = 0;
                });
            }

            state = updatedState;

            syncAppWithState(state, prevState);
            render();
            requestAutoSave();
        }

        function syncAppWithState(newState, prevState) {
            if (newState.bpm !== prevState.bpm) {
                Tone.Transport.bpm.value = newState.bpm;
            }

            const musicModeChanged = JSON.stringify(newState.musicMode) !== JSON.stringify(prevState.musicMode);
            if (musicModeChanged) {
                setupTimedRandomization();
            }

            const tracksChanged = JSON.stringify(newState.tracks) !== JSON.stringify(prevState.tracks) || newState.globalMidiChannel !== prevState.globalMidiChannel;
            if (tracksChanged) {
                rebuildAllTrackLoops();
            }
        }

        function updateTrackState(trackId, newTrackState) {
            const newTracks = state.tracks.map(t => t.id === trackId ? deepMerge(t, newTrackState) : t);
            updateState({ tracks: newTracks });
        }

        function requestAutoSave() {
            if (autosaveTimeout) clearTimeout(autosaveTimeout);
            autosaveTimeout = setTimeout(() => {
                try {
                    localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(state));
                } catch (e) {
                    console.error("Autosave failed. Storage might be full.", e);
                }
            }, 500);
        }

        function manualSaveState() {
            try {
                localStorage.setItem(MANUAL_SAVE_KEY, JSON.stringify(state));
                showStatusMessage("Manual save successful!", 2000);
            } catch (e) {
                console.error("Manual save failed:", e);
                showStatusMessage("Manual save failed. Storage might be full.", 5000);
            }
        }

        async function loadState(stateToLoad) {
            const wasPlaying = Tone.Transport.state === 'started';
            if (wasPlaying) {
                await Tone.Transport.stop();
                panic();
            }

            state = deepMerge(getDefaultState(), stateToLoad);

            state.tracks.forEach(track => {
                if (!track.pattern) {
                    const rawPattern = generateEuclideanPattern(track.pulses, track.steps);
                    track.pattern = rotatePattern(rawPattern, track.rotation);
                    track.currentStep = 0;
                }
            });

            syncAppWithState(state, getDefaultState());
            render();

            if (state.midiOutputId && Array.from(dom.midiOutSelect.options).some(o => o.value === state.midiOutputId)) {
                dom.midiOutSelect.value = state.midiOutputId;
                updateMidiOutput();
            }

            if (wasPlaying) {
                await Tone.Transport.start();
            }
        }

        async function loadManualState() {
            const savedStateJSON = localStorage.getItem(MANUAL_SAVE_KEY);
            if (!savedStateJSON) {
                showStatusMessage("No manual save found.");
                return;
            }
            try {
                const loaded = JSON.parse(savedStateJSON);
                await loadState(loaded);
                showStatusMessage("Manual save loaded successfully!", 2000);
            } catch (e) {
                showStatusMessage("Error loading manual save. Data might be corrupt.", 5000);
                console.error("Failed to load state:", e);
            }
        }

        // --- CORE LOGIC (MIDI, EUCLIDEAN) ---
        let midiAccess = null;
        let midiOutput = null;
        let currentLearningControl = null;
        let noteLearningTrack = null;

        async function setupMIDI() {
            try {
                if (!navigator.requestMIDIAccess) {
                    showStatusMessage('Web MIDI not supported in this browser.', 5000);
                    return;
                }
                if (midiAccess) {
                    midiAccess.inputs.forEach(i => i.onmidimessage = null);
                    midiAccess.removeEventListener('statechange', populateMidiDeviceList);
                }
                midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                populateMidiDeviceList();
                midiAccess.addEventListener('statechange', populateMidiDeviceList);
                midiAccess.inputs.forEach(i => i.onmidimessage = handleMidiMessage);
            } catch (err) {
                showStatusMessage('Web MIDI disabled by permissions policy.', 5000);
                console.error("MIDI setup error:", err);
            }
        }

        function handleMidiMessage(event) {
            const [cmd, param1, param2] = event.data;
            const channel = (cmd & 0x0F) + 1;
            const command = cmd & 0xF0;

            if (command === 0x90 && param2 > 0 && noteLearningTrack) {
                const trackId = noteLearningTrack.trackId;
                updateTrackState(trackId, { note: param1, channelOverride: channel });
                showStatusMessage(`Track ${trackId + 1} set to Note: ${Tone.Frequency(param1, "midi").toNote()} on Ch: ${channel}.`);
                cancelAllLearnModes(false);
                return;
            }

            if (command === 0xB0) {
                if (currentLearningControl) {
                    const { paramId } = currentLearningControl;
                    const newCcMap = { ...state.ccMap, [paramId]: { cc: param1, channel: channel } };
                    showStatusMessage(`${getReadableParamId(paramId)} mapped to CC#${param1} on Ch ${channel}.`);
                    cancelAllLearnModes(false);
                    updateState({ccMap: newCcMap});
                } else {
                    Object.entries(state.ccMap).forEach(([paramId, map]) => {
                        if (map.cc === param1 && map.channel === channel) {
                            const el = dom.get(paramId);
                            if (!el) return;
                            const min = parseFloat(el.min ?? 0);
                            const max = parseFloat(el.max ?? 127);
                            const step = parseFloat(el.step ?? 1);
                            const newValue = Math.round((min + (((max - min) * param2) / 127)) / step) * step;
                            el.value = newValue;
                            el.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                    });
                }
            }
        }

        function populateMidiDeviceList() {
            if (!midiAccess) {
                dom.midiOutSelect.innerHTML = '<option>MIDI Not Available</option>';
                return;
            }
            const selectedId = midiOutput?.id;
            dom.midiOutSelect.innerHTML = '';
            if (midiAccess.outputs.size === 0) {
                dom.midiOutSelect.add(new Option("No MIDI Devices Found", ""));
                midiOutput = null;
                return;
            }
            let firstOutput = null;
            midiAccess.outputs.forEach(out => {
                if (!firstOutput) firstOutput = out;
                dom.midiOutSelect.add(new Option(out.name, out.id));
            });
            dom.midiOutSelect.value = selectedId && midiAccess.outputs.has(selectedId) ? selectedId : firstOutput?.id;
            updateMidiOutput();
        }

        function updateMidiOutput() {
            const selectedId = dom.midiOutSelect.value;
            midiOutput = selectedId ? midiAccess?.outputs.get(selectedId) : null;
            if(state.midiOutputId !== (midiOutput?.id ?? null)) {
                updateState({ midiOutputId: midiOutput?.id ?? null });
            }
        }

        function sendMidi(command) { midiOutput?.send(command); }
        function sendMidiNoteOn(note, vel, ch) { sendMidi([0x90 + (ch - 1), note, vel]); }
        function sendMidiNoteOff(note, ch) { sendMidi([0x80 + (ch - 1), note, 0]); }
        function sendMidiCC(cc, value, channel) { sendMidi([0xB0 + (channel - 1), cc, value]); }

        function clearActiveNotes() {
            Object.values(activeTrackNotes).forEach(noteInfo => {
                if (noteInfo) sendMidiNoteOff(noteInfo.note, noteInfo.channel);
            });
            activeTrackNotes = {};
        }

        function panic() {
            clearActiveNotes();
            for (let i = 1; i <= 16; i++) {
                sendMidiCC(120, 0, i); // All sound off
                sendMidiCC(123, 0, i); // All notes off
            }
        }

        function generateEuclideanPattern(pulses, steps) {
            if (pulses > steps || pulses < 0 || steps <= 0) return [];
            if (pulses === 0) return Array(steps).fill(0);

            let pattern = [];
            let counts = [];
            let remainders = [];
            let divisor = steps - pulses;
            remainders.push(pulses);
            let level = 0;

            while (true) {
                counts.push(Math.floor(divisor / remainders[level]));
                remainders.push(divisor % remainders[level]);
                divisor = remainders[level];
                level += 1;
                if (remainders[level] <= 1) {
                    break;
                }
            }
            counts.push(divisor);

            function build(level) {
                if (level === -1) pattern.push(0);
                else if (level === -2) pattern.push(1);
                else {
                    for (let i = 0; i < counts[level]; i++) build(level - 1);
                    if (remainders[level] !== 0) build(level - 2);
                }
            }

            build(level);
            return pattern.reverse();
        }

        function rotatePattern(pattern, rotation) {
            const len = pattern.length;
            if (len === 0) return [];
            const r = ((rotation % len) + len) % len;
            return [...pattern.slice(r), ...pattern.slice(0, r)];
        }


        // --- UI RENDERING ---
        function render() {
            regenerateScaleFromName();

            dom.numTracksInput.value = state.numTracks;
            dom.bpmSlider.value = state.bpm;
            dom.bpmValue.textContent = state.bpm;
            dom.masterVolumeSlider.value = state.masterVolume;
            dom.masterVolumeValue.textContent = state.masterVolume;
            dom.lockStepsCheckbox.checked = state.stepsLocked;
            dom.midiChannelSelect.value = state.globalMidiChannel;

            const midiAvailable = !!midiAccess;
            dom.midiPanel.querySelectorAll('select, button').forEach(el => {
                if (el.id !== 'reInitMidiButton' && el.id !== 'allNotesOffButton') {
                    el.disabled = !midiAvailable;
                }
            });
            dom.reInitMidiButton.disabled = false;
            dom.allNotesOffButton.disabled = !midiOutput;

            dom.queryAll('.learn-cc-button, .note-learn-button').forEach(btn => btn.disabled = !midiAvailable);

            Object.entries(VIEW_PANEL_MAP).forEach(([key, panelId]) => {
                const checkbox = dom.get(key);
                const panel = dom.get(panelId);
                if (checkbox) checkbox.checked = state.view[key];
                if(panel) panel.style.display = state.view[key] ? 'flex' : 'none';
            });

            dom.musicModeToggle.checked = state.musicMode.enabled;
            dom.musicModePanel.style.display = state.musicMode.enabled ? 'flex' : 'none';
            dom.musicModeRefineCheck.checked = state.musicMode.refine;
            dom.musicModeRandomizeOctaveCheck.checked = state.musicMode.randomizeOctave;

            document.body.classList.toggle('music-mode-active', state.musicMode.enabled);
            dom.appBackground.classList.toggle('bg-music-mode', state.musicMode.enabled);
            dom.appBackground.classList.toggle('bg-default', !state.musicMode.enabled);
            dom.logSection.style.display = state.musicMode.enabled ? 'flex' : 'none';
            dom.randomIntervalSlider.value = state.musicMode.interval;
            dom.randomIntervalValue.textContent = state.musicMode.interval;

            renderManualRandomizationOptions();
            renderMusicModePresets();
            renderAllTracks();
            renderChannelVolumes();
            renderCcMappings();
            renderOctaveSelector();
            renderScaleSelector();
        }

        function renderScaleSelector() {
            if (!state.currentScaleName) return;
            const parts = state.currentScaleName.split(' ');
            const root = parts[0];
            const type = parts.slice(1).join(' ');

            if (dom.scaleRootSelect.value !== root) {
                dom.scaleRootSelect.value = root;
            }
            if (dom.scaleTypeSelect.value !== type) {
                dom.scaleTypeSelect.value = type;
            }
        }

        function renderAllTracks() {
            dom.queryAll('.synth-panel[data-track-id]').forEach(panel => {
                if (!state.tracks.some(t => t.id === parseInt(panel.dataset.trackId, 10))) {
                    panel.remove();
                }
            });

            state.tracks.forEach(track => {
                let panel = dom.query(`.synth-panel[data-track-id="${track.id}"]`);
                if (!panel) {
                    panel = createSequencerTrackUI(track.id);
                    dom.sequencerTracksContainer.appendChild(panel);
                }
                renderTrack(track, panel);
            });
        }

        function renderTrack(track, panel) {
            const update = (prop, value, text) => {
                const el = panel.querySelector(`#${prop}${track.id}`);
                if (el) el.value = value;
                const textEl = panel.querySelector(`#${prop}Value${track.id}`);
                if(textEl) textEl.textContent = text ?? value;
            };

            const pulsesSlider = panel.querySelector(`#pulses${track.id}`);
            if (pulsesSlider) pulsesSlider.max = track.steps;

            update('steps', track.steps);
            update('pulses', track.pulses);
            update('rotation', track.rotation);
            update('velocity', track.velocity);

            panel.querySelector(`#note${track.id}`).value = Tone.Frequency(track.note, 'midi').toNote();
            panel.querySelector(`#channelOverride${track.id}`).value = track.channelOverride;

            const toggleButton = panel.querySelector(`#trackToggle${track.id}`);
            toggleButton.textContent = track.active ? 'ON' : 'OFF';
            toggleButton.classList.toggle('active', track.active);

            renderPatternDisplay(track, panel);
        }

        function renderPatternDisplay(track, panel) {
            const display = panel.querySelector(`#patternDisplay${track.id}`);
            if (!display) return;
            display.innerHTML = '';
            const isPlaying = Tone.Transport.state === "started";
            const pattern = track.pattern || [];
            for (let i = 0; i < track.steps; i++) {
                const stepDot = document.createElement('div');
                stepDot.className = 'pattern-step';
                if (pattern[i] === 1) stepDot.classList.add('active');
                if (isPlaying && track.active && i === track.currentStep) {
                    stepDot.classList.add('current');
                }
                display.appendChild(stepDot);
            }
        }

        function renderChannelVolumes() {
            for(let i=1; i<=16; i++) {
                const slider = dom.get(`channelVolume${i}`);
                const valueDisplay = dom.get(`channelVolumeValue${i}`);
                if (slider && valueDisplay) {
                    const volume = state.channelVolumes[i - 1];
                    slider.value = volume;
                    valueDisplay.textContent = volume;
                }
            }
        }

        function renderCcMappings() {
            dom.queryAll('.learn-cc-button').forEach(btn => {
                const paramId = btn.dataset.paramId;
                btn.classList.remove('learning', 'mapped');
                if (currentLearningControl?.paramId === paramId) {
                    btn.classList.add('learning');
                    btn.textContent = '...';
                    btn.title = `Listening for MIDI CC for ${getReadableParamId(paramId)}...`;
                } else {
                    btn.textContent = 'L';
                    if (state.ccMap[paramId]) {
                        btn.classList.add('mapped');
                        const { cc, channel } = state.ccMap[paramId];
                        btn.title = `Mapped to CC #${cc} on Ch ${channel}. Click to unmap.`;
                    } else {
                        btn.title = `Map ${getReadableParamId(paramId)} to a MIDI CC knob/fader`;
                    }
                }
            });
        }

        function renderOctaveSelector() {
            dom.octaveSelector.querySelectorAll('.radio-label').forEach(label => {
                const radio = label.querySelector('input');
                radio.checked = parseInt(radio.value, 10) === state.randomization.octave;
                label.classList.toggle('selected', radio.checked);
            });
        }

        function renderMusicModePresets() {
            dom.musicModePresetContainer.querySelectorAll('.radio-label').forEach(label => {
                const radio = label.querySelector('input');
                radio.checked = radio.value === state.musicMode.preset;
                label.classList.toggle('selected', radio.checked);
            });
        }

        function renderManualRandomizationOptions(){
            dom.randomizeNoteCheck.checked = state.randomization.note;
            dom.randomizePulsesCheck.checked = state.randomization.pulses;
            dom.randomizeRotationCheck.checked = state.randomization.rotation;
            dom.randomizeScaleCheck.checked = state.randomization.scale;
            dom.randomizeVelocityCheck.checked = state.randomization.velocity;
        }

        // --- UI CREATION ---
        function createSequencerTrackUI(trackId) {
            const trackDiv = document.createElement('div');
            trackDiv.className = 'synth-panel p-3 flex flex-col relative';
            trackDiv.dataset.trackId = trackId;

            trackDiv.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-base font-semibold" style="font-family: 'Orbitron', sans-serif;">Track ${trackId + 1}</h3>
                    <div>
                        <button data-action="randomize" class="push-button randomize-button text-xs py-1 px-2" title="Randomize this track's parameters">RANDOM</button>
                        <button data-action="toggleActive" id="trackToggle${trackId}" class="push-button text-xs py-1 px-2 ml-1" title="Mute or unmute this track">ON</button>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-x-3 gap-y-1 mb-2">
                    ${createSliderControl('steps', trackId, 'Steps', 1, 32, 16, 'Number of steps in the sequence (pattern length)')}
                    ${createSliderControl('pulses', trackId, 'Pulses', 1, 16, 4, 'Number of active beats in the pattern')}
                    ${createSliderControl('rotation', trackId, 'Rotate', 0, 15, 0, 'Shift the pattern start point left or right')}
                    ${createSliderControl('velocity', trackId, 'Velocity', 1, 127, 100, 'Note loudness (MIDI velocity)')}
                    ${createSelectControl('channelOverride', trackId, 'MIDI Ch', ['global', ...Array.from({length:16},(_,i)=>i+1)])}
                    ${createNoteControl(trackId)}
                </div>
                <div id="patternDisplay${trackId}" class="pattern-display my-1"></div>
            `;
            return trackDiv;
        }

        function createSliderControl(id, trackId, label, min, max, value, title) {
            return `
                <div class="control-group">
                    <div class="control-header">
                        <label for="${id}${trackId}">${label}:</label>
                        <span id="${id}Value${trackId}" class="value-display">${value}</span>
                        <button class="learn-cc-button ml-2" data-param-id="${id}${trackId}" title="Map ${label} to a MIDI CC knob/fader">L</button>
                    </div>
                    <div class="control-slider-container">
                        <button class="slider-button" data-target="${id}${trackId}" data-action="decrement" title="Decrease ${label}">&minus;</button>
                        <input type="range" data-action="update" data-prop="${id}" id="${id}${trackId}" min="${min}" max="${max}" value="${value}" class="control-slider" title="${title}">
                        <button class="slider-button" data-target="${id}${trackId}" data-action="increment" title="Increase ${label}">+</button>
                    </div>
                </div>
            `;
        }

        function createSelectControl(id, trackId, label, options) {
            return `
                <div class="control-group">
                    <label for="${id}${trackId}" class="mb-1">${label}:</label>
                    <select id="${id}${trackId}" data-action="update" data-prop="${id}" class="text-xs p-1 h-full" title="Set a specific MIDI Channel for this track, or use the Global setting">
                        ${options.map(o => `<option value="${o}">${o === 'global' ? 'Global' : o}</option>`).join('')}
                    </select>
                </div>
            `;
        }

        function createNoteControl(trackId) {
            return `
                <div class="control-group">
                    <label for="note${trackId}" class="mb-1">Note:</label>
                    <div class="note-input-group">
                        <input type="text" data-action="update" data-prop="note" id="note${trackId}" class="text-xs p-1" title="Set the MIDI note for this track (e.g., C3, F#4, G5)">
                        <button data-action="learnNote" id="noteLearn${trackId}" class="note-learn-button" title="Learn MIDI note and channel from your controller">L</button>
                    </div>
                </div>
            `;
        }

        // --- EVENT HANDLERS ---
        let autoRepeatTimeoutId = null;
        let autoRepeatIntervalId = null;
        const AUTO_REPEAT_DELAY = 500;
        const AUTO_REPEAT_INTERVAL = 100;

        function adjustControlValue(targetId, action) {
            const el = dom.get(targetId);
            if (!el) return;
            let val = parseFloat(el.value);
            const step = parseFloat(el.step) || 1;
            const min = parseFloat(el.min);
            const max = parseFloat(el.max);
            el.value = Math.max(min, Math.min(max, val + (action === 'increment' ? step : -step)));
            el.dispatchEvent(new Event(el.id === 'numTracksInput' ? 'change' : 'input', { bubbles: true }));
        }

        function startAutoRepeat(e) {
            const btn = e.target.closest('.slider-button, .number-input-button');
            if (!btn) return;
            if (e.type === 'touchstart') e.preventDefault();
            const targetId = btn.dataset.target;
            const action = btn.dataset.action;
            stopAutoRepeat();
            adjustControlValue(targetId, action);
            autoRepeatTimeoutId = setTimeout(() => {
                autoRepeatIntervalId = setInterval(() => adjustControlValue(targetId, action), AUTO_REPEAT_INTERVAL);
            }, AUTO_REPEAT_DELAY);
        }

        function stopAutoRepeat() {
            clearTimeout(autoRepeatTimeoutId);
            clearInterval(autoRepeatIntervalId);
        }

        function setupGlobalListeners() {
            dom.playStopButton.addEventListener('click', handlePlayStop);
            dom.numTracksInput.addEventListener('change', handleNumTracksChange);

            dom.bpmSlider.addEventListener('input', e => updateState({ bpm: parseInt(e.target.value, 10) }));
            dom.masterVolumeSlider.addEventListener('input', e => updateState({ masterVolume: parseInt(e.target.value, 10) }));

            dom.saveStateButton.addEventListener('click', manualSaveState);
            dom.loadStateButton.addEventListener('click', loadManualState);
            dom.refineButton.addEventListener('click', () => handleRefine(true));
            dom.quantizeNotesButton.addEventListener('click', handleQuantizeNotes);

            dom.reInitMidiButton.addEventListener('click', async () => {
                await Tone.Transport.stop();
                panic();
                await setupMIDI();
                showStatusMessage("MIDI re-initialized.", 2000);
            });
            dom.allNotesOffButton.addEventListener('click', () => {
                panic();
                showStatusMessage("Stop Notes: All notes off sent.", 1500);
            });
            dom.midiOutSelect.addEventListener('change', updateMidiOutput);
            dom.midiChannelSelect.addEventListener('change', e => updateState({ globalMidiChannel: parseInt(e.target.value, 10) }));

            dom.lockStepsCheckbox.addEventListener('change', handleLockStepsChange);

            dom.scaleRootSelect.addEventListener('change', handleScaleChange);
            dom.scaleTypeSelect.addEventListener('change', handleScaleChange);

            dom.viewTogglesContainer.addEventListener('change', e => {
                if(e.target.id === 'musicModeToggle') {
                    if(e.target.checked) dom.musicModeLog.innerHTML = '';
                    updateState({ musicMode: { ...state.musicMode, enabled: e.target.checked } });
                } else if (e.target.dataset.viewToggle) {
                    const viewKey = 'show' + e.target.id.charAt(4).toUpperCase() + e.target.id.slice(5);
                    updateState({ view: { ...state.view, [viewKey]: e.target.checked } });
                }
            });

            dom.musicModeNextButton.addEventListener('click', triggerGenerativeStep);
            dom.masterRandomizeButton.addEventListener('click', handleMasterRandomize);

            dom.randomIntervalSlider.addEventListener('input', e => {
                updateState({ musicMode: {...state.musicMode, interval: parseInt(e.target.value, 10) }});
            });

            dom.musicModeRefineCheck.addEventListener('change', e => {
                updateState({ musicMode: { ...state.musicMode, refine: e.target.checked } });
            });

            dom.musicModeRandomizeOctaveCheck.addEventListener('change', e => {
                updateState({ musicMode: { ...state.musicMode, randomizeOctave: e.target.checked } });
            });

            dom.sequencerTracksContainer.addEventListener('click', handleTrackAction);
            dom.sequencerTracksContainer.addEventListener('input', handleTrackAction);
            dom.sequencerTracksContainer.addEventListener('change', handleTrackAction);

            document.body.addEventListener('click', handleBodyClick, true);

            document.body.addEventListener('mousedown', startAutoRepeat);
            document.body.addEventListener('mouseup', stopAutoRepeat);
            document.body.addEventListener('mouseleave', stopAutoRepeat);
            document.body.addEventListener('touchstart', startAutoRepeat, { passive: false });
            document.body.addEventListener('touchend', stopAutoRepeat);

            dom.randomizeOptionsContainer.addEventListener('change', handleRandomizeOptionChange);

            dom.musicModePresetContainer.addEventListener('click', e => {
                const label = e.target.closest('.radio-label');
                if (!label) return;

                const radio = label.querySelector('input');
                if (radio && radio.name === 'musicModePreset') {
                    updateState({ musicMode: { ...state.musicMode, preset: radio.value }});
                }
            });
        }

        function handleScaleChange() {
            const root = dom.scaleRootSelect.value;
            const type = dom.scaleTypeSelect.value;
            const newScaleName = `${root} ${type}`;
            if (state.currentScaleName !== newScaleName) {
                logChange(`Scale changed to: ${newScaleName}`);
                updateState({ currentScaleName: newScaleName });
            }
        }

        function handleQuantizeNotes() {
            regenerateScaleFromName();
            if (currentRandomizationScale.length === 0) {
                showStatusMessage("Cannot quantize: Invalid scale selected.", 3000);
                return;
            }

            const newTracks = state.tracks.map(track => {
                if (track.active) {
                    const newNote = findClosestNoteInScale(track.note, currentRandomizationScale);
                    return { ...track, note: newNote };
                }
                return track;
            });

            updateState({ tracks: newTracks });
            showStatusMessage(`All notes quantized to ${state.currentScaleName}.`, 2500);
        }


        function handleRandomizeOptionChange(e) {
            if(e.target.classList.contains('randomize-option')) {
                const newRandomizationState = { ...state.randomization };
                dom.queryAll('.randomize-option').forEach(el => {
                    const key = el.id.replace('randomize', '').replace('Check', '').toLowerCase();
                    newRandomizationState[key] = el.checked;
                });
                updateState({ randomization: newRandomizationState });
            }
        }

        function handleTrackAction(e) {
            const target = e.target;
            const action = target.dataset.action;
            const trackPanel = target.closest('.synth-panel[data-track-id]');
            if (!action || !trackPanel) return;

            const trackId = parseInt(trackPanel.dataset.trackId, 10);
            const track = state.tracks.find(t => t.id === trackId);
            if (!track) return;

            switch(action) {
                case 'randomize': randomizeTrackParameters(track, state.randomization); break;
                case 'toggleActive':
                    if (track.active) {
                        const ch = (track.channelOverride !== 'global') ? parseInt(track.channelOverride) : state.globalMidiChannel;
                        sendMidiNoteOff(track.note, ch);
                        delete activeTrackNotes[trackId];
                    }
                    updateTrackState(trackId, { active: !track.active });
                    break;
                case 'learnNote': startNoteLearn(trackId, target); break;
                case 'update': handleTrackUpdate(trackId, target); break;
            }
        }

        function handleTrackUpdate(trackId, target) {
            const prop = target.dataset.prop;
            let value = target.type === 'range' || target.type === 'number' ? parseInt(target.value, 10) : target.value;

            if (prop === 'note') {
                try {
                    const midiValue = Tone.Frequency(value.toUpperCase()).toMidi();
                    target.value = Tone.Frequency(midiValue, 'midi').toNote();
                    value = midiValue;
                } catch {
                    showStatusMessage("Invalid note format", 2000);
                    renderTrack(state.tracks.find(t=>t.id===trackId), dom.query(`.synth-panel[data-track-id="${trackId}"]`));
                    return;
                }
            }

            const track = state.tracks.find(t => t.id === trackId);
            const newValues = {[prop]: value};

            if(prop === 'steps') {
                if(value < track.pulses) newValues.pulses = value;
                if(value <= track.rotation) newValues.rotation = value > 0 ? value - 1 : 0;
            } else if (prop === 'pulses') {
                const maxPulses = state.stepsLocked ? state.globalLockedSteps : track.steps;
                if (value > maxPulses) newValues.pulses = maxPulses;
            }

            if (prop === 'steps' && state.stepsLocked) {
                synchronizeAllTrackSteps(value);
            } else {
                updateTrackState(trackId, newValues);
            }
        }

        function handleBodyClick(e) {
            const isLearnButton = e.target.closest('.learn-cc-button, .note-learn-button');
            if (isLearnButton) {
                if(e.target.classList.contains('learn-cc-button')) {
                    handleLearnCcClick(e.target.dataset.paramId, e.target);
                }
                return;
            }

            if(currentLearningControl || noteLearningTrack) {
                cancelAllLearnModes(true);
            }
        }


        // --- INITIALIZATION ---
        async function init() {
            console.log("Rhythm King 77 Initializing...");
            setupDOMCache();

            let loadedState = null;
            try {
                const autoSaveJSON = localStorage.getItem(AUTOSAVE_KEY);
                if (autoSaveJSON) {
                    loadedState = JSON.parse(autoSaveJSON);
                    showStatusMessage("Autosave loaded.", 2000);
                }
            } catch (e) {
                console.error("Could not parse autosave:", e);
                localStorage.removeItem(AUTOSAVE_KEY);
            }

            setupGlobalListeners();
            setupToneJS();
            createInitialUI();

            await loadState(loadedState || getDefaultState());
            await setupMIDI();

            hintInterval = setInterval(showHint, 25000);
            showHint();
            console.log("Initialization complete.");
        }

        function createInitialUI() {
            for (let i = 1; i <= 16; i++) {
                dom.midiChannelSelect.add(new Option(`Ch ${i}`, i));

                const volDiv = document.createElement('div');
                volDiv.className = 'control-group';
                volDiv.innerHTML = `<div class="control-header"><label for="channelVolume${i}">Ch ${i}:</label><span id="channelVolumeValue${i}" class="value-display"></span><button class="learn-cc-button ml-2" data-param-id="channelVolume${i}" title="Map Ch ${i} Volume to a MIDI CC knob/fader">L</button></div><div class="control-slider-container"><input type="range" id="channelVolume${i}" min="0" max="127" value="100" class="control-slider" title="Adjust volume for MIDI Channel ${i}"></div>`;
                dom.channelVolumesContainer.appendChild(volDiv);

                volDiv.querySelector('input').addEventListener('input', e => {
                    const newVolume = parseInt(e.target.value, 10);
                    const newVolumes = [...state.channelVolumes];
                    newVolumes[i-1] = newVolume;
                    sendMidiCC(7, newVolume, i);
                    updateState({ channelVolumes: newVolumes });
                });
            }

            // Populate Scale Selectors
            NOTE_NAMES.forEach(note => dom.scaleRootSelect.add(new Option(note, note)));
            Object.keys(SCALES).forEach(scaleName => dom.scaleTypeSelect.add(new Option(scaleName, scaleName)));


            for (let i = 0; i <= 9; i++) {
                const label = document.createElement('label');
                label.className = 'radio-label';
                label.innerHTML = `<input type="radio" name="octaveSelect" value="${i}"><span>${i}</span>`;
                label.title = `Set base octave for randomization to ${i}`;
                dom.octaveSelector.appendChild(label);
            }
            dom.octaveSelector.addEventListener('change', e => {
                if (e.target.name === 'octaveSelect') {
                    updateState({ randomization: { ...state.randomization, octave: parseInt(e.target.value, 10) }});
                    logChange(`Base octave for randomization set to ${e.target.value}.`);
                }
            });

            dom.musicModePresetContainer.innerHTML = '';
            const presetTooltips = {
                off: "Music Mode does nothing.",
                single: "Changes one parameter on one random track.",
                multi: "Changes all enabled parameters on all active tracks.",
                melodic: "Changes notes and scale, but keeps rhythm the same.",
                jazz: "Generates diatonic 7th chords from the current scale.",
                fifths: "Shifts the musical key by a perfect fifth.",
                rock: "Uses the Minor Pentatonic scale for a classic rock sound."
            };
            Object.entries(MUSIC_MODE_PRESETS).forEach(([key, preset]) => {
                const label = document.createElement('label');
                label.className = 'radio-label';
                label.innerHTML = `<input type="radio" name="musicModePreset" value="${key}"><span>${preset.label}</span>`;
                label.title = presetTooltips[key];
                dom.musicModePresetContainer.appendChild(label);
            });
        }

        function setupToneJS() {
            Tone.Transport.on('start', () => {
                dom.playStopButton.innerHTML = '&#x25A0;';
                dom.playStopButton.classList.add('active', 'stop-state');
                transportLoops.forEach(loop => loop?.start(0));
            });
            Tone.Transport.on('stop', () => {
                dom.playStopButton.innerHTML = '&#x25B6;';
                dom.playStopButton.classList.remove('active', 'stop-state');
                panic();
                state.tracks.forEach(t => {
                    t.currentStep = 0;
                    const panel = dom.query(`.synth-panel[data-track-id="${t.id}"]`);
                    if (panel) renderPatternDisplay(t, panel);
                });
                transportLoops.forEach(loop => loop?.stop(0));
            });
        }

        // --- UTILITY FUNCTIONS ---
        function showStatusMessage(message, duration = 3000) {
            if (statusTimeout) clearTimeout(statusTimeout);
            dom.statusBarContent.textContent = message;
            dom.statusBar.classList.add('visible');
            statusTimeout = setTimeout(() => dom.statusBar.classList.remove('visible'), duration);
        }

        function showHint() { dom.hintContent.textContent = HINTS[Math.floor(Math.random() * HINTS.length)]; }

        function deepMerge(target, source) {
            const output = { ...target };
            if (isObject(target) && isObject(source)) {
                Object.keys(source).forEach(key => {
                    if (isObject(source[key]) && !Array.isArray(source[key])) {
                        output[key] = deepMerge(target[key] || {}, source[key]);
                    } else {
                        output[key] = source[key];
                    }
                });
            }
            return output;
        }
        function isObject(item) { return (item && typeof item === 'object' && !Array.isArray(item)); }

        function rebuildAllTrackLoops() {
            transportLoops.forEach(l => l?.dispose());
            transportLoops = [];
            state.tracks.forEach(track => {
                transportLoops[track.id] = createTrackLoop(track);
            });

            if (Tone.Transport.state === 'started') {
                transportLoops.forEach(loop => loop?.start(0));
            }
        }

        function getNoteColor(note, minNote, maxNote) {
            const range = Math.max(1, maxNote - minNote);
            const normalized = (note - minNote) / range;
            const hue = 240 - (normalized * 240);
            const color = `hsl(${hue}, 90%, 65%)`;
            const glow = `hsla(${hue}, 90%, 65%, 0.7)`;
            return { color, glow };
        }

        function findClosestNoteInScale(midiNote, scale) {
            if (!scale || scale.length === 0) return midiNote;
            return scale.reduce((prev, curr) => {
                return (Math.abs(curr - midiNote) < Math.abs(prev - midiNote) ? curr : prev);
            });
        }

        function createTrackLoop(track) {
            if (track.steps === 0 || !track.pattern || track.pattern.length === 0) {
                return null;
            }

            return new Tone.Sequence((time, value) => {
                const ch = (track.channelOverride !== 'global') ? parseInt(track.channelOverride) : state.globalMidiChannel;

                if (activeTrackNotes[track.id]) {
                    const { note, channel } = activeTrackNotes[track.id];
                    sendMidiNoteOff(note, channel);
                    delete activeTrackNotes[track.id];
                }

                if (track.active && value === 1) {
                    const channelVolume = state.channelVolumes[ch - 1] / 127.0;
                    const masterVol = state.masterVolume / 127.0;
                    const finalVelocity = Math.round(track.velocity * channelVolume * masterVol);
                    const noteToPlay = { note: track.note, channel: ch };

                    sendMidiNoteOn(noteToPlay.note, Math.max(1, Math.min(127, finalVelocity)), noteToPlay.channel);
                    activeTrackNotes[track.id] = noteToPlay;

                    Tone.Transport.scheduleOnce(() => {
                        const currentlyActive = activeTrackNotes[track.id];
                        if (currentlyActive && currentlyActive.note === noteToPlay.note && currentlyActive.channel === noteToPlay.channel) {
                            sendMidiNoteOff(noteToPlay.note, noteToPlay.channel);
                            delete activeTrackNotes[track.id];
                        }
                    }, time + Tone.Time("16n").toSeconds() * 0.9);

                    const allNotes = state.tracks.filter(t => t.active).map(t => t.note);
                    const minNote = Math.min(...allNotes);
                    const maxNote = Math.max(...allNotes);
                    const { color, glow } = getNoteColor(noteToPlay.note, minNote, maxNote);

                    Tone.Draw.schedule(() => {
                        const panel = dom.query(`.synth-panel[data-track-id="${track.id}"]`);
                        if (panel) {
                            panel.style.setProperty('--flash-color', color);
                            panel.style.setProperty('--flash-glow', glow);
                            panel.classList.add('track-pulse');
                            setTimeout(() => panel.classList.remove('track-pulse'), 150);
                        }
                    }, time);
                }

                Tone.Draw.schedule(() => {
                    const trackToUpdate = state.tracks.find(t => t.id === track.id);
                    if(trackToUpdate) {
                        trackToUpdate.currentStep = (trackToUpdate.currentStep + 1) % trackToUpdate.steps;
                        const panel = dom.query(`.synth-panel[data-track-id="${track.id}"]`);
                        if (panel) renderPatternDisplay(trackToUpdate, panel);
                    }
                }, time);
            }, track.pattern, `${track.steps}n`);
        }

        function handlePlayStop() {
            (async () => {
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                    showStatusMessage("Audio Context Started.");
                }
                if (Tone.Transport.state === 'started') {
                    Tone.Transport.stop();
                } else {
                    rebuildAllTrackLoops();
                    Tone.Transport.start();
                }
            })();
        }

        function handleNumTracksChange(e) {
            let newCount = Math.max(1, Math.min(MAX_TRACKS, parseInt(e.target.value, 10) || state.numTracks));
            if (newCount === state.numTracks) return;

            const currentTracks = [...state.tracks];
            const newTracks = [];
            for (let i = 0; i < newCount; i++) {
                if (currentTracks[i]) {
                    newTracks.push(currentTracks[i]);
                } else {
                    newTracks.push({
                        id: i, active: true, pulses: 4, steps: state.stepsLocked ? state.globalLockedSteps : 16,
                        rotation: 0, note: 60, velocity: 100, channelOverride: 'global'
                    });
                }
            }
            updateState({ numTracks: newCount, tracks: newTracks });
        }

        function handleLockStepsChange(e) {
            const stepsLocked = e.target.checked;
            if(stepsLocked) {
                const globalLockedSteps = state.tracks.length > 0 ? state.tracks[0].steps : 16;
                updateState({ stepsLocked, globalLockedSteps });
                synchronizeAllTrackSteps(globalLockedSteps);
            } else {
                updateState({ stepsLocked });
            }
        }

        function synchronizeAllTrackSteps(newSteps) {
            const newTracks = state.tracks.map(t => {
                const newPulses = Math.min(t.pulses, newSteps);
                const newRotation = Math.min(t.rotation, newSteps > 0 ? newSteps - 1 : 0);
                return {...t, steps: newSteps, pulses: newPulses, rotation: newRotation };
            });
            updateState({ tracks: newTracks, globalLockedSteps: newSteps });
        }

        function handleLearnCcClick(paramId, button) {
            if (currentLearningControl?.paramId === paramId) {
                cancelAllLearnModes(true);
                return;
            }
            if (state.ccMap[paramId]) {
                const newCcMap = {...state.ccMap};
                delete newCcMap[paramId];
                updateState({ccMap: newCcMap});
                showStatusMessage(`Mapping for ${getReadableParamId(paramId)} cleared.`);
            } else {
                cancelAllLearnModes(false);
                currentLearningControl = { paramId, button };
                showStatusMessage(`Listening for MIDI CC for ${getReadableParamId(paramId)}...`);
                renderCcMappings();
            }
        }

        function getReadableParamId(paramId) {
            let readable = paramId.replace(/([A-Z])/g, ' $1');
            let trackMatch = readable.match(/^(steps|pulses|rotation|velocity)\s?(\d+)$/i);
            if (trackMatch) return `${trackMatch[1].charAt(0).toUpperCase() + trackMatch[1].slice(1)} Track ${parseInt(trackMatch[2]) + 1}`;
            let channelMatch = readable.match(/^channel\s?Volume\s?(\d+)$/i);
            if (channelMatch) return `Channel ${channelMatch[1]} Volume`;
            return readable.replace(/^./, str => str.toUpperCase()).trim();
        }

        function startNoteLearn(trackId, button) {
            if (noteLearningTrack?.trackId === trackId) {
                cancelAllLearnModes(true);
                return;
            }
            cancelAllLearnModes(false);
            noteLearningTrack = { trackId, button };
            button.classList.add('learning');
            button.textContent = '...';
            showStatusMessage(`Listening for MIDI Note for Track ${trackId + 1}.`);
        }

        function cancelAllLearnModes(notify = true) {
            if (currentLearningControl) {
                if (notify) showStatusMessage("MIDI CC Learn cancelled.");
                currentLearningControl = null;
            }
            if (noteLearningTrack) {
                if (notify) showStatusMessage("Note Learn cancelled.");
                noteLearningTrack.button.classList.remove('learning');
                noteLearningTrack.button.textContent = 'L';
                noteLearningTrack = null;
            }
            renderCcMappings();
        }

        // --- GENERATIVE FUNCTIONS ---
        let currentRandomizationScale = [];
        function regenerateScaleFromName() {
            if (!state.currentScaleName) return;
            const parts = state.currentScaleName.split(' ');
            const rootNoteName = parts[0];
            const scaleName = parts.slice(1).join(' ');
            const rootNoteMidi = NOTE_NAMES.indexOf(rootNoteName);
            const scaleIntervals = SCALES[scaleName];
            if (rootNoteMidi === -1 || !scaleIntervals) {
                currentRandomizationScale = [];
                return;
            }
            currentRandomizationScale = [];
            for (let octave = 0; octave < 9; octave++) {
                for (const interval of scaleIntervals) {
                    const midiNote = 12 * octave + rootNoteMidi + interval;
                    if (midiNote >= 0 && midiNote <= 127) {
                        currentRandomizationScale.push(midiNote);
                    }
                }
            }
        }

        function randomizeTrackParameters(track, options, shouldLog = true, assignedNotesByChannel = {}) {
            let changes = [];
            let newTrackState = {};

            if (options.pulses) {
                const old = track.pulses;
                const maxPulses = state.stepsLocked ? state.globalLockedSteps : track.steps;
                newTrackState.pulses = maxPulses > 0 ? Math.floor(Math.pow(Math.random(), 2) * (maxPulses - 1)) + 1 : 0;
                changes.push(`P:${old}→${newTrackState.pulses}`);
            }
            if (options.rotation) {
                const old = track.rotation;
                newTrackState.rotation = track.steps > 0 ? Math.floor(Math.random() * track.steps) : 0;
                changes.push(`R:${old}→${newTrackState.rotation}`);
            }
            if (options.note) {
                const baseOctave = state.randomization.octave;
                const minMidi = Math.max(0, (baseOctave - 1) * 12);
                const maxMidi = Math.min(127, (baseOctave + 1) * 12 + 11);

                let octaveFilteredScale = currentRandomizationScale.filter(note => note >= minMidi && note <= maxMidi);
                if (octaveFilteredScale.length === 0) octaveFilteredScale = currentRandomizationScale;

                const trackChannel = track.channelOverride === 'global' ? state.globalMidiChannel : parseInt(track.channelOverride, 10);
                const usedNotesOnChannel = assignedNotesByChannel[trackChannel] || [];
                let availableNotes = octaveFilteredScale.filter(n => !usedNotesOnChannel.includes(n));
                if(availableNotes.length === 0) availableNotes = octaveFilteredScale;

                if (availableNotes.length > 0) {
                    const newNote = availableNotes[Math.floor(Math.random() * availableNotes.length)];
                    changes.push(`N:${Tone.Frequency(track.note, "midi").toNote()}→${Tone.Frequency(newNote, "midi").toNote()}`);
                    newTrackState.note = newNote;
                    if (!assignedNotesByChannel[trackChannel]) assignedNotesByChannel[trackChannel] = [];
                    assignedNotesByChannel[trackChannel].push(newNote);
                }
            }
            if (options.velocity) {
                changes.push(`V:${track.velocity}→${Math.floor(Math.random() * 107) + 21}`);
                newTrackState.velocity = Math.floor(Math.random() * 107) + 21;
            }

            if (Object.keys(newTrackState).length > 0) {
                updateTrackState(track.id, newTrackState);
            }

            const changesString = changes.length > 0 ? `T${track.id + 1}: ${changes.join(', ')}` : null;
            if (shouldLog && changesString) logChange(changesString, { isGenerative: true });
        }

        async function triggerGenerativeStep() {
            const presetKey = state.musicMode.preset;
            if(presetKey === 'off') {
                logChange("Music Mode is Off.");
                return;
            }

            const preset = MUSIC_MODE_PRESETS[presetKey];
            if (!preset) return;

            const activeTracks = state.tracks.filter(t => t.active);
            if (activeTracks.length === 0) {
                logChange("Music Mode: No active tracks.");
                return;
            }

            logChange('---', { separator: true });

            let nextState = {};
            const randomizerOptions = preset.options;
            const shouldLogGenerativeStep = !state.musicMode.refine;

            if(state.musicMode.randomizeOctave) {
                const newOctave = Math.max(2, Math.min(5, state.randomization.octave + (Math.floor(Math.random() * 3) - 1)));
                if (newOctave !== state.randomization.octave) {
                    nextState.randomization = { ...state.randomization, octave: newOctave };
                    if(shouldLogGenerativeStep) logChange(`New base octave: ${newOctave}`, { isGenerative: true });
                }
            }

            if (presetKey === 'jazz') {
                const parts = state.currentScaleName.split(' ');
                const rootNote = NOTE_NAMES.indexOf(parts[0]);
                const scaleName = parts.slice(1).join(' ');

                if (scaleName !== 'Major' && scaleName !== 'Minor') {
                    logChange(`Jazz Mode needs Major/Minor scale. Changing scale...`, { isGenerative: true });
                    const randomRootNote = Math.floor(Math.random() * 12);
                    updateState({ currentScaleName: `${NOTE_NAMES[randomRootNote]} Major` });
                    return;
                }

                const diatonicChordsMajor = { 0: [0,4,7,11], 2: [0,3,7,10], 4: [0,3,7,10], 5: [0,4,7,11], 7: [0,4,7,10], 9: [0,3,7,10], 11: [0,3,6,10] };
                const diatonicChordsMinor = { 0: [0,3,7,10], 2: [0,3,6,10], 3: [0,4,7,11], 5: [0,3,7,10], 7: [0,3,7,10], 8: [0,4,7,11], 10: [0,4,7,10] };

                const scaleIntervals = SCALES[scaleName];
                const diatonicMap = scaleName === 'Major' ? diatonicChordsMajor : diatonicChordsMinor;

                const randomDegreeIndex = Math.floor(Math.random() * 7);
                const degreeRoot = scaleIntervals[randomDegreeIndex];
                const chordIntervals = diatonicMap[degreeRoot];

                const chordRootNote = rootNote + degreeRoot;
                const chordNotes = chordIntervals.map(i => chordRootNote + i + (state.randomization.octave * 12));

                const chordName = `${NOTE_NAMES[chordRootNote % 12]}`;
                if(shouldLogGenerativeStep) logChange(`Jazz Chord: ${chordName}7 (${scaleName})`, { isGenerative: true });

                const newTracks = [...state.tracks];
                const activeTrackCount = activeTracks.length;
                for(let i=0; i<activeTrackCount; i++) {
                    const track = activeTracks[i];
                    const trackIndex = newTracks.findIndex(t => t.id === track.id);
                    if(trackIndex !== -1) {
                        newTracks[trackIndex] = {...newTracks[trackIndex], note: chordNotes[i % chordNotes.length] };
                    }
                }
                updateState({ ...nextState, tracks: newTracks });

            } else if (presetKey === 'fifths') {
                const scaleParts = state.currentScaleName.split(' ');
                const newRootIndex = (NOTE_NAMES.indexOf(scaleParts[0]) + 7) % 12;
                nextState.currentScaleName = `${NOTE_NAMES[newRootIndex]} ${scaleParts.slice(1).join(' ')}`;
                if(shouldLogGenerativeStep) logChange(`Key Change: ${nextState.currentScaleName}`, { isGenerative: true });
                if (Object.keys(nextState).length > 0) updateState(nextState);

            } else if (presetKey === 'rock') {
                const targetScale = 'Minor Pentatonic';
                if (state.currentScaleName.split(' ').slice(1).join(' ') !== targetScale) {
                    const randomRootNote = Math.floor(Math.random() * 12);
                    nextState.currentScaleName = `${NOTE_NAMES[randomRootNote]} ${targetScale}`;
                    if(shouldLogGenerativeStep) logChange(`${preset.label} Mode: Set scale to ${nextState.currentScaleName}`, { isGenerative: true });
                }
                if (Object.keys(nextState).length > 0) {
                    updateState(nextState);
                    setTimeout(() => randomizeAllTracksForPreset(preset), 50);
                } else {
                    randomizeAllTracksForPreset(preset);
                }
                return;
            } else if (randomizerOptions.scale) {
                const scaleNames = Object.keys(SCALES);
                const randomScaleName = scaleNames[Math.floor(Math.random() * scaleNames.length)];
                const randomRootNote = Math.floor(Math.random() * 12);
                nextState.currentScaleName = `${NOTE_NAMES[randomRootNote]} ${randomScaleName}`;
                if(shouldLogGenerativeStep) logChange(`Scale: ${nextState.currentScaleName}`, { isGenerative: true });
                if (Object.keys(nextState).length > 0) updateState(nextState);
            }

            function randomizeAllTracksForPreset(presetConfig) {
                const assignedNotesByChannel = {};
                activeTracks.forEach(t => randomizeTrackParameters(t, presetConfig.options, shouldLogGenerativeStep, assignedNotesByChannel));
                if (state.musicMode.refine) {
                    setTimeout(() => handleRefine(false), 50);
                }
            }

            const assignedNotesByChannel = {};
            if (preset.multi) {
                activeTracks.forEach(t => randomizeTrackParameters(t, randomizerOptions, shouldLogGenerativeStep, assignedNotesByChannel));
            } else if (preset.options.note || preset.options.pulses || preset.options.rotation || preset.options.velocity) {
                const trackToRandomize = activeTracks[Math.floor(Math.random() * activeTracks.length)];
                randomizeTrackParameters(trackToRandomize, randomizerOptions, shouldLogGenerativeStep, assignedNotesByChannel);
            }

            if (state.musicMode.refine) {
                setTimeout(() => handleRefine(false), 50);
            }
        }

        function setupTimedRandomization() {
            if (timedRandomEvent) {
                Tone.Transport.clear(timedRandomEvent);
                timedRandomEvent = null;
            }
            if (state.musicMode.enabled) {
                const interval = `${state.musicMode.interval}m`;
                timedRandomEvent = Tone.Transport.scheduleRepeat(time => {
                    Tone.Draw.schedule(triggerGenerativeStep, time)
                }, interval, "1m");
                logChange(`Music Mode enabled, randomizing every ${state.musicMode.interval} bars.`);
            } else {
                logChange("Music Mode disabled.");
            }
        }

        function handleMasterRandomize() {
            const options = state.randomization;
            let nextState = {};
            logChange('---', { separator: true });

            if(options.scale) {
                const newOctave = Math.max(2, Math.min(5, state.randomization.octave + (Math.floor(Math.random() * 3) - 1)));
                nextState.randomization = { ...state.randomization, octave: newOctave };
                logChange(`New base octave: ${newOctave}`);

                const scaleNames = Object.keys(SCALES);
                const randomScaleName = scaleNames[Math.floor(Math.random() * scaleNames.length)];
                nextState.currentScaleName = `${NOTE_NAMES[Math.floor(Math.random() * 12)]} ${randomScaleName}`;
                logChange(`Scale: ${nextState.currentScaleName}`);
            }

            if (Object.keys(nextState).length > 0) {
                updateState(nextState);
            }

            const assignedNotesByChannel = {};
            state.tracks.forEach(t => {
                if(t.active) randomizeTrackParameters(t, options, true, assignedNotesByChannel);
            });
            showStatusMessage("All active tracks randomized!", 2500);
        }

        function handleRefine(showStatus = true) {
            const activeTracks = state.tracks.filter(t => t.active);
            if (activeTracks.length < 2) {
                if(showStatus) {
                    logChange("Need at least 2 active tracks to refine.");
                    showStatusMessage("Refinement requires at least 2 active tracks.", 3000);
                }
                return;
            }

            let newTracks = JSON.parse(JSON.stringify(state.tracks));
            let refinementLogs = [];

            // 1. Harmonic Foundation (Anchor to Root)
            const rootNoteMidi = NOTE_NAMES.indexOf(state.currentScaleName.split(' ')[0]);
            let notes = activeTracks.map(t => ({ note: t.note, id: t.id, isRoot: (t.note % 12) === rootNoteMidi }));
            notes.sort((a, b) => a.note - b.note);

            const lowestNote = notes[0];
            if (!lowestNote.isRoot) {
                const rootNoteTrack = notes.find(n => n.isRoot);
                if (rootNoteTrack) {
                    const lowestTrackIndex = newTracks.findIndex(t => t.id === lowestNote.id);
                    const rootTrackIndex = newTracks.findIndex(t => t.id === rootNoteTrack.id);

                    if (lowestTrackIndex !== -1 && rootTrackIndex !== -1) {
                        const originalLowestNote = newTracks[lowestTrackIndex].note;
                        const originalRootNote = newTracks[rootTrackIndex].note;

                        newTracks[lowestTrackIndex].note = originalRootNote;
                        newTracks[rootTrackIndex].note = originalLowestNote;

                        const lowestNoteName = Tone.Frequency(originalLowestNote, 'midi').toNote();
                        const rootNoteName = Tone.Frequency(originalRootNote, 'midi').toNote();

                        refinementLogs.push(`Bass note swap: ${lowestNoteName} ↔ ${rootNoteName}`);
                    }
                } else {
                    const lowestTrackIndex = newTracks.findIndex(t => t.id === lowestNote.id);
                    if (lowestTrackIndex !== -1) {
                        const oldNoteName = Tone.Frequency(newTracks[lowestTrackIndex].note, 'midi').toNote();
                        const currentOctave = Math.floor(newTracks[lowestTrackIndex].note / 12);
                        newTracks[lowestTrackIndex].note = currentOctave * 12 + rootNoteMidi;
                        const newNoteName = Tone.Frequency(newTracks[lowestTrackIndex].note, 'midi').toNote();
                        refinementLogs.push(`Set bass to root: ${oldNoteName} → ${newNoteName}`);
                    }
                }
            }

            // 2. Dissonance Reduction
            let currentNotes = newTracks.filter(t => t.active).map(t => t.note);
            let notesChanged = false;
            for (let i = 0; i < currentNotes.length; i++) {
                for (let j = i + 1; j < currentNotes.length; j++) {
                    const interval = Math.abs(currentNotes[i] - currentNotes[j]) % 12;
                    if (interval === 1) { // Only target minor 2nds
                        const trackToChangeId = newTracks.filter(t => t.active)[j].id;
                        const trackIndex = newTracks.findIndex(t => t.id === trackToChangeId);
                        const oldNote = newTracks[trackIndex].note;

                        let newNote = oldNote + 1;
                        while(!currentRandomizationScale.includes(newNote) && newNote < 127) { newNote++; }

                        if (newNote < 127 && !currentNotes.includes(newNote)) {
                            newTracks[trackIndex].note = newNote;
                            currentNotes[j] = newNote;
                            notesChanged = true;
                            refinementLogs.push(`Resolved dissonance: ${Tone.Frequency(oldNote, 'midi').toNote()} → ${Tone.Frequency(newNote, 'midi').toNote()}`);
                            break;
                        }
                    }
                }
                if(notesChanged) break;
            }

            // 3. Velocity Humanization & Rhythmic Refinement
            const totalPulses = activeTracks.reduce((sum, t) => sum + t.pulses, 0);
            const tweakedRhythms = [];
            const tweakedRotations = [];

            newTracks.forEach(track => {
                if(track.active) {
                    track.velocity = Math.max(20, Math.min(127, track.velocity + Math.floor(Math.random() * 21) - 10));

                    const velocityAdjustment = (1 - (track.pulses / totalPulses)) * 10 - 5;
                    track.velocity = Math.round(Math.max(20, Math.min(127, track.velocity + velocityAdjustment)));

                    if (Math.random() < 0.3) {
                        const oldPulses = track.pulses;
                        track.pulses = Math.max(1, Math.min(track.steps, track.pulses + (Math.random() > 0.5 ? 1 : -1)));
                        if(oldPulses !== track.pulses) tweakedRhythms.push(`T${track.id+1} ${oldPulses}→${track.pulses}p`);
                    }
                    if (Math.random() < 0.2) {
                        const oldRotation = track.rotation;
                        track.rotation = (track.rotation + 1) % track.steps;
                        if(oldRotation !== track.rotation) tweakedRotations.push(`T${track.id+1}`);
                    }
                }
            });

            if (tweakedRhythms.length > 0) refinementLogs.push(`Rhythm tweaks: ${tweakedRhythms.join(', ')}`);
            if (tweakedRotations.length > 0) refinementLogs.push(`Rotation tweaks: ${tweakedRotations.join(', ')}`);

            if (refinementLogs.length > 0) {
                logChange(`Refined: ${refinementLogs.join(' | ')}`);
            } else if (showStatus) {
                logChange("Refined: No changes needed.");
            }

            updateState({ tracks: newTracks });
            if(showStatus) showStatusMessage("Sequence refined!", 2000);
        }

        let lastLogWasMusicModeOff = false;
        function logChange(message, options = {}) {
            if (!dom.musicModeLog) return;

            if (state.musicMode.refine && options.isGenerative) {
                return; // Don't log normal generative steps if auto-refine is on
            }

            if (message === "Music Mode is Off." && lastLogWasMusicModeOff) {
                return;
            }
            lastLogWasMusicModeOff = (message === "Music Mode is Off.");

            const entry = document.createElement('div');
            entry.textContent = message;
            if(options.separator) entry.style.borderTop = "1px solid var(--control-border)";
            dom.musicModeLog.prepend(entry);

            while (dom.musicModeLog.children.length > 12) {
                dom.musicModeLog.removeChild(dom.musicModeLog.lastChild);
            }
        }

        init();
    });
</script>
</body>
</html>
