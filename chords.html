<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Chord Suggester (Multi-Genre)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .custom-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen flex flex-col items-center justify-center p-4">

<div class="bg-slate-800 p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-2xl space-y-6">
    <header class="text-center">
        <h1 class="text-3xl font-bold text-sky-400">MIDI Chord Suggester</h1>
        <p class="text-slate-400 mt-1">Chord & Looping Melody Suggestions Across Genres</p>
    </header>

    <div class="grid grid-cols-1 sm:grid-cols-2 gap-6 mb-6">
        <div>
            <label for="midiInSelect" class="block text-sm font-medium text-sky-300 mb-1">MIDI Input Device:</label>
            <select id="midiInSelect" class="custom-select w-full p-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:ring-sky-500 focus:border-sky-500 text-slate-100">
                <option value="">Select Input</option>
            </select>
        </div>
        <div>
            <label for="channelInSelect" class="block text-sm font-medium text-sky-300 mb-1">Input Channel:</label>
            <select id="channelInSelect" class="custom-select w-full p-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:ring-sky-500 focus:border-sky-500 text-slate-100"></select>
        </div>
        <div>
            <label for="midiOutSelect" class="block text-sm font-medium text-sky-300 mb-1">MIDI Output Device:</label>
            <select id="midiOutSelect" class="custom-select w-full p-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:ring-sky-500 focus:border-sky-500 text-slate-100">
                <option value="">Select Output</option>
            </select>
        </div>
        <div>
            <label for="channelOutSelect" class="block text-sm font-medium text-sky-300 mb-1">Output Channel:</label>
            <select id="channelOutSelect" class="custom-select w-full p-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:ring-sky-500 focus:border-sky-500 text-slate-100"></select>
        </div>
    </div>

    <div class="mb-6">
        <label for="suggestionModeSelect" class="block text-sm font-medium text-sky-300 mb-1">Suggestion Mode:</label>
        <select id="suggestionModeSelect" class="custom-select w-full p-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:ring-sky-500 focus:border-sky-500 text-slate-100">
            <option value="circleOfFifths">Circle of Fifths</option>
            <option value="jazz">Jazz</option>
            <option value="classical">Classical</option>
            <option value="progRock">Prog Rock</option>
            <option value="celtic">Celtic</option>
            <option value="harmoniousMelody">Harmonious Melody</option>
        </select>
    </div>


    <div class="space-y-2 mb-6 text-center">
        <p class="text-sm text-slate-400">The app will suggest chords or melodies based on the selected mode. Chord output plays for a fixed duration. Melody output loops while input chord is held.</p>
    </div>

    <div class="space-y-4">
        <div id="statusDiv" class="p-3 bg-slate-700 rounded-lg text-sm text-center min-h-[40px] flex items-center justify-center">
            Initializing MIDI...
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 text-center">
            <div class="bg-slate-700 p-4 rounded-lg">
                <h3 class="text-lg font-semibold text-sky-400 mb-1">Input Chord:</h3>
                <p id="inputChordDiv" class="text-xl font-mono text-slate-200 min-h-[30px]">-</p>
            </div>
            <div class="bg-slate-700 p-4 rounded-lg">
                <h3 class="text-lg font-semibold text-teal-400 mb-1">Suggested Output:</h3>
                <p id="suggestedOutputDiv" class="text-xl font-mono text-slate-200 min-h-[30px]">-</p>
            </div>
        </div>
    </div>
    <footer class="text-center text-xs text-slate-500 pt-4 border-t border-slate-700">
        Play a Major/Minor triad. App suggests chords or melodies. Settings are saved in cookies.
    </footer>
</div>

<script>
    // --- Cookie Helper Functions ---
    function setCookie(name, value, days) {
        let expires = "";
        if (days) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + (value || "")  + expires + "; path=/; SameSite=Lax";
    }

    function getCookie(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for(let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) === ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    }

    // --- Global State ---
    let midiAccess = null;
    let selectedInputId = null;
    let selectedOutputId = null;
    let selectedInputChannel = 0;
    let selectedOutputChannel = 0;
    let currentSuggestionMode = 'circleOfFifths';

    const activeInputNotes = new Map();
    let lastProcessedInputNotes = []; // Stores the actual MIDI notes of the last processed input chord

    let activePlaybackTimeouts = [];
    let lastScheduledMelodyPattern = null;
    let initialTriggerChordForMelody = null; // Stores the chord that started the current melody loop

    let nextMajorSuggestionIndex = 0;
    let nextMinorSuggestionIndex = 0;

    // --- UI Elements ---
    const midiInSelect = document.getElementById('midiInSelect');
    const midiOutSelect = document.getElementById('midiOutSelect');
    const channelInSelect = document.getElementById('channelInSelect');
    const channelOutSelect = document.getElementById('channelOutSelect');
    const suggestionModeSelect = document.getElementById('suggestionModeSelect');
    const statusDiv = document.getElementById('statusDiv');
    const inputChordDiv = document.getElementById('inputChordDiv');
    const suggestedOutputDiv = document.getElementById('suggestedOutputDiv');

    const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    function noteNumberToName(noteNumber) {
        if (noteNumber < 0 || noteNumber > 127) return '';
        const octave = Math.floor(noteNumber / 12) - 1;
        const name = NOTE_NAMES[noteNumber % 12];
        return name + octave;
    }

    function notesArrayToNames(notes) {
        if (!notes || notes.length === 0) return '-';
        return notes.map(noteNumberToName).join(' ');
    }

    async function setupMIDIAccess() {
        try {
            midiAccess = await navigator.requestMIDIAccess({ sysex: true });
            statusDiv.textContent = 'MIDI Access Granted. Select devices and channels.';
            statusDiv.classList.remove('bg-red-600', 'bg-yellow-500');
            statusDiv.classList.add('bg-green-700');
            populateDeviceSelectors();
            attachEventListenersToSelectors();
        } catch (e) {
            console.error("Could not access MIDI devices.", e);
            statusDiv.textContent = 'Error: Could not access MIDI devices. ' + e.message;
            statusDiv.classList.remove('bg-green-700', 'bg-yellow-500');
            statusDiv.classList.add('bg-red-600');
            if (e.name === 'SecurityError' && e.message.includes('permissions policy')) {
                statusDiv.innerHTML += '<br><small>This might be due to browser/page settings restricting MIDI. Check console (F12).</small>';
            }
        }
    }

    function saveSettingsToCookies() {
        setCookie('midiInputId', selectedInputId, 365);
        setCookie('midiOutputId', selectedOutputId, 365);
        setCookie('midiInputChannel', selectedInputChannel, 365);
        setCookie('midiOutputChannel', selectedOutputChannel, 365);
        setCookie('suggestionMode', currentSuggestionMode, 365);
    }

    function loadSettingsFromCookies() {
        const savedInputId = getCookie('midiInputId');
        const savedOutputId = getCookie('midiOutputId');
        const savedInputChannel = getCookie('midiInputChannel');
        const savedOutputChannel = getCookie('midiOutputChannel');
        const savedSuggestionMode = getCookie('suggestionMode');
        let settingsWereRestored = false;

        if (savedInputId && Array.from(midiInSelect.options).some(opt => opt.value === savedInputId)) {
            selectedInputId = savedInputId; midiInSelect.value = savedInputId; settingsWereRestored = true;
        }
        if (savedOutputId && Array.from(midiOutSelect.options).some(opt => opt.value === savedOutputId)) {
            selectedOutputId = savedOutputId; midiOutSelect.value = savedOutputId; settingsWereRestored = true;
        }
        if (savedInputChannel !== null) {
            selectedInputChannel = parseInt(savedInputChannel); channelInSelect.value = selectedInputChannel + 1; settingsWereRestored = true;
        }
        if (savedOutputChannel !== null) {
            selectedOutputChannel = parseInt(savedOutputChannel); channelOutSelect.value = selectedOutputChannel + 1; settingsWereRestored = true;
        }
        if (savedSuggestionMode) {
            if (Array.from(suggestionModeSelect.options).some(opt => opt.value === savedSuggestionMode)) {
                currentSuggestionMode = savedSuggestionMode; suggestionModeSelect.value = savedSuggestionMode; settingsWereRestored = true;
            } else {
                suggestionModeSelect.value = currentSuggestionMode;
            }
        }

        if (selectedInputId) assignMIDIMessageHandler();

        if (settingsWereRestored) {
            if (!selectedInputId) statusDiv.textContent = "Settings restored. Select input device if needed.";
            else if (!statusDiv.textContent.includes("Listening on")) {
                const cInName = midiInSelect.options[midiInSelect.selectedIndex]?.text || "Unknown";
                const cOutName = midiOutSelect.options[midiOutSelect.selectedIndex]?.text || "Unknown";
                statusDiv.textContent = `Settings Restored: In - ${cInName}, Out - ${cOutName}, Mode - ${currentSuggestionMode.charAt(0).toUpperCase() + currentSuggestionMode.slice(1)}`;
            }
        } else if (selectedInputId || selectedOutputId) {
            const cIn = selectedInputId ? midiInSelect.options[midiInSelect.selectedIndex]?.text : "None";
            const cOut = selectedOutputId ? midiOutSelect.options[midiOutSelect.selectedIndex]?.text : "None";
            statusDiv.textContent = `Auto-selected: In - ${cIn}, Out - ${cOut}, Mode - ${currentSuggestionMode.charAt(0).toUpperCase() + currentSuggestionMode.slice(1)}`;
            if (selectedInputId) assignMIDIMessageHandler();
        } else {
            statusDiv.textContent = `Default Mode: ${currentSuggestionMode.charAt(0).toUpperCase() + currentSuggestionMode.slice(1)}. Select devices.`;
        }
    }

    function populateDeviceSelectors() {
        if (!midiAccess) return;
        midiInSelect.innerHTML = '<option value="">Select Input</option>';
        midiOutSelect.innerHTML = '<option value="">Select Output</option>';
        channelInSelect.innerHTML = ''; channelOutSelect.innerHTML = '';

        if (midiAccess.inputs.size === 0) midiInSelect.add(new Option("No MIDI inputs found", "", false, true)).disabled = true;
        else {
            midiAccess.inputs.forEach(input => midiInSelect.add(new Option(input.name, input.id)));
            if (!selectedInputId) {
                const firstInput = Array.from(midiAccess.inputs.values())[0];
                selectedInputId = firstInput.id; midiInSelect.value = firstInput.id;
            }
        }
        if (midiAccess.outputs.size === 0) midiOutSelect.add(new Option("No MIDI outputs found", "", false, true)).disabled = true;
        else {
            midiAccess.outputs.forEach(output => midiOutSelect.add(new Option(output.name, output.id)));
            if (!selectedOutputId) {
                const firstOutput = Array.from(midiAccess.outputs.values())[0];
                selectedOutputId = firstOutput.id; midiOutSelect.value = firstOutput.id;
            }
        }

        for (let i = 1; i <= 16; i++) {
            channelInSelect.add(new Option(`Channel ${i}`, i));
            channelOutSelect.add(new Option(`Channel ${i}`, i));
        }
        selectedInputChannel = 0; channelInSelect.value = selectedInputChannel + 1;
        selectedOutputChannel = 1; channelOutSelect.value = selectedOutputChannel + 1;
        suggestionModeSelect.value = currentSuggestionMode;

        loadSettingsFromCookies();
    }

    function attachEventListenersToSelectors() {
        midiInSelect.addEventListener('change', (event) => {
            selectedInputId = event.target.value; assignMIDIMessageHandler();
            statusDiv.textContent = selectedInputId && midiInSelect.options[midiInSelect.selectedIndex] ? `Input: ${midiInSelect.options[midiInSelect.selectedIndex].text}` : 'Input device deselected.';
            saveSettingsToCookies();
        });
        midiOutSelect.addEventListener('change', (event) => {
            selectedOutputId = event.target.value;
            statusDiv.textContent = selectedOutputId && midiOutSelect.options[midiOutSelect.selectedIndex] ? `Output: ${midiOutSelect.options[midiOutSelect.selectedIndex].text}` : 'Output device deselected.';
            saveSettingsToCookies();
        });
        channelInSelect.addEventListener('change', (event) => {
            selectedInputChannel = parseInt(event.target.value) - 1;
            statusDiv.textContent = `Input Channel: ${event.target.value}`;
            saveSettingsToCookies();
        });
        channelOutSelect.addEventListener('change', (event) => {
            selectedOutputChannel = parseInt(event.target.value) - 1;
            statusDiv.textContent = `Output Channel: ${event.target.value}`;
            saveSettingsToCookies();
        });
        suggestionModeSelect.addEventListener('change', (event) => {
            currentSuggestionMode = event.target.value;
            nextMajorSuggestionIndex = 0; nextMinorSuggestionIndex = 0;
            statusDiv.textContent = `Suggestion Mode: ${currentSuggestionMode.charAt(0).toUpperCase() + currentSuggestionMode.slice(1)}`;
            saveSettingsToCookies();
            processActiveInputNotes(true);
        });
    }

    function assignMIDIMessageHandler() {
        if (!midiAccess) return;
        midiAccess.inputs.forEach(input => { input.onmidimessage = null; });
        if (!selectedInputId) { activeInputNotes.clear(); processActiveInputNotes(); return; }
        const inputDevice = midiAccess.inputs.get(selectedInputId);
        if (inputDevice) {
            inputDevice.onmidimessage = onMIDIMessage;
            statusDiv.textContent = `Listening on: ${inputDevice.name}`;
        } else {
            statusDiv.textContent = `Failed to assign listener: Input ${selectedInputId} not found.`;
        }
    }

    function onMIDIMessage(event) {
        const command = event.data[0] >> 4, channel = event.data[0] & 0x0f, note = event.data[1], vel = event.data[2] || 0;
        if (channel !== selectedInputChannel) return;
        if (command === 0x9 && vel > 0) activeInputNotes.set(note, vel);
        else if (command === 0x8 || (command === 0x9 && vel === 0)) activeInputNotes.delete(note);
        processActiveInputNotes();
    }

    function processActiveInputNotes(forceReprocess = false) {
        const currentNotesSorted = Array.from(activeInputNotes.keys()).sort((a, b) => a - b);

        // If it's not a forced reprocess and the notes haven't changed, do nothing
        if (!forceReprocess && arraysEqual(currentNotesSorted, lastProcessedInputNotes)) return;

        // If it IS a forced reprocess (e.g. mode change) BUT the notes are the same as last time,
        // AND the mode is harmoniousMelody, we might not want to interrupt a playing loop if the chord didn't change.
        // However, for simplicity now, a mode change will always retrigger.

        const prevHeldChordForMelody = initialTriggerChordForMelody ? [...initialTriggerChordForMelody] : null;

        if (!arraysEqual(currentNotesSorted, lastProcessedInputNotes) || forceReprocess) {
            clearAndStopPlayback(); // Stop previous playback if notes changed or forced
        }

        lastProcessedInputNotes = [...currentNotesSorted];
        inputChordDiv.textContent = notesArrayToNames(currentNotesSorted);

        if (currentNotesSorted.length >= 3) {
            const analyzedChord = analyzeChord(currentNotesSorted);
            if (analyzedChord) {
                inputChordDiv.textContent = analyzedChord.name + " (" + notesArrayToNames(analyzedChord.originalNotes) + ")";
                let suggestionIndex = 0;
                if (currentSuggestionMode !== 'circleOfFifths' && currentSuggestionMode !== 'harmoniousMelody') {
                    if (analyzedChord.quality === 'Major') {
                        suggestionIndex = nextMajorSuggestionIndex;
                        if (forceReprocess) { suggestionIndex = 0; nextMajorSuggestionIndex = 1; }
                        else nextMajorSuggestionIndex = (nextMajorSuggestionIndex + 1) % 4;
                    } else {
                        suggestionIndex = nextMinorSuggestionIndex;
                        if (forceReprocess) { suggestionIndex = 0; nextMinorSuggestionIndex = 1; }
                        else nextMinorSuggestionIndex = (nextMinorSuggestionIndex + 1) % 4;
                    }
                }
                // Store the chord that will trigger the new melody/chord
                initialTriggerChordForMelody = [...currentNotesSorted];

                const suggested = getSuggestedOutput(analyzedChord, suggestionIndex, currentSuggestionMode);
                if (suggested) {
                    suggestedOutputDiv.textContent = suggested.name + " (" + notesArrayToNames(suggested.displayNotes || suggested.notes) + ")";
                    playOutput(suggested, analyzedChord); // Pass analyzedChord for melody looping condition
                } else {
                    suggestedOutputDiv.textContent = '-';
                    initialTriggerChordForMelody = null;
                }
            } else { // Not a recognized triad
                suggestedOutputDiv.textContent = notesArrayToNames(currentNotesSorted);
                initialTriggerChordForMelody = null;
            }
        } else { // Less than 3 notes
            suggestedOutputDiv.textContent = '-';
            initialTriggerChordForMelody = null;
            if (currentNotesSorted.length === 0) lastProcessedInputNotes = [];
        }
    }

    function analyzeChord(notes) {
        if (notes.length < 3) return null;
        const root = notes[0], intervals = notes.slice(1).map(n => n - root);
        const isMajor = intervals.includes(4) && intervals.includes(7);
        if (isMajor && notes.length === 3 && notes.every(n => [root, root + 4, root + 7].includes(n))) {
            return { rootMidi: root, quality: 'Major', name: noteNumberToName(root) + ' Major', originalNotes: notes };
        }
        const isMinor = intervals.includes(3) && intervals.includes(7);
        if (isMinor && notes.length === 3 && notes.every(n => [root, root + 3, root + 7].includes(n))) {
            return { rootMidi: root, quality: 'Minor', name: noteNumberToName(root) + ' Minor', originalNotes: notes };
        }
        return null;
    }

    function getSuggestedOutput(analyzedChord, suggestionIndex, mode) {
        if (!analyzedChord) return null;
        const originalRoot = analyzedChord.rootMidi;
        let suggestedActualRoot, suggestedNotes, suggestedChordName, suggestedQuality, melodyPattern;

        const buildChord = (root, type) => {
            let notes = [];
            switch (type) {
                case 'm7': notes = [root, root + 3, root + 7, root + 10]; break;
                case 'maj7': notes = [root, root + 4, root + 7, root + 11]; break;
                case '7': notes = [root, root + 4, root + 7, root + 10]; break;
                case 'm7b5': notes = [root, root + 3, root + 6, root + 10]; break;
            }
            return notes.filter(n => n >= 0 && n <= 127).sort((a,b) => a-b);
        };

        const findOctave = (rootPitchClass, referenceRoot) => {
            let newRoot = Math.floor(referenceRoot / 12) * 12 + rootPitchClass;
            if (newRoot < referenceRoot - 6 && newRoot < 80 ) newRoot += 12;
            else if (newRoot > referenceRoot + 6 && newRoot > 30) newRoot -=12;
            return Math.max(21, Math.min(108 - 12, newRoot));
        };

        if (mode === 'harmoniousMelody') {
            const root = originalRoot;
            const third = analyzedChord.quality === 'Major' ? root + 4 : root + 3;
            const fifth = root + 7;
            // Using major second as a passing tone for both major/minor for simplicity
            const passingTone = analyzedChord.quality === 'Major' ? root + 2 : root + 2; // D for Cmaj, B for Amin (or D for Amin if Dorian)
            // Let's stick to a simpler passing tone for now.

            const adjustOctaveForMelody = (note, baseOctaveRefNote = originalRoot) => {
                let adjustedNote = note;
                // Try to keep melody notes above or around the original chord's root
                while(adjustedNote < baseOctaveRefNote && adjustedNote < 72) adjustedNote += 12; // Try to push up if too low
                while(adjustedNote > baseOctaveRefNote + 12 && adjustedNote > 48) adjustedNote -=12; // Try to pull down if too high

                // General floor and ceiling
                while(adjustedNote < 48) adjustedNote += 12; // Min C3-ish
                while(adjustedNote > 83) adjustedNote -=12; // Max B5-ish
                return Math.max(36, Math.min(84, adjustedNote));
            };

            const melRoot = adjustOctaveForMelody(root);
            const melThird = adjustOctaveForMelody(third);
            const melFifth = adjustOctaveForMelody(fifth);
            const melPassing = adjustOctaveForMelody(passingTone, melRoot);


            melodyPattern = [ // Simple arpeggio + passing tone
                { note: melFifth, duration: 250, delay: 0 },    // 5th
                { note: melThird, duration: 250, delay: 300 },   // 3rd
                { note: melRoot, duration: 250, delay: 600 },    // Root
                { note: melPassing, duration: 250, delay: 900 }, // Passing
                { note: melRoot, duration: 500, delay: 1200 }   // Root (longer)
            ]; // Total duration approx 1.7s
            suggestedChordName = `Melody for ${analyzedChord.name}`;
            const displayNotesForMelody = [...new Set(melodyPattern.map(item => item.note))].sort((a,b)=>a-b);
            return { name: suggestedChordName, isMelody: true, melodyPattern: melodyPattern, displayNotes: displayNotesForMelody };

        } else if (mode === 'circleOfFifths') {
            suggestedActualRoot = findOctave((originalRoot + 7 + 12) % 12, originalRoot);
            suggestedQuality = '7';
            suggestedChordName = noteNumberToName(suggestedActualRoot) + "7";
        } else if (mode === 'jazz') {
            if (analyzedChord.quality === 'Major') {
                switch (suggestionIndex) {
                    case 0: suggestedActualRoot = findOctave((originalRoot - 3 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7"; break;
                    case 1: suggestedActualRoot = findOctave((originalRoot + 5 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7"; break;
                    case 2: suggestedActualRoot = findOctave((originalRoot + 6 + 12) % 12, originalRoot); suggestedQuality = 'm7b5'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7b5"; break;
                    case 3: suggestedActualRoot = findOctave((originalRoot + 4 + 12) % 12, originalRoot); suggestedQuality = '7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "7 (alt)"; break;
                    default: return null;
                }
            } else if (analyzedChord.quality === 'Minor') {
                switch (suggestionIndex) {
                    case 0: suggestedActualRoot = findOctave((originalRoot + 5 + 12) % 12, originalRoot); suggestedQuality = '7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "7"; break;
                    case 1: suggestedActualRoot = findOctave((originalRoot + 3 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7"; break;
                    case 2: suggestedActualRoot = findOctave((originalRoot - 5 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7"; break;
                    case 3: suggestedActualRoot = findOctave((originalRoot - 2 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7"; break;
                    default: return null;
                }
            } else { return null; }
        } else if (mode === 'classical') {
            if (analyzedChord.quality === 'Major') {
                switch (suggestionIndex) {
                    case 0: suggestedActualRoot = findOctave((originalRoot + 7 + 12) % 12, originalRoot); suggestedQuality = '7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "7 (V7)"; break;
                    case 1: suggestedActualRoot = findOctave((originalRoot + 5 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7 (IV)"; break;
                    case 2: suggestedActualRoot = findOctave((originalRoot + 2 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7 (ii)"; break;
                    case 3: suggestedActualRoot = findOctave((originalRoot - 3 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7 (vi)"; break;
                    default: return null;
                }
            } else if (analyzedChord.quality === 'Minor') {
                switch (suggestionIndex) {
                    case 0: suggestedActualRoot = findOctave((originalRoot + 7 + 12) % 12, originalRoot); suggestedQuality = '7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "7 (V7)"; break;
                    case 1: suggestedActualRoot = findOctave((originalRoot + 5 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7 (iv)"; break;
                    case 2: suggestedActualRoot = findOctave((originalRoot + 3 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7 (III)"; break;
                    case 3: suggestedActualRoot = findOctave((originalRoot - 4 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7 (VI)"; break;
                    default: return null;
                }
            } else { return null; }
        } else if (mode === 'progRock') {
            if (analyzedChord.quality === 'Major') {
                switch (suggestionIndex) {
                    case 0: suggestedActualRoot = findOctave((originalRoot - 2 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7 (bVII)"; break;
                    case 1: suggestedActualRoot = findOctave((originalRoot + 5 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7 (iv)"; break;
                    case 2: suggestedActualRoot = findOctave((originalRoot + 7 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7 (v)"; break;
                    case 3: suggestedActualRoot = findOctave((originalRoot - 4 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7 (bVI)"; break;
                    default: return null;
                }
            } else if (analyzedChord.quality === 'Minor') {
                switch (suggestionIndex) {
                    case 0: suggestedActualRoot = findOctave((originalRoot + 5 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7 (IV)"; break;
                    case 1: suggestedActualRoot = findOctave((originalRoot + 7 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7 (v)"; break;
                    case 2: suggestedActualRoot = findOctave((originalRoot - 2 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7 (bVII)"; break;
                    case 3: suggestedActualRoot = findOctave((originalRoot - 4 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7 (bVI)"; break;
                    default: return null;
                }
            } else { return null; }
        } else if (mode === 'celtic') {
            if (analyzedChord.quality === 'Major') {
                switch (suggestionIndex) {
                    case 0: suggestedActualRoot = findOctave((originalRoot + 5 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7 (IV)"; break;
                    case 1: suggestedActualRoot = findOctave((originalRoot + 7 + 12) % 12, originalRoot); suggestedQuality = '7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "7 (V)"; break;
                    case 2: suggestedActualRoot = findOctave((originalRoot + 2 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7 (ii)"; break;
                    case 3: suggestedActualRoot = findOctave((originalRoot - 3 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7 (vi)"; break;
                    default: return null;
                }
            } else if (analyzedChord.quality === 'Minor') {
                switch (suggestionIndex) {
                    case 0: suggestedActualRoot = findOctave((originalRoot + 5 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7 (IV)"; break;
                    case 1: suggestedActualRoot = findOctave((originalRoot + 7 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7 (v)"; break;
                    case 2: suggestedActualRoot = findOctave((originalRoot - 2 + 12) % 12, originalRoot); suggestedQuality = 'maj7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "maj7 (bVII)"; break;
                    case 3: suggestedActualRoot = findOctave((originalRoot + 0 + 12) % 12, originalRoot); suggestedQuality = 'm7'; suggestedChordName = noteNumberToName(suggestedActualRoot) + "m7 (i)"; break;
                    default: return null;
                }
            } else { return null; }
        } else { return null; }

        suggestedNotes = buildChord(suggestedActualRoot, suggestedQuality);
        if (!suggestedNotes || suggestedNotes.length < 3) return null;

        return {
            rootMidi: suggestedActualRoot, quality: suggestedQuality, name: suggestedChordName,
            notes: suggestedNotes, isMelody: false
        };
    }

    function playOutput(outputObject, triggerMeta, velocity = 90) {
        if (!midiAccess || !selectedOutputId) { console.warn("Cannot play: MIDI setup issue."); return; }
        const outputDevice = midiAccess.outputs.get(selectedOutputId);
        if (!outputDevice) { console.warn("Output device not found."); statusDiv.textContent = "Error: Output device not found."; return; }

        // clearAndStopPlayback() is now called in processActiveInputNotes before playOutput
        // This ensures that when playOutput is called, it's for a new, distinct event.

        if (outputObject.isMelody && outputObject.melodyPattern) {
            const pattern = outputObject.melodyPattern;
            // initialTriggerChordForMelody is already set in processActiveInputNotes
            lastScheduledMelodyPattern = pattern; // For stopping specific notes if cleared early

            let playMelodyIteration;

            playMelodyIteration = () => {
                // Check if the initial triggering chord is still held by comparing with global lastProcessedInputNotes
                if (!arraysEqual(lastProcessedInputNotes, initialTriggerChordForMelody)) {
                    console.log("Melody loop stopped: Initial triggering chord released or changed.");
                    lastScheduledMelodyPattern = null;
                    initialTriggerChordForMelody = null; // Clear the trigger chord
                    return;
                }

                console.log("Playing melody iteration, triggered by:", notesArrayToNames(initialTriggerChordForMelody));
                let maxDelayInPattern = 0;

                pattern.forEach(item => {
                    const noteOnDelay = item.delay;
                    const noteOffDelay = item.delay + item.duration;
                    if (noteOffDelay > maxDelayInPattern) {
                        maxDelayInPattern = noteOffDelay;
                    }

                    const onTimeout = setTimeout(() => {
                        if (!arraysEqual(lastProcessedInputNotes, initialTriggerChordForMelody)) return;
                        outputDevice.send([0x90 | selectedOutputChannel, item.note, velocity]);
                        console.log(`Melody ON: ${noteNumberToName(item.note)} (Ch: ${selectedOutputChannel+1})`);
                    }, noteOnDelay);
                    activePlaybackTimeouts.push(onTimeout);

                    const offTimeout = setTimeout(() => {
                        outputDevice.send([0x80 | selectedOutputChannel, item.note, 0]);
                        console.log(`Melody OFF: ${noteNumberToName(item.note)} (Ch: ${selectedOutputChannel+1})`);
                    }, noteOffDelay);
                    activePlaybackTimeouts.push(offTimeout);
                });

                const loopTimeout = setTimeout(playMelodyIteration, maxDelayInPattern + 100); // 100ms gap before loop
                activePlaybackTimeouts.push(loopTimeout);
            };
            playMelodyIteration(); // Start the first iteration

        } else if (outputObject.notes && outputObject.notes.length > 0) { // It's a chord
            const chordDuration = 1000;
            lastScheduledMelodyPattern = null;
            initialTriggerChordForMelody = null; // Not a melody, so no trigger chord for looping
            console.log(`Sending CHORD notes to ${outputDevice.name} (Mode: ${currentSuggestionMode}): ${notesArrayToNames(outputObject.notes)}`);
            outputObject.notes.forEach(note => {
                outputDevice.send([0x90 | selectedOutputChannel, note, velocity]);
            });

            const chordOffTimeout = setTimeout(() => {
                stopNotes(outputObject.notes, outputDevice, selectedOutputChannel);
            }, chordDuration);
            activePlaybackTimeouts.push(chordOffTimeout);
        }
    }

    function clearAndStopPlayback() {
        console.log("Clearing and stopping playback. Timeouts to clear:", activePlaybackTimeouts.length);
        activePlaybackTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
        activePlaybackTimeouts = [];

        if (lastScheduledMelodyPattern && selectedOutputId && midiAccess) {
            const outputDevice = midiAccess.outputs.get(selectedOutputId);
            if (outputDevice) {
                console.log("Sending note-offs for last scheduled melody pattern.");
                const uniqueNotesInPattern = [...new Set(lastScheduledMelodyPattern.map(item => item.note))];
                stopNotes(uniqueNotesInPattern, outputDevice, selectedOutputChannel);
            }
        }
        lastScheduledMelodyPattern = null;
        // initialTriggerChordForMelody is cleared in processActiveInputNotes or when a chord is played
    }

    function stopNotes(notesToStop, device, channel) {
        if (!device || !notesToStop || notesToStop.length === 0) return;
        notesToStop.forEach(note => {
            device.send([0x80 | channel, note, 0]);
        });
    }

    function arraysEqual(a, b) {
        if (a === b) return true;
        if (a == null || b == null) return false;
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; ++i) {
            if (a[i] !== b[i]) return false;
        }
        return true;
    }

    document.addEventListener('DOMContentLoaded', setupMIDIAccess);
</script>
</body>
</html>
