<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xenon - Vector Command</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #00f3ff;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* UI OVERLAY */
        #overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            padding: 40px;
            text-align: center;
            background: rgba(0, 10, 20, 0.95);
            border: 1px solid #00f3ff;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2), inset 0 0 50px rgba(0, 0, 0, 0.9);
            clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
            backdrop-filter: blur(8px);
            max-width: 500px;
            width: 90%;
            transition: opacity 0.5s ease;
        }

        h1 {
            font-size: 1.8rem;
            margin: 0 0 10px 0;
            color: #fff;
            text-shadow: 0 0 10px #00f3ff;
            text-transform: uppercase;
            letter-spacing: 6px;
        }

        h2 {
            font-size: 0.8rem;
            color: #00f3ff;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 30px;
            border-bottom: 1px solid rgba(0, 243, 255, 0.3);
            display: inline-block;
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid rgba(0, 243, 255, 0.2);
            background: rgba(0, 20, 40, 0.5);
        }

        .btn {
            background: rgba(0, 243, 255, 0.1);
            color: #00f3ff;
            font-family: inherit;
            font-size: 1.0rem;
            font-weight: 700;
            padding: 15px 30px;
            border: 1px solid #00f3ff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s ease;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.1);
            width: 100%;
            margin-top: 10px;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }

        .btn:hover { background: #00f3ff; color: #000; box-shadow: 0 0 25px rgba(0, 243, 255, 0.6); }

        #fileInput { display: none; }

        /* Recording UI */
        #recordContainer {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            display: none;
            flex-direction: row;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .rec-btn {
            padding: 10px 20px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            font-size: 0.7rem;
            letter-spacing: 1px;
            transition: all 0.2s;
            clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px);
        }

        #recordButton { background: #ff0055; color: white; min-width: 150px; }
        #recordButton:hover { background: #ff3377; }
        #recordButton.recording { animation: pulseAlert 1s infinite; }
        #leaveButton { background: rgba(0, 243, 255, 0.2); color: #00f3ff; border: 1px solid #00f3ff; }
        #leaveButton:hover { background: #00f3ff; color: #000; }

        @keyframes pulseAlert {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(255, 0, 85, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0); }
        }

        #fullscreenBtn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 35px;
            height: 35px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00f3ff;
            color: #00f3ff;
            font-size: 18px;
            cursor: pointer;
            z-index: 150;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        #fullscreenBtn:hover { background: #00f3ff; color: #000; }
        #message { margin-top: 15px; color: #00f3ff; font-size: 0.8rem; min-height: 1.2em; }
        .checkbox-wrapper { display: flex; align-items: center; justify-content: center; gap: 10px; color: #81d4fa; margin-top: 15px; font-size: 0.8rem;}
        input[type="checkbox"] { accent-color: #00f3ff; cursor: pointer; }

        .vignette {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 40%, #000 100%);
            z-index: 5;
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<button id="fullscreenBtn" title="Toggle Fullscreen">â›¶</button>

<div id="recordContainer">
    <button id="recordButton" class="rec-btn">Init Record</button>
    <button id="leaveButton" class="rec-btn">Abort</button>
</div>

<div id="overlay">
    <h1>Xenon Interface</h1>
    <h2>Vector Command Module</h2>
    <div class="control-group">
        <p style="margin-top:0; color:#00f3ff; font-size: 0.75rem; letter-spacing: 1px; margin-bottom: 15px;">INPUT NAVIGATION DATA</p>
        <button id="selectFileBtn" class="btn">Load Audio File</button>
        <input type="file" id="fileInput" accept="audio/*">
    </div>

    <div class="checkbox-wrapper">
        <input type="checkbox" id="record4k">
        <label for="record4k">Hi-Res Capture (4K)</label>
    </div>

    <div class="checkbox-wrapper">
        <input type="checkbox" id="autoRecord">
        <label for="autoRecord">Auto-Log Flight</label>
    </div>

    <div id="message"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<!-- FRAGMENT SHADER: HYPERSPACE BG -->
<script type="x-shader/x-fragment" id="fragShader">
    uniform float uTime;
    uniform vec2 uResolution;
    uniform float uBass;
    uniform float uMid;
    uniform float uHigh;
    uniform float uFade;

    #define PI 3.14159265359

    // COOLER PALETTE (Cyan, Magenta, Blue - Reduced Yellow potential)
    vec3 palette( in float t ) {
        vec3 a = vec3(0.5, 0.5, 0.5);
        vec3 b = vec3(0.5, 0.5, 0.5);
        vec3 c = vec3(1.0, 1.0, 1.0);
        vec3 d = vec3(0.263, 0.416, 0.557); // Cool Neon Palette
        return a + b*cos( 6.28318*(c*t+d) );
    }

    mat2 rot(float a) {
        float s = sin(a);
        float c = cos(a);
        return mat2(c, -s, s, c);
    }

    void main() {
        if (uFade >= 1.0) {
            gl_FragColor = vec4(0.0, 0.05, 0.1, 1.0);
            return;
        }

        vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.y;

        float r = length(uv);
        float a = atan(uv.y, uv.x);
        float z = 1.0 / (r + 0.01);
        float speed = uTime * 4.0 + (uBass * 2.0);

        vec3 finalColor = vec3(0.0);

        for(float i = 0.0; i < 2.0; i++) {
            vec2 p = vec2(z * 0.5 + speed * 0.2, a);
            float cloud = sin(p.x * 5.0) * sin(p.y * 5.0 + i * 3.0);
            cloud += sin(p.x * 10.0 + uTime) * 0.5;
            float depth = 0.1 / abs(cloud + 0.1);
            vec3 col = palette(z * 0.1 + i * 0.2 + uBass * 0.1);

            // Rebalance channels to favor cool colors
            col.r *= 0.8; // Reduce red slightly
            col.b += uHigh * 0.5; // Boost blue

            finalColor += col * depth * (r * r);
        }

        float streaks = sin(z * 20.0 + speed * 5.0) * sin(a * 10.0);
        streaks = smoothstep(0.8, 1.0, streaks);
        finalColor += vec3(0.8, 0.9, 1.0) * streaks * uHigh;

        // --- EDGE COLOR CORRECTION ---
        // Reduce Green and Red mixing at edges to kill Yellow
        float edgeDeYellow = smoothstep(0.5, 1.5, r);
        finalColor.g *= 1.0 - (edgeDeYellow * 0.8); // Kill Green at edges
        finalColor.r *= 1.0 - (edgeDeYellow * 0.4); // Dampen Red
        finalColor.b += edgeDeYellow * 0.2;         // Boost Blue

        // Center darken (Minimal to show center)
        finalColor *= smoothstep(0.0, 0.05, r);

        // Edge Vignette
        finalColor *= 1.0 - smoothstep(1.0, 2.2, r);

        vec3 fadeColor = vec3(0.0, 0.02, 0.05);
        finalColor = mix(finalColor, fadeColor, uFade);

        gl_FragColor = vec4(finalColor, 1.0);
    }
</script>

<script>
    (function(){
        // --- CONFIG & STATE ---
        let audioContext, analyser, dataArray, sourceNode;
        let renderer, sceneBG, cameraBG, materialBG, meshBG;
        let scene3D, camera3D;
        let sceneHUD, cameraHUD; // HUD Overlay Scene
        let hudCanvas, hudCtx, hudTexture;
        let isRunning = false;
        let currentAudioFile = null;

        // 3D HUD Objects
        let shipWireframe, planetWireframe, tunnelRings = [];
        let shipCoreMesh;
        let centerSpinner;
        let currentShapeIdx = 0;

        // Morphing State
        let morphState = {
            active: false,
            start: 0,
            duration: 10.0,
            oldMesh: null,
            newMesh: null
        };

        // Audio State
        let smoothBass = 0, smoothMid = 0, smoothHigh = 0;
        let lastVolume = 0;

        // Fading State
        let isFading = false;
        let fadeStartTime = 0;
        let fadeCompleteTime = 0;
        const FADE_DURATION = 3.0;
        const END_BUFFER = 1.0;

        // Recording
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let was4k = false;

        const container = document.getElementById('canvas-container');
        const overlay = document.getElementById('overlay');
        const fileInput = document.getElementById('fileInput');
        const selectFileBtn = document.getElementById('selectFileBtn');
        const messageDiv = document.getElementById('message');
        const recordBtn = document.getElementById('recordButton');
        const leaveBtn = document.getElementById('leaveButton');
        const recordContainer = document.getElementById('recordContainer');
        const autoRecordCheck = document.getElementById('autoRecord');
        const record4kCheck = document.getElementById('record4k');
        const fullscreenBtn = document.getElementById('fullscreenBtn');

        // --- THREE.JS SETUP ---
        function initThree() {
            if (renderer) { container.innerHTML = ''; }

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, preserveDrawingBuffer: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            container.appendChild(renderer.domElement);

            // 1. BG Scene (Hyperdrive)
            sceneBG = new THREE.Scene();
            cameraBG = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
            const geometry = new THREE.PlaneGeometry(2, 2);
            materialBG = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uBass: { value: 0.0 },
                    uMid: { value: 0.0 },
                    uHigh: { value: 0.0 },
                    uFade: { value: 0.0 }
                },
                fragmentShader: document.getElementById('fragShader').textContent,
                depthWrite: false
            });
            meshBG = new THREE.Mesh(geometry, materialBG);
            sceneBG.add(meshBG);

            // 2. 3D Scene (Vector Graphics)
            scene3D = new THREE.Scene();
            camera3D = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera3D.position.z = 10;
            create3DInterface();

            // 3. HUD Scene (2D Overlay via Canvas)
            hudCanvas = document.createElement('canvas');
            hudCanvas.width = window.innerWidth;
            hudCanvas.height = window.innerHeight;
            hudCtx = hudCanvas.getContext('2d');
            hudTexture = new THREE.CanvasTexture(hudCanvas);
            hudTexture.minFilter = THREE.LinearFilter;

            sceneHUD = new THREE.Scene();
            cameraHUD = new THREE.OrthographicCamera(-window.innerWidth/2, window.innerWidth/2, window.innerHeight/2, -window.innerHeight/2, 0, 30);
            const hudPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(window.innerWidth, window.innerHeight),
                new THREE.MeshBasicMaterial({ map: hudTexture, transparent: true })
            );
            sceneHUD.add(hudPlane);

            container.addEventListener("webglcontextlost", (event) => { event.preventDefault(); resetUI(); }, false);
            container.addEventListener("webglcontextrestored", initThree, false);
            window.addEventListener('resize', onResize);
            onResize();
        }

        function create3DInterface() {
            const wireMat = new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.6 });
            const alertMat = new THREE.LineBasicMaterial({ color: 0xff0055, transparent: true, opacity: 0.8 });

            // 1. MORPHING SHIP (Left)
            const shipGroup = new THREE.Group();

            const coreGeo = new THREE.IcosahedronGeometry(1, 0);
            const coreMat = new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.6 });
            shipCoreMesh = new THREE.LineSegments(new THREE.WireframeGeometry(coreGeo), coreMat);
            shipGroup.add(shipCoreMesh);

            const ringGeo = new THREE.TorusGeometry(1.6, 0.05, 4, 32);
            const ring = new THREE.LineSegments(new THREE.WireframeGeometry(ringGeo), wireMat);
            ring.rotation.x = Math.PI / 2;
            shipGroup.add(ring);

            shipGroup.position.set(-5, -3, 0);
            shipGroup.rotation.y = 0.5;
            scene3D.add(shipGroup);
            shipWireframe = shipGroup;

            // 2. TACTICAL PLANET (Right)
            const planetGroup = new THREE.Group();
            const planetGeo = new THREE.SphereGeometry(1.5, 16, 16);
            const planet = new THREE.LineSegments(new THREE.WireframeGeometry(planetGeo), alertMat);
            planetGroup.add(planet);
            const orbitGeo = new THREE.TorusGeometry(2.2, 0.02, 4, 64);
            const orbit = new THREE.Line(new THREE.WireframeGeometry(orbitGeo), wireMat);
            orbit.rotation.x = Math.PI / 2.3;
            planetGroup.add(orbit);

            planetGroup.position.set(5, -3, 0);
            scene3D.add(planetGroup);
            planetWireframe = planetGroup;

            // 3. TUNNEL
            tunnelRings = [];
            const baseTunnelGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(4.0, 4.0));

            for(let i=0; i<40; i++) {
                const frameMat = new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.0 });
                const frame1 = new THREE.LineSegments(baseTunnelGeo, frameMat);
                const frame2 = new THREE.LineSegments(baseTunnelGeo, frameMat);
                frame2.rotation.z = Math.PI / 4;

                const tunnelGroup = new THREE.Group();
                tunnelGroup.add(frame1);
                tunnelGroup.add(frame2);

                tunnelGroup.position.z = - (i * 3);
                scene3D.add(tunnelGroup);
                tunnelRings.push(tunnelGroup);
            }

            // 4. CENTER SPINNER (NEW)
            const spinnerGroup = new THREE.Group();

            // Core Crystal
            const spinGeo = new THREE.OctahedronGeometry(0.3, 0);
            const spinMat = new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.9 });
            const spinMesh = new THREE.LineSegments(new THREE.WireframeGeometry(spinGeo), spinMat);

            // Gyroscope Ring
            const spinRingGeo = new THREE.TorusGeometry(0.5, 0.01, 2, 32); // Thin vector ring
            const spinRingMesh = new THREE.LineSegments(new THREE.WireframeGeometry(spinRingGeo), wireMat);
            spinRingMesh.rotation.x = Math.PI / 2;

            spinnerGroup.add(spinMesh);
            spinnerGroup.add(spinRingMesh);

            spinnerGroup.position.z = 0; // Absolute center
            scene3D.add(spinnerGroup);
            centerSpinner = spinnerGroup;
        }

        // --- CENTRALIZED LAYOUT UPDATE ---
        function update3DLayout() {
            if (!camera3D) return;
            const vFOV = THREE.MathUtils.degToRad(camera3D.fov);
            const distance = camera3D.position.z;
            const heightAtZero = 2 * Math.tan(vFOV / 2) * distance;
            const widthAtZero = heightAtZero * camera3D.aspect;

            if (shipWireframe) {
                shipWireframe.position.x = (-widthAtZero / 2.5);
                shipWireframe.position.y = -heightAtZero/4;
            }
            if (planetWireframe) {
                planetWireframe.position.x = (widthAtZero / 2.5);
                planetWireframe.position.y = -heightAtZero/4;
            }
        }

        // --- CENTRALIZED RESIZING LOGIC ---
        function resizeApp(w, h, updateStyle = true) {
            if (!renderer) return;

            renderer.setSize(w, h, updateStyle);

            hudCanvas.width = w;
            hudCanvas.height = h;

            if(sceneHUD && sceneHUD.children[0]) {
                sceneHUD.children[0].geometry.dispose();
                sceneHUD.children[0].geometry = new THREE.PlaneGeometry(w, h);
            }
            if(cameraHUD) {
                cameraHUD.left = -w/2;
                cameraHUD.right = w/2;
                cameraHUD.top = h/2;
                cameraHUD.bottom = -h/2;
                cameraHUD.updateProjectionMatrix();
            }

            if(materialBG) {
                const drawingSize = new THREE.Vector2();
                renderer.getDrawingBufferSize(drawingSize);
                materialBG.uniforms.uResolution.value.x = drawingSize.x;
                materialBG.uniforms.uResolution.value.y = drawingSize.y;
            }

            if(camera3D) {
                camera3D.aspect = w / h;
                camera3D.updateProjectionMatrix();
            }

            update3DLayout();
        }

        function onResize() {
            if(isRecording && was4k) return;
            resizeApp(window.innerWidth, window.innerHeight, true);
        }

        // --- HUD DRAWING (CANVAS 2D) ---
        function drawHUD(bass, mid, high, time, stats) {
            if(!hudCtx) return;
            const w = hudCanvas.width;
            const h = hudCanvas.height;
            const ctx = hudCtx;

            ctx.clearRect(0, 0, w, h);
            const scale = (w / 1920);
            const s = Math.max(scale, 0.6);

            // Base Styles
            ctx.strokeStyle = "#00f3ff";
            ctx.lineWidth = 1.5 * s;

            const fillPanel = () => {
                ctx.fillStyle = "rgba(0, 5, 15, 0.85)";
                ctx.fill();
                ctx.stroke();
            };

            const applyTextStyle = (size = 11, color = "#00f3ff") => {
                ctx.font = `bold ${size * s}px 'Courier New'`;
                ctx.fillStyle = color;
                ctx.shadowColor = "black";
                ctx.shadowBlur = 4 * s;
                ctx.shadowOffsetX = 2 * s;
                ctx.shadowOffsetY = 2 * s;
            };

            const resetShadow = () => {
                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            };

            // --- TOP BAR ---
            // Left
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.lineTo(300*s, 0); ctx.lineTo(300*s, 20*s); ctx.lineTo(260*s, 50*s); ctx.lineTo(0, 50*s); ctx.closePath();
            fillPanel();

            applyTextStyle(14, "#fff");
            ctx.fillText("USS XENON", 15*s, 30*s);
            resetShadow();
            ctx.restore();

            // Right
            ctx.save();
            ctx.translate(w, 0);
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.lineTo(-200*s, 0); ctx.lineTo(-200*s, 50*s); ctx.lineTo(-40*s, 50*s); ctx.lineTo(0, 20*s); ctx.closePath();
            fillPanel();

            applyTextStyle(12, "#00f3ff");
            ctx.fillText(`T-${Math.floor(time/60).toString().padStart(2,'0')}:${Math.floor(time%60).toString().padStart(2,'0')}`, -140*s, 30*s);
            resetShadow();
            ctx.restore();

            // --- LEFT PANEL ---
            ctx.save();
            ctx.translate(0, h/2 - 300*s);
            // Frame
            ctx.beginPath();
            ctx.moveTo(0, 0); ctx.lineTo(100*s, 0); ctx.lineTo(140*s, 40*s); ctx.lineTo(140*s, 500*s); ctx.lineTo(100*s, 540*s); ctx.lineTo(0, 540*s); ctx.closePath();
            fillPanel();

            // Bars
            ctx.translate(20*s, 80*s);

            applyTextStyle(11, "#00f3ff");
            ctx.fillText("THRUSTER_L", 0, -15*s);
            resetShadow();
            ctx.strokeRect(0, 0, 15*s, 150*s);
            ctx.fillStyle = "#00f3ff";
            ctx.globalAlpha = 0.6;
            ctx.fillRect(2*s, (150*s) - (150*s * bass), 11*s, (150*s * bass));

            ctx.globalAlpha = 1.0;
            applyTextStyle(11, "#00f3ff");
            ctx.fillText("THRUSTER_R", 60*s, -15*s);
            resetShadow();
            ctx.strokeRect(60*s, 0, 15*s, 150*s);
            ctx.fillStyle = "#00f3ff";
            ctx.globalAlpha = 0.6;
            ctx.fillRect(62*s, (150*s) - (150*s * mid), 11*s, (150*s * mid));

            // Text
            ctx.translate(0, 270*s);
            ctx.globalAlpha = 1.0;
            applyTextStyle(11, "#00f3ff");
            ctx.fillText("GEOMETRY_SCAN", 0, 0);

            applyTextStyle(14, "#fff");
            let shapeName = ["ICOSAHEDRON", "OCTAHEDRON", "DODECAHEDRON", "TETRAHEDRON"][currentShapeIdx];
            ctx.fillText(shapeName, 0, 20*s);
            resetShadow();
            ctx.restore();

            // --- RIGHT PANEL ---
            ctx.save();
            ctx.translate(w, h/2 - 300*s);
            ctx.beginPath();
            ctx.moveTo(0,0); ctx.lineTo(-100*s,0); ctx.lineTo(-140*s,40*s); ctx.lineTo(-140*s,500*s); ctx.lineTo(-100*s,540*s); ctx.lineTo(0,540*s); ctx.closePath();
            fillPanel();

            ctx.translate(-120*s, 80*s);
            applyTextStyle(11, "#00f3ff");
            ctx.fillText("SENSOR_ARRAY", 0, -15*s);
            resetShadow();

            ctx.fillStyle = "#00f3ff";
            ctx.globalAlpha = 0.4;
            ctx.fillRect(0, 0, (20 + bass * 80)*s, 8*s);
            ctx.fillRect(0, 15*s, (20 + mid * 80)*s, 8*s);
            ctx.fillRect(0, 30*s, (20 + high * 80)*s, 8*s);

            ctx.translate(0, 80*s);
            ctx.globalAlpha = 1.0;
            applyTextStyle(9, "#00f3ff");
            ctx.fillText("OUTPUT_LEVEL", 0, 0);

            applyTextStyle(11, "#00f3ff");
            if(stats) ctx.fillText(stats.db.toFixed(1) + " dB", 0, 15*s);

            ctx.translate(0, 45*s);
            applyTextStyle(9, "#00f3ff");
            ctx.fillText("RESONANCE", 0, 0);

            applyTextStyle(11, "#00f3ff");
            if(stats) ctx.fillText(Math.round(stats.hz) + " Hz", 0, 15*s);

            ctx.translate(0, 45*s);
            applyTextStyle(9, "#00f3ff");
            ctx.fillText("SIGNAL FLUX", 0, 0);

            applyTextStyle(11, "#00f3ff");
            if(stats) {
                if(stats.flux > 0.1) {
                    ctx.fillStyle = "#ff0055";
                    ctx.fillText("VOLATILE", 0, 15*s);
                } else {
                    ctx.fillText("STABLE", 0, 15*s);
                }
            }
            resetShadow();
            ctx.restore();

            // --- BOTTOM BAR ---
            ctx.save();
            ctx.translate(w/2, h - 60*s);
            const bw = w * 0.4;
            ctx.beginPath();
            ctx.moveTo(-bw/2, 40*s); ctx.lineTo(-bw/2, 20*s); ctx.lineTo(-bw/2 + 20*s, 0); ctx.lineTo(bw/2 - 20*s, 0); ctx.lineTo(bw/2, 20*s); ctx.lineTo(bw/2, 40*s);
            fillPanel();

            applyTextStyle(11, "#00f3ff");
            ctx.textAlign = "center";
            ctx.fillText("SYSTEM: ONLINE", 0, 25*s);
            resetShadow();
            ctx.restore();

            // --- CENTER RETICLE ---
            ctx.save();
            ctx.translate(w/2, h/2);
            ctx.strokeStyle = "#00f3ff";
            ctx.lineWidth = 0.5 * s;
            ctx.globalAlpha = 0.2;
            ctx.beginPath(); ctx.arc(0, 0, 80*s, 0, Math.PI*2); ctx.stroke();
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 1.5 * s;
            ctx.beginPath(); ctx.moveTo(-20*s, 0); ctx.lineTo(20*s, 0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, -20*s); ctx.lineTo(0, 20*s); ctx.stroke();
            ctx.restore();

            hudTexture.needsUpdate = true;
        }

        // --- SMOOTH MORPHING LOGIC ---
        function updateMorphing(time) {
            if (!morphState.active) {
                morphState.active = true;
                morphState.start = time;
                morphState.oldMesh = shipCoreMesh;

                currentShapeIdx = (currentShapeIdx + 1) % 4;
                let newGeo;

                switch(currentShapeIdx) {
                    case 0: newGeo = new THREE.IcosahedronGeometry(1, 0); break;
                    case 1: newGeo = new THREE.OctahedronGeometry(1, 0); break;
                    case 2: newGeo = new THREE.DodecahedronGeometry(1, 0); break;
                    case 3: newGeo = new THREE.TetrahedronGeometry(1, 0); break;
                }

                const wireGeo = new THREE.WireframeGeometry(newGeo);
                newGeo.dispose();

                const mat = new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.0 });
                morphState.newMesh = new THREE.LineSegments(wireGeo, mat);
                morphState.newMesh.scale.setScalar(0.5);

                shipWireframe.add(morphState.newMesh);
            }

            if (morphState.active) {
                const progress = (time - morphState.start) / morphState.duration;

                if (progress >= 1.0) {
                    morphState.active = false;

                    if (morphState.oldMesh) {
                        morphState.oldMesh.geometry.dispose();
                        morphState.oldMesh.material.dispose();
                        shipWireframe.remove(morphState.oldMesh);
                    }

                    shipCoreMesh = morphState.newMesh;
                    shipCoreMesh.material.opacity = 0.6;
                    shipCoreMesh.scale.setScalar(1.0);

                } else {
                    if (morphState.oldMesh) {
                        morphState.oldMesh.material.opacity = 0.6 * (1.0 - progress);
                        morphState.oldMesh.scale.setScalar(1.0 - (0.5 * progress));
                        morphState.oldMesh.rotation.y -= 0.01;
                        morphState.oldMesh.rotation.x += 0.005;
                    }
                    if (morphState.newMesh) {
                        morphState.newMesh.material.opacity = 0.6 * progress;
                        morphState.newMesh.scale.setScalar(0.5 + (0.5 * progress));
                        morphState.newMesh.rotation.y += 0.01;
                        morphState.newMesh.rotation.x -= 0.005;
                    }
                }
            }
        }

        function initAudio() {
            if(!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            } else if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function getAudioData() {
            if(!analyser) return { bass:0, mid:0, high:0, stats: {db: -100, hz: 0, flux: 0} };
            analyser.getByteFrequencyData(dataArray);

            const len = dataArray.length;
            const avg = (start, end) => {
                let sum = 0;
                for(let i=start; i<end; i++) sum += dataArray[i];
                return sum / (end-start);
            };

            let sumSq = 0;
            let peakVal = 0;
            let peakIdx = 0;
            for(let i=0; i<len; i++) {
                const val = dataArray[i] / 255.0;
                sumSq += val * val;
                if(dataArray[i] > peakVal) {
                    peakVal = dataArray[i];
                    peakIdx = i;
                }
            }

            const rms = Math.sqrt(sumSq / len);
            let db = 20 * Math.log10(rms);
            if (!isFinite(db)) db = -100;

            const hz = peakIdx * (audioContext.sampleRate / analyser.fftSize);
            const flux = Math.abs(rms - lastVolume);
            lastVolume = rms;

            return {
                bass: avg(0, 10) / 255,
                mid: avg(10, 80) / 255,
                high: avg(80, 200) / 255,
                stats: { db, hz, flux }
            };
        }

        // --- ANIMATION ---
        let lastFrameTime = 0;
        let animationFrameId;

        function animate(time) {
            if(!isRunning && !isFading) return;

            const currentTimeSec = time / 1000;
            const deltaTime = (time - lastFrameTime) / 1000;
            lastFrameTime = time;

            if (isFading) {
                const fadeProgress = (currentTimeSec - fadeStartTime) / FADE_DURATION;
                if (fadeProgress >= 1.0) {
                    materialBG.uniforms.uFade.value = 1.0;

                    if (fadeCompleteTime === 0) fadeCompleteTime = currentTimeSec;

                    renderer.clear();
                    renderer.render(sceneBG, cameraBG);

                    if (currentTimeSec - fadeCompleteTime >= END_BUFFER) {
                        resetUI();
                        return;
                    }

                    animationFrameId = requestAnimationFrame(animate);
                    return;
                }
                materialBG.uniforms.uFade.value = fadeProgress;
            }

            const data = getAudioData();
            smoothBass += (data.bass - smoothBass) * 0.1;
            smoothMid += (data.mid - smoothMid) * 0.1;
            smoothHigh += (data.high - smoothHigh) * 0.1;

            materialBG.uniforms.uTime.value = currentTimeSec;
            materialBG.uniforms.uBass.value = smoothBass;
            materialBG.uniforms.uMid.value = smoothMid;
            materialBG.uniforms.uHigh.value = smoothHigh;

            if(shipWireframe) {
                shipWireframe.rotation.x += deltaTime * 0.5;
                shipWireframe.rotation.y += deltaTime * 0.2;
                if(shipCoreMesh) shipCoreMesh.rotation.y -= deltaTime;
                updateMorphing(currentTimeSec);
            }

            if(planetWireframe) {
                planetWireframe.rotation.y -= deltaTime;
                planetWireframe.children[0].material.opacity = 0.5 + smoothHigh;
            }

            // Spinner Logic
            if(centerSpinner) {
                // Rotate entire group
                centerSpinner.rotation.z -= deltaTime * 0.5;
                // Rotate internal core faster
                if(centerSpinner.children[0]) {
                    centerSpinner.children[0].rotation.y += deltaTime * 2;
                    centerSpinner.children[0].rotation.x += deltaTime;
                    // Pulse core with High frequencies (snare/hats)
                    const pulse = 1.0 + (smoothHigh * 0.5);
                    centerSpinner.children[0].scale.setScalar(pulse);
                }
                // Rotate outer ring counter
                if(centerSpinner.children[1]) {
                    centerSpinner.children[1].rotation.x += deltaTime * 0.2;
                }
            }

            const baseHue = (currentTimeSec * 0.05) % 1.0;

            tunnelRings.forEach((ring, i) => {
                ring.position.z += deltaTime * (6 + smoothBass * 8);
                ring.rotation.z += deltaTime * (i%2==0 ? 0.1 : -0.1);

                const spinSpeed = 0.4 + (i * 0.02) + (smoothMid * 0.5);
                if (ring.children[0]) ring.children[0].rotation.z += deltaTime * spinSpeed;
                if (ring.children[1]) ring.children[1].rotation.z -= deltaTime * spinSpeed;

                if(ring.position.z > 5) {
                    ring.position.z -= 120;
                }

                ring.scale.setScalar(1.0);

                const z = ring.position.z;

                let opacity = 0;
                if (z < -115) opacity = 0;
                else if (z < -100) opacity = (z + 115) / 15;
                else if (z < -10) opacity = 1.0;
                else opacity = (2 - z) / 12;

                opacity = Math.max(0, Math.min(1, opacity));

                const hue = (baseHue + (i * 0.02) + (smoothBass * 0.1)) % 1.0;
                const saturation = 0.8;
                const lightness = 0.5 + (smoothHigh * 0.4);

                const ringColor = new THREE.Color().setHSL(hue, saturation, lightness);

                ring.children.forEach(child => {
                    if(child.material) {
                        child.material.opacity = opacity * 0.8;
                        child.material.color.copy(ringColor);
                    }
                });
            });

            drawHUD(smoothBass, smoothMid, smoothHigh, currentTimeSec, data.stats);

            renderer.clear();
            renderer.render(sceneBG, cameraBG);
            renderer.clearDepth();
            renderer.render(scene3D, camera3D);
            renderer.clearDepth();
            renderer.render(sceneHUD, cameraHUD);

            animationFrameId = requestAnimationFrame(animate);
        }

        // --- FILE HANDLING & UTILS ---
        selectFileBtn.onclick = () => { initAudio(); fileInput.value = ''; fileInput.click(); };

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if(!file) return;
            currentAudioFile = file;
            messageDiv.innerText = "ENGAGING HYPERDRIVE...";
            const reader = new FileReader();
            reader.onload = async (ev) => {
                try {
                    const audioBuffer = await audioContext.decodeAudioData(ev.target.result);
                    await startVisualizer(audioBuffer);
                } catch(err) {
                    messageDiv.innerText = "SYSTEM FAILURE: " + err.message;
                }
            };
            reader.readAsArrayBuffer(file);
        };

        async function startVisualizer(buffer) {
            if (audioContext.state === 'suspended') await audioContext.resume();
            if(sourceNode) { try { sourceNode.onended = null; sourceNode.disconnect(); sourceNode.stop(); } catch(e) {} }

            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = buffer;
            sourceNode.connect(analyser);
            analyser.connect(audioContext.destination);
            sourceNode.onended = () => { if (isRunning) triggerFadeOut(); };
            sourceNode.start(0);

            overlay.style.opacity = 0;
            setTimeout(() => overlay.style.display = 'none', 800);
            recordContainer.style.display = 'flex';
            setTimeout(() => recordContainer.style.opacity = 1, 10);

            isRunning = true;
            isFading = false;
            fadeCompleteTime = 0;
            materialBG.uniforms.uFade.value = 0.0;
            lastFrameTime = performance.now();
            smoothBass = 0; smoothMid = 0; smoothHigh = 0;

            onResize();

            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animate(lastFrameTime);
            if(autoRecordCheck.checked) setTimeout(toggleRecord, 800);
        }

        function triggerFadeOut() {
            if (!isRunning || isFading) return;
            isFading = true;
            fadeStartTime = performance.now() / 1000;
            fadeCompleteTime = 0;
        }

        function resetUI() {
            isRunning = false;
            isFading = false;
            fadeCompleteTime = 0;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if(isRecording) toggleRecord();
            overlay.style.display = 'block';
            setTimeout(() => overlay.style.opacity = 1, 10);
            recordContainer.style.opacity = 0;
            setTimeout(() => recordContainer.style.display = 'none', 500);
            if(sourceNode) { try { sourceNode.onended = null; sourceNode.disconnect(); } catch(e){} }
        }

        leaveBtn.onclick = () => { if(sourceNode) { try { sourceNode.stop(); } catch(e){} } resetUI(); };
        recordBtn.onclick = toggleRecord;

        function toggleRecord() {
            if(isRecording) {
                try { mediaRecorder.stop(); } catch(e){}
                isRecording = false;
                recordBtn.innerText = "Init Record";
                recordBtn.classList.remove('recording');
                if (was4k) {
                    resizeApp(window.innerWidth, window.innerHeight, true);
                    was4k = false;
                }
            } else {
                if (record4kCheck.checked) {
                    was4k = true;
                    resizeApp(3840, 2160, false);
                }
                const stream = renderer.domElement.captureStream(60);
                const dest = audioContext.createMediaStreamDestination();
                sourceNode.connect(dest);
                const tracks = [...stream.getVideoTracks(), ...dest.stream.getAudioTracks()];
                try { mediaRecorder = new MediaRecorder(new MediaStream(tracks), { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 15000000 }); }
                catch (e) { try { mediaRecorder = new MediaRecorder(new MediaStream(tracks)); } catch (e2) { messageDiv.innerText = "Recording not supported"; return; } }
                mediaRecorder.ondataavailable = (e) => { if(e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = saveVideo;
                recordedChunks = [];
                mediaRecorder.start();
                isRecording = true;
                recordBtn.innerText = "Stop Rec";
                recordBtn.classList.add('recording');
            }
        }

        function saveVideo() {
            if (recordedChunks.length === 0) return;
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = currentAudioFile ? `xenon-flight-${currentAudioFile.name.split('.')[0]}.webm` : 'xenon-flight.webm';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 100);
        }

        fullscreenBtn.onclick = () => {
            if (!document.fullscreenElement) { document.body.requestFullscreen(); fullscreenBtn.innerHTML = "ðŸ¡¼"; }
            else { document.exitFullscreen(); fullscreenBtn.innerHTML = "â›¶"; }
        };

        initThree();
    })();
</script>
</body>
</html>