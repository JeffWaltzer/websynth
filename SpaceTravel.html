<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xenon - Vector Command</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #00f3ff;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* --- COMPACT MODULAR HUD LAYOUT --- */
        #hud-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            display: grid;
            grid-template-columns: 175px 1fr 175px;
            grid-template-rows: 70px 1fr 70px;
            grid-template-areas:
                "top-left top-mid top-right"
                "side-left center side-right"
                "bot-left bot-mid bot-right";
        }

        /* Panel Positioning */
        .hud-panel { position: relative; width: 100%; height: 100%; overflow: visible; }
        .area-top { grid-area: top-left; grid-column: 1 / -1; display: flex; justify-content: space-between; align-items: flex-start; }
        .area-left { grid-area: side-left; display: flex; align-items: center; justify-content: flex-start; }
        .area-right { grid-area: side-right; display: flex; align-items: center; justify-content: flex-end; }
        .area-bottom { grid-area: bot-mid; display: flex; align-items: flex-end; justify-content: center; grid-column: 1 / -1; }
        .area-center { grid-area: center; display: flex; align-items: center; justify-content: center; }

        /* SVG Styles */
        .hud-svg { overflow: visible; width: 100%; height: 100%; }
        .hud-line { fill: none; stroke: #00f3ff; stroke-width: 1.5; opacity: 0.8; vector-effect: non-scaling-stroke; }
        .hud-thin { fill: none; stroke: #00f3ff; stroke-width: 0.5; opacity: 0.4; vector-effect: non-scaling-stroke; }
        .hud-fill { fill: #00f3ff; opacity: 0.15; }
        .hud-text { fill: #00f3ff; font-size: 11px; font-weight: bold; letter-spacing: 1px; }
        .hud-text-sm { fill: #00f3ff; font-size: 9px; font-weight: normal; letter-spacing: 0px; opacity: 0.8; }
        .hud-text-lg { fill: #fff; font-size: 14px; letter-spacing: 3px; text-shadow: 0 0 5px #00f3ff; }

        /* UI OVERLAY */
        #overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            padding: 40px;
            text-align: center;
            background: rgba(0, 10, 20, 0.9);
            border: 1px solid #00f3ff;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2), inset 0 0 50px rgba(0, 0, 0, 0.8);
            clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
            backdrop-filter: blur(8px);
            max-width: 500px;
            width: 90%;
            transition: opacity 0.5s ease;
        }

        h1 {
            font-size: 1.8rem;
            margin: 0 0 10px 0;
            color: #fff;
            text-shadow: 0 0 10px #00f3ff;
            text-transform: uppercase;
            letter-spacing: 6px;
        }

        h2 {
            font-size: 0.8rem;
            color: #00f3ff;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 30px;
            border-bottom: 1px solid rgba(0, 243, 255, 0.3);
            display: inline-block;
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid rgba(0, 243, 255, 0.2);
            background: rgba(0, 20, 40, 0.5);
        }

        .btn {
            background: rgba(0, 243, 255, 0.1);
            color: #00f3ff;
            font-family: inherit;
            font-size: 1.0rem;
            font-weight: 700;
            padding: 15px 30px;
            border: 1px solid #00f3ff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s ease;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.1);
            width: 100%;
            margin-top: 10px;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }

        .btn:hover { background: #00f3ff; color: #000; box-shadow: 0 0 25px rgba(0, 243, 255, 0.6); }

        #fileInput { display: none; }

        /* Recording UI */
        #recordContainer {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            display: none;
            flex-direction: row;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .rec-btn {
            padding: 10px 20px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            font-size: 0.7rem;
            letter-spacing: 1px;
            transition: all 0.2s;
            clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px);
        }

        #recordButton { background: #ff0055; color: white; min-width: 150px; }
        #recordButton:hover { background: #ff3377; }
        #recordButton.recording { animation: pulseAlert 1s infinite; }
        #leaveButton { background: rgba(0, 243, 255, 0.2); color: #00f3ff; border: 1px solid #00f3ff; }
        #leaveButton:hover { background: #00f3ff; color: #000; }

        @keyframes pulseAlert {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(255, 0, 85, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0); }
        }

        #fullscreenBtn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 35px;
            height: 35px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00f3ff;
            color: #00f3ff;
            font-size: 18px;
            cursor: pointer;
            z-index: 150;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        #fullscreenBtn:hover { background: #00f3ff; color: #000; }
        #message { margin-top: 15px; color: #00f3ff; font-size: 0.8rem; min-height: 1.2em; }
        .checkbox-wrapper { display: flex; align-items: center; justify-content: center; gap: 10px; color: #81d4fa; margin-top: 15px; font-size: 0.8rem;}
        input[type="checkbox"] { accent-color: #00f3ff; cursor: pointer; }

        .vignette {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 40%, #000 100%);
            z-index: 5;
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 3px 100%;
            z-index: 6;
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>
<div class="vignette"></div>
<div class="scanlines"></div>

<!-- RESPONSIVE MODULAR HUD -->
<div id="hud-container">

    <!-- TOP BAR -->
    <div class="hud-panel area-top">
        <!-- Top Left -->
        <svg class="hud-svg" style="width: 300px; height: 100%;">
            <path d="M0,0 L300,0 L300,20 L260,50 L0,50 Z" class="hud-fill"/>
            <path d="M0,50 L260,50 L300,20 L300,0" class="hud-line"/>
            <text x="15" y="30" class="hud-text-lg">USS XENON</text>
        </svg>

        <!-- Top Right -->
        <svg class="hud-svg" style="width: 200px; height: 100%; margin-right: 50px;">
            <path d="M0,0 L200,0 L200,50 L0,50 L40,20 L40,0 Z" class="hud-fill"/>
            <path d="M40,0 L40,20 L0,50 L200,50" class="hud-line"/>
            <text x="60" y="30" class="hud-text" id="clock-display">T-00:00</text>
        </svg>
    </div>

    <!-- LEFT PANEL (Engine Stats) -->
    <div class="hud-panel area-left">
        <svg class="hud-svg" viewBox="0 0 175 600" preserveAspectRatio="xMinYMid meet">
            <path d="M0,0 L100,0 L140,40 L140,500 L100,540 L0,540 Z" class="hud-fill"/>
            <path d="M100,0 L140,40 L140,500 L100,540" class="hud-line"/>

            <!-- Bars -->
            <g transform="translate(20, 80)">
                <text x="0" y="-15" class="hud-text">THRUSTER_L</text>
                <rect x="0" y="0" width="15" height="150" class="hud-thin"/>
                <rect id="bar-thrust-l" x="2" y="150" width="11" height="0" fill="#00f3ff" opacity="0.6"/>

                <text x="60" y="-15" class="hud-text">THRUSTER_R</text>
                <rect x="60" y="0" width="15" height="150" class="hud-thin"/>
                <rect id="bar-thrust-r" x="62" y="150" width="11" height="0" fill="#00f3ff" opacity="0.6"/>
            </g>

            <g transform="translate(20, 350)">
                <text x="0" y="0" class="hud-text">GEOMETRY_SCAN</text>
                <text x="0" y="20" class="hud-text-lg" id="shield-val">SCANNING...</text>
            </g>
        </svg>
    </div>

    <!-- RIGHT PANEL (Detailed Music Stats) -->
    <div class="hud-panel area-right">
        <svg class="hud-svg" viewBox="0 0 175 600" preserveAspectRatio="xMaxYMid meet">
            <g transform="translate(35,0)">
                <path d="M140,0 L40,0 L0,40 L0,500 L40,540 L140,540 Z" class="hud-fill"/>
                <path d="M40,0 L0,40 L0,500 L40,540" class="hud-line"/>

                <g transform="translate(20, 80)">
                    <text x="0" y="-15" class="hud-text">SENSOR_ARRAY</text>

                    <!-- Spectral Bars -->
                    <rect id="bar-spec-1" x="0" y="0" width="80" height="8" fill="#00f3ff" opacity="0.4"/>
                    <rect id="bar-spec-2" x="0" y="15" width="60" height="8" fill="#00f3ff" opacity="0.4"/>
                    <rect id="bar-spec-3" x="0" y="30" width="90" height="8" fill="#00f3ff" opacity="0.4"/>

                    <!-- New Statistics -->
                    <g transform="translate(0, 80)">
                        <text x="0" y="0" class="hud-text-sm">OUTPUT_LEVEL</text>
                        <text x="0" y="15" class="hud-text" id="stat-db">- inf dB</text>

                        <text x="0" y="45" class="hud-text-sm">RESONANCE</text>
                        <text x="0" y="60" class="hud-text" id="stat-hz">0 Hz</text>

                        <text x="0" y="90" class="hud-text-sm">SIGNAL FLUX</text>
                        <text x="0" y="105" class="hud-text" id="stat-flux">STABLE</text>
                    </g>
                </g>
            </g>
        </svg>
    </div>

    <!-- BOTTOM FRAME -->
    <div class="hud-panel area-bottom">
        <svg class="hud-svg" style="width: 100%; height: 60px;">
            <g transform="translate(0, 20)">
                <rect x="30%" y="0" width="40%" height="40" class="hud-fill"/>
                <line x1="30%" y1="0" x2="70%" y2="0" class="hud-line"/>
                <line x1="30%" y1="0" x2="28%" y2="40" class="hud-line"/>
                <line x1="70%" y1="0" x2="72%" y2="40" class="hud-line"/>
                <text x="50%" y="25" class="hud-text" text-anchor="middle" style="letter-spacing:5px;">SYSTEM: ONLINE</text>
            </g>
        </svg>
    </div>

    <!-- CENTER RETICLE -->
    <div class="hud-panel area-center">
        <svg class="hud-svg" viewBox="-100 -100 200 200" style="width: 300px; height: 300px;">
            <circle cx="0" cy="0" r="80" class="hud-thin" stroke-dasharray="10 20" opacity="0.2"/>
            <line x1="-20" y1="0" x2="20" y2="0" class="hud-line" opacity="0.5"/>
            <line x1="0" y1="-20" x2="0" y2="20" class="hud-line" opacity="0.5"/>
        </svg>
    </div>
</div>

<button id="fullscreenBtn" title="Toggle Fullscreen">â›¶</button>

<div id="recordContainer">
    <button id="recordButton" class="rec-btn">Init Record</button>
    <button id="leaveButton" class="rec-btn">Abort</button>
</div>

<div id="overlay">
    <h1>Xenon Interface</h1>
    <h2>Vector Command Module</h2>
    <div class="control-group">
        <p style="margin-top:0; color:#00f3ff; font-size: 0.75rem; letter-spacing: 1px; margin-bottom: 15px;">INPUT NAVIGATION DATA</p>
        <button id="selectFileBtn" class="btn">Load Audio File</button>
        <input type="file" id="fileInput" accept="audio/*">
    </div>

    <div class="checkbox-wrapper">
        <input type="checkbox" id="record4k">
        <label for="record4k">Hi-Res Capture (4K)</label>
    </div>

    <div class="checkbox-wrapper">
        <input type="checkbox" id="autoRecord">
        <label for="autoRecord">Auto-Log Flight</label>
    </div>

    <div id="message"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<!-- FRAGMENT SHADER: HYPERSPACE BG -->
<script type="x-shader/x-fragment" id="fragShader">
    uniform float uTime;
    uniform vec2 uResolution;
    uniform float uBass;
    uniform float uMid;
    uniform float uHigh;
    uniform float uFade;

    #define PI 3.14159265359

    vec3 palette( in float t ) {
        vec3 a = vec3(0.5, 0.5, 0.5);
        vec3 b = vec3(0.5, 0.5, 0.5);
        vec3 c = vec3(1.0, 1.0, 1.0);
        vec3 d = vec3(0.80, 0.90, 0.30);
        return a + b*cos( 6.28318*(c*t+d) );
    }

    mat2 rot(float a) {
        float s = sin(a);
        float c = cos(a);
        return mat2(c, -s, s, c);
    }

    void main() {
        if (uFade >= 1.0) {
            gl_FragColor = vec4(0.0, 0.05, 0.1, 1.0);
            return;
        }

        vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.y;

        float r = length(uv);
        float a = atan(uv.y, uv.x);
        float z = 1.0 / (r + 0.01);
        float speed = uTime * 4.0 + (uBass * 2.0);

        vec3 finalColor = vec3(0.0);

        for(float i = 0.0; i < 2.0; i++) {
            vec2 p = vec2(z * 0.5 + speed * 0.2, a);
            float cloud = sin(p.x * 5.0) * sin(p.y * 5.0 + i * 3.0);
            cloud += sin(p.x * 10.0 + uTime) * 0.5;
            float depth = 0.1 / abs(cloud + 0.1);
            vec3 col = palette(z * 0.1 + i * 0.2 + uBass * 0.1);
            col.r += uBass * 0.4;
            col.g += uMid * 0.3;
            col.b += uHigh * 0.8;
            finalColor += col * depth * (r * r);
        }

        float streaks = sin(z * 20.0 + speed * 5.0) * sin(a * 10.0);
        streaks = smoothstep(0.8, 1.0, streaks);
        finalColor += vec3(0.8, 0.9, 1.0) * streaks * uHigh;

        finalColor *= smoothstep(0.0, 0.4, r);

        vec3 fadeColor = vec3(0.0, 0.02, 0.05);
        finalColor = mix(finalColor, fadeColor, uFade);

        gl_FragColor = vec4(finalColor, 1.0);
    }
</script>

<script>
    (function(){
        // --- CONFIG & STATE ---
        let audioContext, analyser, dataArray, sourceNode;
        let renderer, sceneBG, cameraBG, materialBG, meshBG;
        let scene3D, camera3D;
        let isRunning = false;
        let currentAudioFile = null;

        // 3D HUD Objects
        let shipWireframe, planetWireframe, tunnelRings = [];
        let shipCoreMesh; // Separate ref for the core shape
        let currentShapeIdx = 0;

        // Morphing State
        let morphState = {
            active: false,
            start: 0,
            duration: 10.0, // SLOW SMOOTH TRANSITION
            oldMesh: null,
            newMesh: null
        };

        // Audio State
        let smoothBass = 0, smoothMid = 0, smoothHigh = 0;
        let lastVolume = 0;

        // Fading State
        let isFading = false;
        let fadeStartTime = 0;
        const FADE_DURATION = 3.0;

        // Recording
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let was4k = false;

        // DOM Elements
        const barThrustL = document.getElementById('bar-thrust-l');
        const barThrustR = document.getElementById('bar-thrust-r');
        const shieldVal = document.getElementById('shield-val');
        const clockDisplay = document.getElementById('clock-display');
        const statDb = document.getElementById('stat-db');
        const statHz = document.getElementById('stat-hz');
        const statFlux = document.getElementById('stat-flux');
        const specBars = [
            document.getElementById('bar-spec-1'),
            document.getElementById('bar-spec-2'),
            document.getElementById('bar-spec-3')
        ];

        const container = document.getElementById('canvas-container');
        const overlay = document.getElementById('overlay');
        const fileInput = document.getElementById('fileInput');
        const selectFileBtn = document.getElementById('selectFileBtn');
        const messageDiv = document.getElementById('message');
        const recordBtn = document.getElementById('recordButton');
        const leaveBtn = document.getElementById('leaveButton');
        const recordContainer = document.getElementById('recordContainer');
        const autoRecordCheck = document.getElementById('autoRecord');
        const record4kCheck = document.getElementById('record4k');
        const fullscreenBtn = document.getElementById('fullscreenBtn');

        // --- THREE.JS SETUP ---
        function initThree() {
            if (renderer) { container.innerHTML = ''; }

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, preserveDrawingBuffer: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            container.appendChild(renderer.domElement);

            sceneBG = new THREE.Scene();
            cameraBG = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
            const geometry = new THREE.PlaneGeometry(2, 2);
            materialBG = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uBass: { value: 0.0 },
                    uMid: { value: 0.0 },
                    uHigh: { value: 0.0 },
                    uFade: { value: 0.0 }
                },
                fragmentShader: document.getElementById('fragShader').textContent,
                depthWrite: false
            });
            meshBG = new THREE.Mesh(geometry, materialBG);
            sceneBG.add(meshBG);

            scene3D = new THREE.Scene();
            camera3D = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera3D.position.z = 10;

            create3DInterface();

            container.addEventListener("webglcontextlost", (event) => { event.preventDefault(); resetUI(); }, false);
            container.addEventListener("webglcontextrestored", initThree, false);
            window.addEventListener('resize', onResize);
            onResize();
        }

        function create3DInterface() {
            const wireMat = new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.6 });
            const alertMat = new THREE.LineBasicMaterial({ color: 0xff0055, transparent: true, opacity: 0.8 });

            // 1. MORPHING SHIP (Left)
            const shipGroup = new THREE.Group();

            // Initial Core with dedicated material for fading
            const coreGeo = new THREE.IcosahedronGeometry(1, 0);
            const coreMat = new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.6 });
            shipCoreMesh = new THREE.LineSegments(new THREE.WireframeGeometry(coreGeo), coreMat);
            shipGroup.add(shipCoreMesh);

            // Fixed Ring
            const ringGeo = new THREE.TorusGeometry(1.6, 0.05, 4, 32);
            const ring = new THREE.LineSegments(new THREE.WireframeGeometry(ringGeo), wireMat);
            ring.rotation.x = Math.PI / 2;
            shipGroup.add(ring);

            shipGroup.position.set(-6, -3, 0);
            shipGroup.rotation.y = 0.5;
            scene3D.add(shipGroup);
            shipWireframe = shipGroup;

            // 2. TACTICAL PLANET (Right)
            const planetGroup = new THREE.Group();
            const planetGeo = new THREE.SphereGeometry(1.5, 16, 16);
            const planet = new THREE.LineSegments(new THREE.WireframeGeometry(planetGeo), alertMat);
            planetGroup.add(planet);
            const orbitGeo = new THREE.TorusGeometry(2.2, 0.02, 4, 64);
            const orbit = new THREE.Line(new THREE.WireframeGeometry(orbitGeo), wireMat);
            orbit.rotation.x = Math.PI / 2.3;
            planetGroup.add(orbit);

            planetGroup.position.set(6, -3, 0);
            scene3D.add(planetGroup);
            planetWireframe = planetGroup;

            // 3. TUNNEL
            tunnelRings = [];
            for(let i=0; i<6; i++) {
                const tunnelGeo = new THREE.OctahedronGeometry(1 + i*0.5, 0);
                const tunnelRing = new THREE.LineSegments(new THREE.WireframeGeometry(tunnelGeo), new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.3 - (i*0.05) }));
                tunnelRing.position.z = -10 - (i * 5);
                scene3D.add(tunnelRing);
                tunnelRings.push(tunnelRing);
            }
        }

        function onResize() {
            if(isRecording && was4k) return;
            const w = window.innerWidth;
            const h = window.innerHeight;

            renderer.setSize(w, h);
            materialBG.uniforms.uResolution.value.x = w;
            materialBG.uniforms.uResolution.value.y = h;

            camera3D.aspect = w / h;
            camera3D.updateProjectionMatrix();

            const vFOV = THREE.MathUtils.degToRad(camera3D.fov);
            const distance = camera3D.position.z;
            const heightAtZero = 2 * Math.tan(vFOV / 2) * distance;
            const widthAtZero = heightAtZero * camera3D.aspect;

            if (shipWireframe) {
                shipWireframe.position.x = (-widthAtZero / 2) + 4;
                shipWireframe.position.y = -heightAtZero/4;
            }
            if (planetWireframe) {
                planetWireframe.position.x = (widthAtZero / 2) - 4;
                planetWireframe.position.y = -heightAtZero/4;
            }
        }

        // --- SMOOTH MORPHING LOGIC ---
        function updateMorphing(time) {
            // Trigger new morph if idle
            if (!morphState.active) {
                morphState.active = true;
                morphState.start = time;
                morphState.oldMesh = shipCoreMesh;

                // Advance Shape
                currentShapeIdx = (currentShapeIdx + 1) % 4;
                let newGeo;
                const shapeName = ["ICOSAHEDRON", "OCTAHEDRON", "DODECAHEDRON", "TETRAHEDRON"][currentShapeIdx];

                switch(currentShapeIdx) {
                    case 0: newGeo = new THREE.IcosahedronGeometry(1, 0); break;
                    case 1: newGeo = new THREE.OctahedronGeometry(1, 0); break;
                    case 2: newGeo = new THREE.DodecahedronGeometry(1, 0); break;
                    case 3: newGeo = new THREE.TetrahedronGeometry(1, 0); break;
                }

                // Create new mesh (hidden initially)
                const wireGeo = new THREE.WireframeGeometry(newGeo);
                newGeo.dispose(); // Cleanup prim

                const mat = new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.0 });
                morphState.newMesh = new THREE.LineSegments(wireGeo, mat);
                morphState.newMesh.scale.setScalar(0.5); // Start small

                shipWireframe.add(morphState.newMesh);

                // Update label mid-transition
                setTimeout(() => { if(shieldVal) shieldVal.textContent = shapeName; }, morphState.duration * 500);
            }

            // Animate Transition
            if (morphState.active) {
                const progress = (time - morphState.start) / morphState.duration;

                if (progress >= 1.0) {
                    // FINISHED
                    morphState.active = false;

                    // Cleanup old
                    if (morphState.oldMesh) {
                        morphState.oldMesh.geometry.dispose();
                        morphState.oldMesh.material.dispose();
                        shipWireframe.remove(morphState.oldMesh);
                    }

                    // Promote new
                    shipCoreMesh = morphState.newMesh;
                    shipCoreMesh.material.opacity = 0.6;
                    shipCoreMesh.scale.setScalar(1.0);

                } else {
                    // INTERPOLATE
                    // Old fades out and shrinks
                    if (morphState.oldMesh) {
                        morphState.oldMesh.material.opacity = 0.6 * (1.0 - progress);
                        morphState.oldMesh.scale.setScalar(1.0 - (0.5 * progress));
                        morphState.oldMesh.rotation.y -= 0.01;
                        morphState.oldMesh.rotation.x += 0.005;
                    }

                    // New fades in and grows
                    if (morphState.newMesh) {
                        morphState.newMesh.material.opacity = 0.6 * progress;
                        morphState.newMesh.scale.setScalar(0.5 + (0.5 * progress));
                        morphState.newMesh.rotation.y += 0.01;
                        morphState.newMesh.rotation.x -= 0.005;
                    }
                }
            }
        }

        function updateSVG(bass, mid, high, time, stats) {
            const heightL = 150 * bass;
            const heightR = 150 * mid;
            barThrustL.setAttribute('height', heightL);
            barThrustL.setAttribute('y', 150 - heightL);
            barThrustR.setAttribute('height', heightR);
            barThrustR.setAttribute('y', 150 - heightR);

            specBars.forEach((bar, i) => {
                const val = (i % 2 === 0) ? bass : high;
                bar.setAttribute('width', 20 + val * 80);
            });

            if(stats) {
                statDb.textContent = stats.db.toFixed(1) + " dB";
                statHz.textContent = Math.round(stats.hz) + " Hz";
                statFlux.textContent = stats.flux > 0.1 ? "VOLATILE" : "STABLE";
                statFlux.setAttribute('fill', stats.flux > 0.1 ? "#ff0055" : "#00f3ff");
            }

            const mins = Math.floor(time / 60).toString().padStart(2, '0');
            const secs = Math.floor(time % 60).toString().padStart(2, '0');
            clockDisplay.textContent = `T-${mins}:${secs}`;
        }

        function initAudio() {
            if(!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            } else if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function getAudioData() {
            if(!analyser) return { bass:0, mid:0, high:0, stats: {db: -100, hz: 0, flux: 0} };
            analyser.getByteFrequencyData(dataArray);

            const len = dataArray.length;
            const avg = (start, end) => {
                let sum = 0;
                for(let i=start; i<end; i++) sum += dataArray[i];
                return sum / (end-start);
            };

            let sumSq = 0;
            let peakVal = 0;
            let peakIdx = 0;
            for(let i=0; i<len; i++) {
                const val = dataArray[i] / 255.0;
                sumSq += val * val;
                if(dataArray[i] > peakVal) {
                    peakVal = dataArray[i];
                    peakIdx = i;
                }
            }

            const rms = Math.sqrt(sumSq / len);
            let db = 20 * Math.log10(rms);
            if (!isFinite(db)) db = -100;

            const hz = peakIdx * (audioContext.sampleRate / analyser.fftSize);
            const flux = Math.abs(rms - lastVolume);
            lastVolume = rms;

            return {
                bass: avg(0, 10) / 255,
                mid: avg(10, 80) / 255,
                high: avg(80, 200) / 255,
                stats: { db, hz, flux }
            };
        }

        // --- ANIMATION ---
        let lastFrameTime = 0;
        let animationFrameId;

        function animate(time) {
            if(!isRunning && !isFading) return;

            const currentTimeSec = time / 1000;
            const deltaTime = (time - lastFrameTime) / 1000;
            lastFrameTime = time;

            if (isFading) {
                const fadeProgress = (currentTimeSec - fadeStartTime) / FADE_DURATION;
                if (fadeProgress >= 1.0) {
                    materialBG.uniforms.uFade.value = 1.0;
                    renderer.clear();
                    renderer.render(sceneBG, cameraBG);
                    resetUI();
                    return;
                }
                materialBG.uniforms.uFade.value = fadeProgress;
            }

            const data = getAudioData();
            smoothBass += (data.bass - smoothBass) * 0.15;
            smoothMid += (data.mid - smoothMid) * 0.15;
            smoothHigh += (data.high - smoothHigh) * 0.15;

            materialBG.uniforms.uTime.value = currentTimeSec;
            materialBG.uniforms.uBass.value = smoothBass;
            materialBG.uniforms.uMid.value = smoothMid;
            materialBG.uniforms.uHigh.value = smoothHigh;

            // Handle Ship
            if(shipWireframe) {
                shipWireframe.rotation.x += deltaTime * 0.5;
                shipWireframe.rotation.y += deltaTime * 0.2;
                // Run continuous smooth morph
                updateMorphing(currentTimeSec);
            }

            if(planetWireframe) {
                planetWireframe.rotation.y -= deltaTime;
                planetWireframe.children[0].material.opacity = 0.5 + smoothHigh;
            }

            tunnelRings.forEach((ring, i) => {
                ring.position.z += deltaTime * (5 + smoothBass * 10);
                ring.rotation.z += deltaTime * (i%2==0 ? 1 : -1);
                if(ring.position.z > 5) {
                    ring.position.z = -25;
                }
            });

            updateSVG(smoothBass, smoothMid, smoothHigh, currentTimeSec, data.stats);

            renderer.clear();
            renderer.render(sceneBG, cameraBG);
            renderer.clearDepth();
            renderer.render(scene3D, camera3D);

            animationFrameId = requestAnimationFrame(animate);
        }

        // --- FILE HANDLING & UTILS ---
        selectFileBtn.onclick = () => { initAudio(); fileInput.value = ''; fileInput.click(); };

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if(!file) return;
            currentAudioFile = file;
            messageDiv.innerText = "ENGAGING HYPERDRIVE...";
            const reader = new FileReader();
            reader.onload = async (ev) => {
                try {
                    const audioBuffer = await audioContext.decodeAudioData(ev.target.result);
                    await startVisualizer(audioBuffer);
                } catch(err) {
                    messageDiv.innerText = "SYSTEM FAILURE: " + err.message;
                }
            };
            reader.readAsArrayBuffer(file);
        };

        async function startVisualizer(buffer) {
            if (audioContext.state === 'suspended') await audioContext.resume();
            if(sourceNode) { try { sourceNode.onended = null; sourceNode.disconnect(); sourceNode.stop(); } catch(e) {} }

            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = buffer;
            sourceNode.connect(analyser);
            analyser.connect(audioContext.destination);
            sourceNode.onended = () => { if (isRunning) triggerFadeOut(); };
            sourceNode.start(0);

            overlay.style.opacity = 0;
            setTimeout(() => overlay.style.display = 'none', 800);
            recordContainer.style.display = 'flex';
            setTimeout(() => recordContainer.style.opacity = 1, 10);

            isRunning = true;
            isFading = false;
            materialBG.uniforms.uFade.value = 0.0;
            lastFrameTime = performance.now();
            smoothBass = 0; smoothMid = 0; smoothHigh = 0;

            onResize();

            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animate(lastFrameTime);
            if(autoRecordCheck.checked) setTimeout(toggleRecord, 800);
        }

        function triggerFadeOut() {
            if (!isRunning || isFading) return;
            isFading = true;
            fadeStartTime = performance.now() / 1000;
        }

        function resetUI() {
            isRunning = false;
            isFading = false;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if(isRecording) toggleRecord();
            overlay.style.display = 'block';
            setTimeout(() => overlay.style.opacity = 1, 10);
            recordContainer.style.opacity = 0;
            setTimeout(() => recordContainer.style.display = 'none', 500);
            if(sourceNode) { try { sourceNode.onended = null; sourceNode.disconnect(); } catch(e){} }
        }

        leaveBtn.onclick = () => { if(sourceNode) { try { sourceNode.stop(); } catch(e){} } resetUI(); };
        recordBtn.onclick = toggleRecord;

        function toggleRecord() {
            if(isRecording) {
                try { mediaRecorder.stop(); } catch(e){}
                isRecording = false;
                recordBtn.innerText = "Init Record";
                recordBtn.classList.remove('recording');
                if (was4k) {
                    renderer.setSize(window.innerWidth, window.innerHeight, true);
                    materialBG.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
                    camera3D.aspect = window.innerWidth / window.innerHeight;
                    camera3D.updateProjectionMatrix();
                    was4k = false;
                }
            } else {
                if (record4kCheck.checked) {
                    was4k = true;
                    renderer.setSize(3840, 2160, false);
                    materialBG.uniforms.uResolution.value.set(3840, 2160);
                    camera3D.aspect = 3840 / 2160;
                    camera3D.updateProjectionMatrix();
                }
                const stream = renderer.domElement.captureStream(60);
                const dest = audioContext.createMediaStreamDestination();
                sourceNode.connect(dest);
                const tracks = [...stream.getVideoTracks(), ...dest.stream.getAudioTracks()];
                try { mediaRecorder = new MediaRecorder(new MediaStream(tracks), { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 15000000 }); }
                catch (e) { try { mediaRecorder = new MediaRecorder(new MediaStream(tracks)); } catch (e2) { messageDiv.innerText = "Recording not supported"; return; } }
                mediaRecorder.ondataavailable = (e) => { if(e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = saveVideo;
                recordedChunks = [];
                mediaRecorder.start();
                isRecording = true;
                recordBtn.innerText = "Stop Rec";
                recordBtn.classList.add('recording');
            }
        }

        function saveVideo() {
            if (recordedChunks.length === 0) return;
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = currentAudioFile ? `xenon-flight-${currentAudioFile.name.split('.')[0]}.webm` : 'xenon-flight.webm';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 100);
        }

        fullscreenBtn.onclick = () => {
            if (!document.fullscreenElement) { document.body.requestFullscreen(); fullscreenBtn.innerHTML = "ðŸ¡¼"; }
            else { document.exitFullscreen(); fullscreenBtn.innerHTML = "â›¶"; }
        };

        initThree();
    })();
</script>
</body>
</html>