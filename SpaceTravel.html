<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xenon - Vector Command</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #00f3ff;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* HOLOGRAPHIC HUD LAYER */
        #hud-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .hud-line { fill: none; stroke: #00f3ff; stroke-width: 1.5; opacity: 0.8; }
        .hud-thin { fill: none; stroke: #00f3ff; stroke-width: 0.5; opacity: 0.4; }
        .hud-fill { fill: #00f3ff; opacity: 0.15; }
        .hud-fill-alert { fill: #ff0055; opacity: 0.2; }
        .hud-text { fill: #00f3ff; font-size: 11px; font-weight: bold; letter-spacing: 1px; }
        .hud-text-lg { fill: #fff; font-size: 14px; letter-spacing: 3px; text-shadow: 0 0 5px #00f3ff; }

        /* UI OVERLAY */
        #overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            padding: 40px;
            text-align: center;
            background: rgba(0, 10, 20, 0.9);
            border: 1px solid #00f3ff;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2), inset 0 0 50px rgba(0, 0, 0, 0.8);
            clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
            backdrop-filter: blur(8px);
            max-width: 500px;
            width: 90%;
            transition: opacity 0.5s ease;
        }

        h1 {
            font-size: 1.8rem;
            margin: 0 0 10px 0;
            color: #fff;
            text-shadow: 0 0 10px #00f3ff;
            text-transform: uppercase;
            letter-spacing: 6px;
        }

        h2 {
            font-size: 0.8rem;
            color: #00f3ff;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-bottom: 30px;
            border-bottom: 1px solid rgba(0, 243, 255, 0.3);
            display: inline-block;
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid rgba(0, 243, 255, 0.2);
            background: rgba(0, 20, 40, 0.5);
        }

        .btn {
            background: rgba(0, 243, 255, 0.1);
            color: #00f3ff;
            font-family: inherit;
            font-size: 1.0rem;
            font-weight: 700;
            padding: 15px 30px;
            border: 1px solid #00f3ff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s ease;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.1);
            width: 100%;
            margin-top: 10px;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }

        .btn:hover {
            background: #00f3ff;
            color: #000;
            box-shadow: 0 0 25px rgba(0, 243, 255, 0.6);
        }

        #fileInput { display: none; }

        /* Recording UI */
        #recordContainer {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            display: none;
            flex-direction: row;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .rec-btn {
            padding: 12px 24px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 1px;
            transition: all 0.2s;
            clip-path: polygon(10px 0, 100% 0, 100% 100%, 0 100%, 0 10px);
        }

        #recordButton { background: #ff0055; color: white; min-width: 180px; }
        #recordButton:hover { background: #ff3377; }
        #recordButton.recording { animation: pulseAlert 1s infinite; }

        #leaveButton { background: rgba(0, 243, 255, 0.2); color: #00f3ff; border: 1px solid #00f3ff; }
        #leaveButton:hover { background: #00f3ff; color: #000; }

        @keyframes pulseAlert {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(255, 0, 85, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0); }
        }

        #fullscreenBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00f3ff;
            color: #00f3ff;
            font-size: 20px;
            cursor: pointer;
            z-index: 150;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        #fullscreenBtn:hover { background: #00f3ff; color: #000; }

        #message { margin-top: 15px; color: #00f3ff; font-size: 0.8rem; min-height: 1.2em; }

        .checkbox-wrapper { display: flex; align-items: center; justify-content: center; gap: 10px; color: #81d4fa; margin-top: 15px; font-size: 0.8rem;}
        input[type="checkbox"] { accent-color: #00f3ff; cursor: pointer; }

        .vignette {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background: radial-gradient(circle, transparent 40%, #000 100%);
            z-index: 5;
        }

        .scanlines {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 3px, 3px 100%;
            z-index: 6;
        }

    </style>
</head>
<body>

<div id="canvas-container"></div>
<div class="vignette"></div>
<div class="scanlines"></div>

<!-- HOLOGRAPHIC HUD SVG -->
<svg id="hud-layer" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid slice">

    <!-- TOP FRAME -->
    <g transform="translate(0, 0)">
        <path d="M0,0 L1920,0 L1920,60 L1400,60 L1350,100 L570,100 L520,60 L0,60 Z" class="hud-fill"/>
        <path d="M0,60 L520,60 L570,100 L1350,100 L1400,60 L1920,60" class="hud-line"/>
        <text x="50" y="35" class="hud-text-lg">USS XENON // FLIGHT DECK</text>
        <text x="1750" y="35" class="hud-text" id="clock-display">T-MINUS 00:00</text>

        <!-- Top Ticks -->
        <g transform="translate(600, 80)">
            <line x1="0" y1="0" x2="720" y2="0" class="hud-thin"/>
            <rect id="compass-tick" x="360" y="-10" width="4" height="20" fill="#ff0055"/>
        </g>
    </g>

    <!-- LEFT PANEL (Engine Stats) -->
    <g transform="translate(0, 200)">
        <path d="M0,0 L120,0 L160,40 L160,600 L120,640 L0,640 Z" class="hud-fill"/>
        <path d="M120,0 L160,40 L160,600 L120,640" class="hud-line"/>

        <!-- Bars -->
        <g transform="translate(30, 100)">
            <text x="0" y="-20" class="hud-text">THRUSTER_L</text>
            <rect x="0" y="0" width="20" height="200" class="hud-thin"/>
            <rect id="bar-thrust-l" x="2" y="100" width="16" height="100" fill="#00f3ff" opacity="0.6"/>

            <text x="50" y="-20" class="hud-text">THRUSTER_R</text>
            <rect x="50" y="0" width="20" height="200" class="hud-thin"/>
            <rect id="bar-thrust-r" x="52" y="100" width="16" height="100" fill="#00f3ff" opacity="0.6"/>
        </g>

        <g transform="translate(30, 400)">
            <text x="0" y="0" class="hud-text">SHIELD_INTEGRITY</text>
            <text x="0" y="20" class="hud-text-lg" id="shield-val">100%</text>
        </g>
    </g>

    <!-- RIGHT PANEL (Nav/Comms) -->
    <g transform="translate(1760, 200)">
        <path d="M160,0 L40,0 L0,40 L0,600 L40,640 L160,640 Z" class="hud-fill"/>
        <path d="M40,0 L0,40 L0,600 L40,640" class="hud-line"/>

        <g transform="translate(30, 100)">
            <text x="0" y="-20" class="hud-text">SPECTRAL_ANALYSIS</text>
            <rect id="bar-spec-1" x="0" y="0" width="80" height="10" fill="#00f3ff" opacity="0.4"/>
            <rect id="bar-spec-2" x="0" y="20" width="60" height="10" fill="#00f3ff" opacity="0.4"/>
            <rect id="bar-spec-3" x="0" y="40" width="90" height="10" fill="#00f3ff" opacity="0.4"/>
            <rect id="bar-spec-4" x="0" y="60" width="30" height="10" fill="#00f3ff" opacity="0.4"/>
        </g>
    </g>

    <!-- BOTTOM FRAME -->
    <g transform="translate(0, 1000)">
        <path d="M0,80 L1920,80 L1920,0 L1520,0 L1470,40 L450,40 L400,0 L0,0 Z" class="hud-fill"/>
        <path d="M400,0 L450,40 L1470,40 L1520,0" class="hud-line"/>
        <text x="880" y="65" class="hud-text" style="letter-spacing:5px;">SYSTEM: ONLINE</text>
    </g>

    <!-- CENTER RETICLE (Simple) -->
    <g transform="translate(960, 540)">
        <circle cx="0" cy="0" r="150" class="hud-thin" stroke-dasharray="10 20" opacity="0.2"/>
        <line x1="-20" y1="0" x2="20" y2="0" class="hud-line" opacity="0.5"/>
        <line x1="0" y1="-20" x2="0" y2="20" class="hud-line" opacity="0.5"/>
    </g>
</svg>

<button id="fullscreenBtn" title="Toggle Fullscreen">â›¶</button>

<div id="recordContainer">
    <button id="recordButton" class="rec-btn">Init Record</button>
    <button id="leaveButton" class="rec-btn">Abort</button>
</div>

<div id="overlay">
    <h1>Xenon Interface</h1>
    <h2>Vector Command Module</h2>
    <div class="control-group">
        <p style="margin-top:0; color:#00f3ff; font-size: 0.75rem; letter-spacing: 1px; margin-bottom: 15px;">INPUT NAVIGATION DATA</p>
        <button id="selectFileBtn" class="btn">Load Audio File</button>
        <input type="file" id="fileInput" accept="audio/*">
    </div>

    <div class="checkbox-wrapper">
        <input type="checkbox" id="record4k">
        <label for="record4k">Hi-Res Capture (4K)</label>
    </div>

    <div class="checkbox-wrapper">
        <input type="checkbox" id="autoRecord">
        <label for="autoRecord">Auto-Log Flight</label>
    </div>

    <div id="message"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<!-- FRAGMENT SHADER: HYPERSPACE BG -->
<script type="x-shader/x-fragment" id="fragShader">
    uniform float uTime;
    uniform vec2 uResolution;
    uniform float uBass;
    uniform float uMid;
    uniform float uHigh;
    uniform float uFade;

    #define PI 3.14159265359

    vec3 palette( in float t ) {
        vec3 a = vec3(0.5, 0.5, 0.5);
        vec3 b = vec3(0.5, 0.5, 0.5);
        vec3 c = vec3(1.0, 1.0, 1.0);
        vec3 d = vec3(0.80, 0.90, 0.30);
        return a + b*cos( 6.28318*(c*t+d) );
    }

    mat2 rot(float a) {
        float s = sin(a);
        float c = cos(a);
        return mat2(c, -s, s, c);
    }

    void main() {
        if (uFade >= 1.0) {
            gl_FragColor = vec4(0.0, 0.05, 0.1, 1.0);
            return;
        }

        vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.y;

        // --- WARP TUNNEL ---
        float r = length(uv);
        float a = atan(uv.y, uv.x);
        float z = 1.0 / (r + 0.01);
        float speed = uTime * 4.0 + (uBass * 2.0);

        vec3 finalColor = vec3(0.0);

        for(float i = 0.0; i < 2.0; i++) {
            vec2 p = vec2(z * 0.5 + speed * 0.2, a / PI + i * 0.5);
            float cloud = sin(p.x * 5.0) * sin(p.y * 5.0);
            cloud += sin(p.x * 10.0 + uTime) * 0.5;
            float depth = 0.1 / abs(cloud + 0.1);
            vec3 col = palette(z * 0.1 + i * 0.2 + uBass * 0.1);
            col.r += uBass * 0.4;
            col.g += uMid * 0.3;
            col.b += uHigh * 0.8;
            finalColor += col * depth * (r * r);
        }

        float streaks = sin(z * 20.0 + speed * 5.0) * sin(a * 10.0);
        streaks = smoothstep(0.8, 1.0, streaks);
        finalColor += vec3(0.8, 0.9, 1.0) * streaks * uHigh;

        // Darken center for 3D objects to pop
        finalColor *= smoothstep(0.0, 0.4, r);

        vec3 fadeColor = vec3(0.0, 0.02, 0.05);
        finalColor = mix(finalColor, fadeColor, uFade);

        gl_FragColor = vec4(finalColor, 1.0);
    }
</script>

<script>
    (function(){
        // --- CONFIG & STATE ---
        let audioContext, analyser, dataArray, sourceNode;
        let renderer, sceneBG, cameraBG, materialBG, meshBG;
        let scene3D, camera3D; // For Vector Graphics
        let isRunning = false;
        let currentAudioFile = null;

        // 3D HUD Objects
        let shipWireframe, planetWireframe, tunnelRings = [];

        // Audio State
        let smoothBass = 0, smoothMid = 0, smoothHigh = 0;

        // Fading State
        let isFading = false;
        let fadeStartTime = 0;
        const FADE_DURATION = 3.0;

        // Recording
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;
        let was4k = false;

        // DOM Elements
        const barThrustL = document.getElementById('bar-thrust-l');
        const barThrustR = document.getElementById('bar-thrust-r');
        const shieldVal = document.getElementById('shield-val');
        const compassTick = document.getElementById('compass-tick');
        const clockDisplay = document.getElementById('clock-display');
        const specBars = [
            document.getElementById('bar-spec-1'),
            document.getElementById('bar-spec-2'),
            document.getElementById('bar-spec-3'),
            document.getElementById('bar-spec-4')
        ];

        const container = document.getElementById('canvas-container');
        const overlay = document.getElementById('overlay');
        const fileInput = document.getElementById('fileInput');
        const selectFileBtn = document.getElementById('selectFileBtn');
        const messageDiv = document.getElementById('message');
        const recordBtn = document.getElementById('recordButton');
        const leaveBtn = document.getElementById('leaveButton');
        const recordContainer = document.getElementById('recordContainer');
        const autoRecordCheck = document.getElementById('autoRecord');
        const record4kCheck = document.getElementById('record4k');
        const fullscreenBtn = document.getElementById('fullscreenBtn');

        // --- THREE.JS SETUP ---
        function initThree() {
            // RENDERER
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, preserveDrawingBuffer: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false; // Important for multi-pass
            container.appendChild(renderer.domElement);

            // SCENE 1: BACKGROUND SHADER
            sceneBG = new THREE.Scene();
            cameraBG = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
            const geometry = new THREE.PlaneGeometry(2, 2);
            materialBG = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    uBass: { value: 0.0 },
                    uMid: { value: 0.0 },
                    uHigh: { value: 0.0 },
                    uFade: { value: 0.0 }
                },
                fragmentShader: document.getElementById('fragShader').textContent,
                depthWrite: false
            });
            meshBG = new THREE.Mesh(geometry, materialBG);
            sceneBG.add(meshBG);

            // SCENE 2: 3D VECTOR GRAPHICS
            scene3D = new THREE.Scene();
            // Perspective Camera: FOV 75, Aspect, Near 0.1, Far 1000
            camera3D = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera3D.position.z = 10;

            create3DInterface();

            container.addEventListener("webglcontextlost", (event) => { event.preventDefault(); resetUI(); }, false);
            container.addEventListener("webglcontextrestored", initThree, false);
            window.addEventListener('resize', onResize);
        }

        function create3DInterface() {
            const wireMat = new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.6 });
            const alertMat = new THREE.LineBasicMaterial({ color: 0xff0055, transparent: true, opacity: 0.8 });

            // 1. SHIP DIAGNOSTIC (Left Bottom)
            const shipGroup = new THREE.Group();

            // Core
            const coreGeo = new THREE.IcosahedronGeometry(1, 0);
            const core = new THREE.LineSegments(new THREE.WireframeGeometry(coreGeo), wireMat);
            shipGroup.add(core);

            // Rings around ship
            const ringGeo = new THREE.TorusGeometry(1.6, 0.05, 4, 32);
            const ring = new THREE.LineSegments(new THREE.WireframeGeometry(ringGeo), wireMat);
            ring.rotation.x = Math.PI / 2;
            shipGroup.add(ring);

            shipGroup.position.set(-6, -3, 0); // Bottom Left position in 3D space
            shipGroup.rotation.y = 0.5;
            scene3D.add(shipGroup);
            shipWireframe = shipGroup;

            // 2. TACTICAL PLANET (Right Bottom)
            const planetGroup = new THREE.Group();
            const planetGeo = new THREE.SphereGeometry(1.5, 16, 16);
            const planet = new THREE.LineSegments(new THREE.WireframeGeometry(planetGeo), alertMat);
            planetGroup.add(planet);

            // Orbit line
            const orbitGeo = new THREE.TorusGeometry(2.2, 0.02, 4, 64);
            const orbit = new THREE.Line(new THREE.WireframeGeometry(orbitGeo), wireMat);
            orbit.rotation.x = Math.PI / 2.3;
            planetGroup.add(orbit);

            planetGroup.position.set(6, -3, 0); // Bottom Right
            scene3D.add(planetGroup);
            planetWireframe = planetGroup;

            // 3. TARGETING TUNNEL RINGS
            // Create a series of rings moving towards camera
            for(let i=0; i<6; i++) {
                const tunnelGeo = new THREE.OctahedronGeometry(1 + i*0.5, 0);
                const tunnelRing = new THREE.LineSegments(new THREE.WireframeGeometry(tunnelGeo), new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.3 - (i*0.05) }));
                tunnelRing.position.z = -10 - (i * 5);
                scene3D.add(tunnelRing);
                tunnelRings.push(tunnelRing);
            }
        }

        function onResize() {
            if(isRecording && was4k) return;
            const w = window.innerWidth;
            const h = window.innerHeight;

            renderer.setSize(w, h);

            // Update BG Uniforms
            materialBG.uniforms.uResolution.value.x = w;
            materialBG.uniforms.uResolution.value.y = h;

            // Update 3D Camera
            camera3D.aspect = w / h;
            camera3D.updateProjectionMatrix();
        }

        // --- HUD UPDATE LOGIC (SVG) ---
        function updateSVG(bass, mid, high, time) {
            // Bars (Engines)
            const heightL = 200 * bass;
            const heightR = 200 * mid;
            barThrustL.setAttribute('height', heightL);
            barThrustL.setAttribute('y', 200 - heightL);
            barThrustR.setAttribute('height', heightR);
            barThrustR.setAttribute('y', 200 - heightR);

            // Shield %
            shieldVal.textContent = Math.floor(100 - (high * 20)) + "%";

            // Compass Tick
            const compassX = 360 + Math.sin(time) * 100;
            compassTick.setAttribute('x', compassX);

            // Spec Bars (Right)
            specBars.forEach((bar, i) => {
                const val = (i % 2 === 0) ? bass : high;
                bar.setAttribute('width', 20 + val * 100);
            });

            // Clock
            const mins = Math.floor(time / 60).toString().padStart(2, '0');
            const secs = Math.floor(time % 60).toString().padStart(2, '0');
            clockDisplay.textContent = `FLIGHT TIME ${mins}:${secs}`;
        }

        // --- AUDIO ENGINE ---
        function initAudio() {
            if(!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
            } else if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function getAudioData() {
            if(!analyser) return { bass:0, mid:0, high:0 };
            analyser.getByteFrequencyData(dataArray);

            const avg = (start, end) => {
                let sum = 0;
                for(let i=start; i<end; i++) sum += dataArray[i];
                return sum / (end-start);
            };

            return {
                bass: avg(0, 10) / 255,
                mid: avg(10, 80) / 255,
                high: avg(80, 200) / 255
            };
        }

        // --- ANIMATION ---
        let lastFrameTime = 0;
        let animationFrameId;

        function animate(time) {
            if(!isRunning && !isFading) return;

            const currentTimeSec = time / 1000;
            const deltaTime = (time - lastFrameTime) / 1000;
            lastFrameTime = time;

            if (isFading) {
                const fadeProgress = (currentTimeSec - fadeStartTime) / FADE_DURATION;
                if (fadeProgress >= 1.0) {
                    materialBG.uniforms.uFade.value = 1.0;
                    renderer.clear();
                    renderer.render(sceneBG, cameraBG);
                    resetUI();
                    return;
                }
                materialBG.uniforms.uFade.value = fadeProgress;
            }

            const audioData = getAudioData();
            smoothBass += (audioData.bass - smoothBass) * 0.15;
            smoothMid += (audioData.mid - smoothMid) * 0.15;
            smoothHigh += (audioData.high - smoothHigh) * 0.15;

            // 1. UPDATE SHADER BG
            materialBG.uniforms.uTime.value = currentTimeSec;
            materialBG.uniforms.uBass.value = smoothBass;
            materialBG.uniforms.uMid.value = smoothMid;
            materialBG.uniforms.uHigh.value = smoothHigh;

            // 2. UPDATE 3D OBJECTS
            if(shipWireframe) {
                shipWireframe.rotation.x += deltaTime * 0.5;
                shipWireframe.rotation.y += deltaTime * 0.2;
                shipWireframe.scale.setScalar(1 + smoothBass * 0.3); // Pulse
            }

            if(planetWireframe) {
                planetWireframe.rotation.y -= deltaTime;
                planetWireframe.children[0].material.opacity = 0.5 + smoothHigh; // Glow
            }

            // Move Tunnel Rings
            tunnelRings.forEach((ring, i) => {
                ring.position.z += deltaTime * (5 + smoothBass * 10);
                ring.rotation.z += deltaTime * (i%2==0 ? 1 : -1);
                if(ring.position.z > 5) {
                    ring.position.z = -25;
                }
            });

            // 3. UPDATE SVG
            updateSVG(smoothBass, smoothMid, smoothHigh, currentTimeSec);

            // 4. RENDER PASSES
            renderer.clear();
            renderer.render(sceneBG, cameraBG); // Draw BG
            renderer.clearDepth(); // Clear depth buffer so 3D draws on top
            renderer.render(scene3D, camera3D); // Draw 3D HUD

            animationFrameId = requestAnimationFrame(animate);
        }

        // --- FILE HANDLING & UTILS ---
        selectFileBtn.onclick = () => { initAudio(); fileInput.value = ''; fileInput.click(); };

        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if(!file) return;
            currentAudioFile = file;
            messageDiv.innerText = "ENGAGING HYPERDRIVE...";
            const reader = new FileReader();
            reader.onload = async (ev) => {
                try {
                    const audioBuffer = await audioContext.decodeAudioData(ev.target.result);
                    await startVisualizer(audioBuffer);
                } catch(err) {
                    messageDiv.innerText = "SYSTEM FAILURE: " + err.message;
                }
            };
            reader.readAsArrayBuffer(file);
        };

        async function startVisualizer(buffer) {
            if (audioContext.state === 'suspended') await audioContext.resume();
            if(sourceNode) { try { sourceNode.onended = null; sourceNode.disconnect(); sourceNode.stop(); } catch(e) {} }

            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = buffer;
            sourceNode.connect(analyser);
            analyser.connect(audioContext.destination);
            sourceNode.onended = () => { if (isRunning) triggerFadeOut(); };
            sourceNode.start(0);

            overlay.style.opacity = 0;
            setTimeout(() => overlay.style.display = 'none', 800);
            recordContainer.style.display = 'flex';
            setTimeout(() => recordContainer.style.opacity = 1, 10);

            isRunning = true;
            isFading = false;
            materialBG.uniforms.uFade.value = 0.0;
            lastFrameTime = performance.now();
            smoothBass = 0; smoothMid = 0; smoothHigh = 0;

            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animate(lastFrameTime);
            if(autoRecordCheck.checked) setTimeout(toggleRecord, 800);
        }

        function triggerFadeOut() {
            if (!isRunning || isFading) return;
            isFading = true;
            fadeStartTime = performance.now() / 1000;
        }

        function resetUI() {
            isRunning = false;
            isFading = false;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if(isRecording) toggleRecord();
            overlay.style.display = 'block';
            setTimeout(() => overlay.style.opacity = 1, 10);
            recordContainer.style.opacity = 0;
            setTimeout(() => recordContainer.style.display = 'none', 500);
            if(sourceNode) { try { sourceNode.onended = null; sourceNode.disconnect(); } catch(e){} }
        }

        leaveBtn.onclick = () => { if(sourceNode) { try { sourceNode.stop(); } catch(e){} } resetUI(); };
        recordBtn.onclick = toggleRecord;

        function toggleRecord() {
            if(isRecording) {
                try { mediaRecorder.stop(); } catch(e){}
                isRecording = false;
                recordBtn.innerText = "Init Record";
                recordBtn.classList.remove('recording');
                if (was4k) {
                    renderer.setSize(window.innerWidth, window.innerHeight, true);
                    materialBG.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
                    camera3D.aspect = window.innerWidth / window.innerHeight;
                    camera3D.updateProjectionMatrix();
                    was4k = false;
                }
            } else {
                if (record4kCheck.checked) {
                    was4k = true;
                    renderer.setSize(3840, 2160, false);
                    materialBG.uniforms.uResolution.value.set(3840, 2160);
                    camera3D.aspect = 3840 / 2160;
                    camera3D.updateProjectionMatrix();
                }
                const stream = renderer.domElement.captureStream(60);
                const dest = audioContext.createMediaStreamDestination();
                sourceNode.connect(dest);
                const tracks = [...stream.getVideoTracks(), ...dest.stream.getAudioTracks()];
                try { mediaRecorder = new MediaRecorder(new MediaStream(tracks), { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 15000000 }); }
                catch (e) { try { mediaRecorder = new MediaRecorder(new MediaStream(tracks)); } catch (e2) { messageDiv.innerText = "Recording not supported"; return; } }
                mediaRecorder.ondataavailable = (e) => { if(e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = saveVideo;
                recordedChunks = [];
                mediaRecorder.start();
                isRecording = true;
                recordBtn.innerText = "Stop Rec";
                recordBtn.classList.add('recording');
            }
        }

        function saveVideo() {
            if (recordedChunks.length === 0) return;
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = currentAudioFile ? `xenon-flight-${currentAudioFile.name.split('.')[0]}.webm` : 'xenon-flight.webm';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 100);
        }

        fullscreenBtn.onclick = () => {
            if (!document.fullscreenElement) { document.body.requestFullscreen(); fullscreenBtn.innerHTML = "ðŸ¡¼"; }
            else { document.exitFullscreen(); fullscreenBtn.innerHTML = "â›¶"; }
        };

        initThree();
    })();
</script>
</body>
</html>