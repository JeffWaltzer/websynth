<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Groovesynth 70s</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Monoton&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #3a2f2f;
            color: #f0f0f0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
        }
        .font-brand {
            font-family: 'Monoton', cursive;
        }
        .panel {
            background-color: #c5b8a5;
            border: 2px solid #8a7868;
            box-shadow: 0 0 8px rgba(0,0,0,0.4) inset, 0 1px 3px rgba(0,0,0,0.2);
            border-radius: 6px;
        }
        header.panel {
            padding: 0.4rem 0.8rem;
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            gap: 0.3rem;
            flex-wrap: wrap;
        }
        .control-panel {
            background-color: #a09383;
            border: 1px solid #706050;
            border-radius: 4px;
            padding: 0.2rem 0.4rem;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 0.3rem;
            flex-wrap: nowrap;
        }
        header.panel .control-panel.transport-midi {
            flex-wrap: wrap;
        }

        .project-name-input {
            background-color: #f0e6d2;
            color: #3a2f2f;
            border: 1px solid #8a7868;
            border-radius: 3px;
            padding: 1px 4px;
            font-size: 0.7rem;
            max-width: 120px;
        }

        .btn-70s {
            background-color: #f58700;
            color: #fff;
            border: 1px solid #d47500;
            border-radius: 4px;
            padding: 4px 10px;
            font-weight: bold;
            line-height: 1;
            font-size: 0.9rem;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2), 0 1px 1px rgba(255,255,255,0.2) inset;
            transition: all 0.1s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 36px;
        }
        .btn-70s:hover {
            background-color: #ff9a1f;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3), 0 1px 1px rgba(255,255,255,0.3) inset;
        }
        .btn-70s:active {
            background-color: #e07000;
            transform: translateY(1px);
            box-shadow: 0 1px 1px rgba(0,0,0,0.3), 0 1px 1px rgba(255,255,255,0.1) inset;
        }
        .btn-70s.active {
            background-color: #5a8a28;
            border-color: #4a731f;
        }
        .btn-70s.record.active {
            background-color: #c00;
            border-color: #a00;
            animation: pulse 0.8s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(204, 0, 0, 0.6), 0 1px 2px rgba(0,0,0,0.2); }
            70% { box-shadow: 0 0 0 8px rgba(204, 0, 0, 0), 0 1px 2px rgba(0,0,0,0.2); }
            100% { box-shadow: 0 0 0 0 rgba(204, 0, 0, 0), 0 1px 2px rgba(0,0,0,0.2); }
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #706050;
            outline: none;
            border-radius: 4px;
            margin: 3px 0;
            border: 1px solid #504030;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 10px;
            height: 20px;
            background: #f58700;
            cursor: pointer;
            border-radius: 2px;
            border: 1px solid #d47500;
            box-shadow: 0 1px 1px rgba(0,0,0,0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 10px;
            height: 20px;
            background: #f58700;
            cursor: pointer;
            border-radius: 2px;
            border: 1px solid #d47500;
            box-shadow: 0 1px 1px rgba(0,0,0,0.2);
        }

        .piano {
            display: flex;
            justify-content: center;
            padding: 6px; /* Further reduced padding */
            background-color: #4a3f3f;
            border-top: 2px solid #2a1f1f;
            border-radius: 4px 4px 0 0;
            box-shadow: 0 -1px 3px rgba(0,0,0,0.2);
            overflow-x: auto;
            margin-top: 0; /* Remove space between grid and piano */
        }
        .piano-keys-wrapper {
            display: flex;
            justify-content: flex-start; /* Align keys to the left */
        }
        .piano-key {
            border: 1px solid #333;
            border-radius: 0 0 4px 4px;
            cursor: pointer;
            box-shadow: 1px 0 2px rgba(0,0,0,0.2);
            transition: background-color 0.1s;
            flex-shrink: 0;
        }
        .piano-key.white {
            width: 36px; /* Slightly narrower */
            height: 150px; /* Shorter */
            background-color: #f0e6d2;
            z-index: 1;
        }
        .piano-key.black {
            width: 22px; /* Slightly narrower */
            height: 95px; /* Shorter */
            background-color: #333;
            color: white;
            margin-left: -11px; /* Adjusted overlap */
            margin-right: -11px; /* Adjusted overlap */
            z-index: 2;
        }
        .piano-key:active, .piano-key.pressed {
            background-color: #f58700;
        }
        .piano-key.black:active, .piano-key.black.pressed {
            background-color: #e07000;
        }

        .combined-sequencer-view {
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* Align tracks to the start (left) */
            overflow-y: auto;
            background-color: #504840;
            border-radius: 3px;
            padding: 3px;
            width: min-content; /* Make the view only as wide as its content */
            margin-left: auto; /* Center the block if it's narrower than parent */
            margin-right: auto; /* Center the block */
        }
        .track-row {
            display: flex;
            align-items: center;
            margin-bottom: 2px;
            background-color: #c5b8a5;
            border-radius: 4px;
            border: 1px solid #8a7868;
            height: 26px;
        }
        .track-controls {
            min-width: 110px;
            padding: 0 4px;
            text-align: left;
            border-right: 1px solid #8a7868;
            background-color: #a09383;
            border-radius: 4px 0 0 4px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            gap: 2px;
            height: 100%;
        }
        .track-controls.selected {
            outline: 1px solid #f58700;
            box-shadow: 0 0 6px #f58700;
            z-index: 1;
        }
        .track-controls h3 {
            font-size: 0.65rem;
            margin: 0;
            line-height: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 1;
            color: #3a2f2f;
        }
        .track-controls input[type="range"] {
            width: 40px;
            height: 5px;
            margin: 0;
            flex-shrink: 0;
        }
        .track-controls input[type="range"]::-webkit-slider-thumb {
            height: 10px;
            width: 7px;
        }
        .track-controls input[type="range"]::-moz-range-thumb {
            height: 10px;
            width: 7px;
        }

        .track-steps-container {
            display: flex;
            overflow-x: auto;
            padding: 2px;
            align-items: center;
            height: 100%;
            width: fit-content; /* Ensure container fits steps */
        }
        .step {
            min-width: 22px;
            width: 22px;
            height: 16px;
            background-color: #7d7064;
            border: 1px solid #60554b;
            margin-right: 1px;
            position: relative;
            border-radius: 2px;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .step.active-step {
            background-color: rgba(245, 135, 0, 0.4);
            border-color: #f58700;
        }
        .step.record-head {
            background-color: rgba(204, 0, 0, 0.3);
            border-color: #cc0000;
        }
        .note-indicator {
            position: absolute;
            top: 1px; left: 1px; right: 1px; bottom: 1px;
            background-color: #5a8a28;
            border-radius: 1px;
            pointer-events: none;
            opacity: 0.8;
            box-shadow: 0 0 1px rgba(0,0,0,0.3) inset;
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        .note-indicator.last-active-note {
            background-color: #8fbc8f;
            border: 1px solid #f58700;
        }
        .note-pitch-text {
            font-size: 0.5rem;
            color: #f0f0f0;
            line-height: 1;
            pointer-events: none;
            text-shadow: 1px 1px 1px #3a2f2f;
            white-space: nowrap;
        }

        .message-box {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #e0c00d;
            color: #3a2f2f;
            padding: 8px 15px;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .midi-select {
            background-color: #f0e6d2;
            color: #3a2f2f;
            border: 1px solid #8a7868;
            border-radius: 3px;
            padding: 1px 3px;
            min-width: 110px;
            font-size: 0.7rem;
        }
        header.panel .control-panel label.text-xs {
            font-size: 0.65rem;
            margin-right: 0.1rem;
        }
        header.panel .control-panel input[type="number"] {
            padding: 0.05rem 0.2rem;
            font-size: 0.7rem;
            width: 3.5rem;
        }
    </style>
</head>
<body class="text-sm sm:text-base">

<header class="panel">
    <h1 class="font-brand text-xl sm:text-2xl text-[#3a2f2f] flex-shrink-0">Groovesynth 70</h1>
    <div class="control-panel transport-midi flex-grow">
        <button id="playBtn" class="btn-70s" title="Play/Pause">&#x25B6;</button>
        <button id="stopBtn" class="btn-70s" title="Stop">&#x25A0;</button>
        <button id="recordBtn" class="btn-70s record" title="Record">&#x25CF;</button>
        <div class="flex items-center">
            <label for="tempo" class="text-xs text-[#3a2f2f] font-semibold">BPM:</label>
            <input type="number" id="tempo" value="120" min="40" max="280" class="w-14 p-0.5 rounded bg-[#f0e6d2] text-[#3a2f2f] border border-[#8a7868] text-center">
        </div>
        <div class="flex items-center">
            <label for="midiInputSelect" class="text-xs text-[#3a2f2f] font-semibold">In:</label>
            <select id="midiInputSelect" class="midi-select">
                <option value="">No MIDI In</option>
            </select>
        </div>
        <div class="flex items-center">
            <label for="midiOutputSelect" class="text-xs text-[#3a2f2f] font-semibold">Out:</label>
            <select id="midiOutputSelect" class="midi-select">
                <option value="">No MIDI Out</option>
            </select>
        </div>
    </div>
    <div class="control-panel">
        <label for="currentProjectNameInput" class="text-xs text-[#3a2f2f] font-semibold" style="display: inline-block !important;">Name:</label>
        <input type="text" id="currentProjectNameInput" placeholder="Local Groove" class="project-name-input">
    </div>
    <div class="control-panel">
        <label for="masterVolume" class="text-xs text-[#3a2f2f] font-semibold" style="display: inline-block !important;">Master:</label>
        <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.8" class="w-16">
    </div>
</header>

<main class="flex-grow mx-1 sm:mx-2 mb-0 panel p-0.5 sm:p-1">
    <div id="combinedSequencerView" class="combined-sequencer-view">
    </div>
</main>

<footer class="piano" id="pianoContainer">
    <div id="pianoKeysWrapper" class="piano-keys-wrapper">
    </div>
</footer>

<div id="messageBox" class="message-box">Sample Message</div>

<script type="module">
    const appId = 'groovesynth-70s-local-no-fb';

    const NUM_CHANNELS = 16;
    const STEPS_PER_BEAT = 4;
    const BEATS_PER_MEASURE = 4;
    const NUM_MEASURES = 2;
    const TOTAL_STEPS = STEPS_PER_BEAT * BEATS_PER_MEASURE * NUM_MEASURES;

    let channelAudioNodes = [];
    let selectedChannelIndex = 0;
    let isRecording = false;
    let currentPlaybackStep = 0;
    let manualRecordStep = 0;
    let playheadMarker;
    let currentMIDIInput = null;
    let currentMIDIOutput = null;
    let lastActiveNoteId = null;
    let midiAccessGlobal = null;

    const projectData = {
        projectName: "Local Groove",
        tempo: 120,
        masterVolume: 0.8,
        channels: []
    };

    const playBtn = document.getElementById('playBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recordBtn = document.getElementById('recordBtn');
    const tempoInput = document.getElementById('tempo');
    const masterVolumeSlider = document.getElementById('masterVolume');
    const combinedSequencerView = document.getElementById('combinedSequencerView');
    const pianoContainer = document.getElementById('pianoContainer');
    const pianoKeysWrapper = document.getElementById('pianoKeysWrapper');
    const messageBox = document.getElementById('messageBox');
    const midiInputSelect = document.getElementById('midiInputSelect');
    const midiOutputSelect = document.getElementById('midiOutputSelect');
    const currentProjectNameInput = document.getElementById('currentProjectNameInput');

    const PLAY_SYMBOL = '\u25B6';
    const PAUSE_SYMBOL = '\u23F8';

    function showMessage(message, duration = 2500) {
        messageBox.textContent = message;
        messageBox.style.display = 'block';
        setTimeout(() => {
            messageBox.style.display = 'none';
        }, duration);
    }

    function generateId() {
        return Math.random().toString(36).substring(2, 9) + Date.now().toString(36);
    }

    const notesSharpFlat = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const notesWhite = ["C", "D", "E", "F", "G", "A", "B"]; // Helper for piano generation
    const OCTAVE_START_DEFAULT = 3;
    const WHITE_KEY_WIDTH_CSS = 36;
    const MIN_OCTAVES_DISPLAY = 1;
    const MAX_OCTAVES_DISPLAY = 7;

    function updateVisualPlayhead(stepIndex, isRecordHead = false) {
        document.querySelectorAll('.step.active-step').forEach(s => s.classList.remove('active-step'));
        document.querySelectorAll('.step.record-head').forEach(s => s.classList.remove('record-head'));

        if (stepIndex >= 0 && stepIndex < TOTAL_STEPS) {
            document.querySelectorAll(`.track-steps-container .step[data-step-index="${stepIndex}"]`).forEach(s => {
                s.classList.add(isRecordHead ? 'record-head' : 'active-step');
            });
        }
    }

    function createPiano() {
        pianoKeysWrapper.innerHTML = '';
        const containerWidth = pianoContainer.clientWidth - 12;

        const whiteKeyWidth = WHITE_KEY_WIDTH_CSS;
        const maxWhiteKeysThatCanFit = Math.floor(containerWidth / whiteKeyWidth);

        let numOctavesToDisplay = Math.floor(maxWhiteKeysThatCanFit / 7); // 7 white keys per octave
        numOctavesToDisplay = Math.max(MIN_OCTAVES_DISPLAY, Math.min(numOctavesToDisplay, MAX_OCTAVES_DISPLAY));

        let octaveStart = OCTAVE_START_DEFAULT;
        if (numOctavesToDisplay < 3 && numOctavesToDisplay > 0) { // Try to center for 1 or 2 octaves
            octaveStart = Math.max(0, OCTAVE_START_DEFAULT - Math.floor((3 - numOctavesToDisplay)));
        } else if (numOctavesToDisplay >= 3) {
            octaveStart = Math.max(0, OCTAVE_START_DEFAULT - Math.floor((numOctavesToDisplay - 2)/2) );
        }

        let keysRendered = 0;
        for (let o = 0; o < MAX_OCTAVES_DISPLAY + 2; o++) { // Iterate a bit beyond max to fill width
            const currentOctaveReal = octaveStart + o;
            if (currentOctaveReal > 8) break; // Max MIDI octave

            for (const noteName of notesSharpFlat) {
                const isBlack = noteName.includes('#');
                const whiteKeyEquivalentWidth = isBlack ? 0 : whiteKeyWidth; // Black keys don't consume main width in this layout

                if (pianoKeysWrapper.scrollWidth + (isBlack ? 0 : whiteKeyWidth) <= containerWidth + whiteKeyWidth/2) { // Allow slight overflow for last black key
                    const key = document.createElement('div');
                    key.classList.add('piano-key', isBlack ? 'black' : 'white');
                    const fullNoteName = noteName + currentOctaveReal;
                    key.dataset.note = fullNoteName;
                    key.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        playPianoKey(fullNoteName, key);
                    });
                    pianoKeysWrapper.appendChild(key);
                    keysRendered++;
                } else if (!isBlack) { // If a white key can't fit, stop this octave and subsequent ones
                    return; // Exit createPiano
                }
            }
            if (pianoKeysWrapper.scrollWidth >= containerWidth) break;
        }
    }

    async function playPianoKey(note, keyElement, velocity = 1) {
        if (Tone.context.state !== 'running') {
            await Tone.start();
            if (Tone.context.state !== 'running') {
                showMessage("Audio context not ready.", 4000);
                return;
            }
        }
        if (selectedChannelIndex >= 0 && selectedChannelIndex < channelAudioNodes.length && channelAudioNodes[selectedChannelIndex] && channelAudioNodes[selectedChannelIndex].synth) {
            channelAudioNodes[selectedChannelIndex].synth.triggerAttack(note, Tone.now(), velocity);
        } else {
            console.error("Synth not ready for selected channel:", selectedChannelIndex);
            return;
        }

        if (keyElement) keyElement.classList.add('pressed');

        if (isRecording && projectData.channels[selectedChannelIndex]) {
            const stepTicks = Tone.Time('16n').toTicks();
            const quantizedTimeTicks = manualRecordStep * stepTicks;
            const newNoteId = generateId();
            const newNote = {
                id: newNoteId, time: quantizedTimeTicks, pitch: note,
                duration: '8n', velocity: velocity
            };
            const notesArray = projectData.channels[selectedChannelIndex].notes;
            const existingNoteIndex = notesArray.findIndex(n => n.time === quantizedTimeTicks);
            if (existingNoteIndex > -1) {
                notesArray.splice(existingNoteIndex, 1, newNote);
            } else {
                notesArray.push(newNote);
            }
            lastActiveNoteId = newNoteId;
            updateSequencerGridVisuals();
            updateVisualPlayhead(manualRecordStep, true);
            manualRecordStep = (manualRecordStep + 1) % TOTAL_STEPS;
            updateVisualPlayhead(manualRecordStep, true);
            if (keyElement) {
                setTimeout(() => keyElement.classList.remove('pressed'), 100);
            }
        }
    }

    function releasePianoKey(note, keyElement) {
        if (Tone.context.state !== 'running') return;
        const targetSynth = channelAudioNodes[selectedChannelIndex]?.synth;
        if (!targetSynth) return;
        targetSynth.triggerRelease(note, Tone.now() + 0.05);
        if (keyElement && keyElement.classList.contains('pressed')) {
            keyElement.classList.remove('pressed');
        } else {
            const actualKeyElement = pianoKeysWrapper.querySelector(`.piano-key[data-note="${note}"].pressed`);
            if (actualKeyElement) actualKeyElement.classList.remove('pressed');
        }
    }

    window.addEventListener('mouseup', (e) => {
        pianoKeysWrapper.querySelectorAll('.piano-key.pressed').forEach(key => {
            releasePianoKey(key.dataset.note, key);
        });
    });
    pianoContainer.addEventListener('mouseleave', (e) => {
        pianoKeysWrapper.querySelectorAll('.piano-key.pressed').forEach(key => {
            releasePianoKey(key.dataset.note, key);
        });
    });

    function createChannels() {
        combinedSequencerView.innerHTML = '';
        projectData.channels = [];
        channelAudioNodes.forEach(nodes => {
            if (nodes.synth) nodes.synth.dispose();
            if (nodes.panner) nodes.panner.dispose();
        });
        channelAudioNodes = [];
        for (let i = 0; i < NUM_CHANNELS; i++) {
            const channelData = {
                id: `ch${i}`, name: `MIDI Ch ${i + 1}`, volume: 0.8, pan: 0,
                instrument: { type: 'Synth', options: { oscillator: { type: 'triangle' }, envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.5 } } },
                notes: [],
            };
            projectData.channels.push(channelData);
            const synth = new Tone[channelData.instrument.type](channelData.instrument.options);
            const panner = new Tone.Panner(channelData.pan).toDestination();
            synth.connect(panner);
            channelAudioNodes.push({ synth, panner });
            synth.volume.value = Tone.gainToDb(channelData.volume);
            const trackRowDiv = document.createElement('div');
            trackRowDiv.classList.add('track-row');
            trackRowDiv.dataset.channelIndex = i;
            const trackControlsDiv = document.createElement('div');
            trackControlsDiv.classList.add('track-controls');
            if (i === selectedChannelIndex) trackControlsDiv.classList.add('selected');
            const nameLabel = document.createElement('h3');
            nameLabel.classList.add('truncate');
            nameLabel.textContent = channelData.name;
            trackControlsDiv.appendChild(nameLabel);
            const volumeFader = document.createElement('input');
            volumeFader.type = 'range';
            volumeFader.min = 0; volumeFader.max = 1; volumeFader.step = 0.01; volumeFader.value = channelData.volume;
            volumeFader.title = "Channel Volume";
            volumeFader.addEventListener('input', (e) => {
                projectData.channels[i].volume = parseFloat(e.target.value);
                if (channelAudioNodes[i] && channelAudioNodes[i].synth) {
                    channelAudioNodes[i].synth.volume.value = Tone.gainToDb(projectData.channels[i].volume);
                }
            });
            trackControlsDiv.appendChild(volumeFader);
            trackControlsDiv.addEventListener('click', () => selectChannel(i));
            trackRowDiv.appendChild(trackControlsDiv);
            const trackStepsContainerDiv = document.createElement('div');
            trackStepsContainerDiv.classList.add('track-steps-container');
            for (let j = 0; j < TOTAL_STEPS; j++) {
                const stepDiv = document.createElement('div');
                stepDiv.classList.add('step');
                stepDiv.dataset.stepIndex = j;
                stepDiv.addEventListener('click', () => handleStepClick(i, j));
                trackStepsContainerDiv.appendChild(stepDiv);
            }
            trackRowDiv.appendChild(trackStepsContainerDiv);
            combinedSequencerView.appendChild(trackRowDiv);
        }
        selectChannel(0);
    }

    function selectChannel(index) {
        selectedChannelIndex = index;
        document.querySelectorAll('.track-controls').forEach((tc, i) => {
            tc.classList.toggle('selected', i === index);
        });
        // When a channel is selected, set the manualRecordStep to 0 for that channel,
        // or to where the playhead is if playing.
        if (isRecording) {
            manualRecordStep = 0; // Or consider aligning with currentPlaybackStep if desired behavior
            updateVisualPlayhead(manualRecordStep, true);
        }
        console.log(`Switched to Channel: ${index + 1}`);
    }

    function handleStepClick(channelIndex, stepIndex) {
        // If a different track row is clicked to select it, that action is handled by selectChannel.
        // This function handles clicks directly on a step in the currently selected channel.
        if (channelIndex !== selectedChannelIndex) {
            selectChannel(channelIndex); // Ensure the clicked channel becomes the selected one
        }

        const channelData = projectData.channels[selectedChannelIndex]; // Use selectedChannelIndex
        if (!channelData) return;

        const noteTimeInTicks = stepIndex * Tone.Time('16n').toTicks();
        const existingNoteIndex = channelData.notes.findIndex(note => note.time === noteTimeInTicks);

        if (existingNoteIndex > -1) {
            const removedNote = channelData.notes.splice(existingNoteIndex, 1)[0];
            if (lastActiveNoteId === removedNote.id) lastActiveNoteId = null;
        } else {
            const defaultPitch = 'C4';
            const newNoteId = generateId();
            const newNote = {
                id: newNoteId, time: noteTimeInTicks, pitch: defaultPitch,
                duration: '16n', velocity: 1
            };
            channelData.notes.push(newNote);
            lastActiveNoteId = newNoteId;
            if (!isRecording && channelAudioNodes[selectedChannelIndex] && channelAudioNodes[selectedChannelIndex].synth) {
                channelAudioNodes[selectedChannelIndex].synth.triggerAttackRelease(defaultPitch, '16n', Tone.now());
            }
        }
        updateSequencerGridVisuals();

        // Always advance manualRecordStep after a grid click, whether adding or removing.
        manualRecordStep = (stepIndex + 1) % TOTAL_STEPS;
        updateVisualPlayhead(manualRecordStep, isRecording);

        if (Tone.Transport.state === 'started' && !isRecording) setupTransport();
    }

    function updateSequencerGridVisuals() {
        document.querySelectorAll('.track-row').forEach((trackRowElement, chIndex) => {
            const channelData = projectData.channels[chIndex];
            if (!channelData) return;
            const stepsContainer = trackRowElement.querySelector('.track-steps-container');
            if (!stepsContainer) return;
            stepsContainer.querySelectorAll('.step').forEach((stepDiv, stIndex) => {
                stepDiv.innerHTML = '';
                const stepStartTimeTicks = stIndex * Tone.Time('16n').toTicks();
                const noteAtThisStepStart = channelData.notes.find(note => note.time === stepStartTimeTicks);
                if (noteAtThisStepStart) {
                    const noteIndicator = document.createElement('div');
                    noteIndicator.classList.add('note-indicator');
                    if (noteAtThisStepStart.id === lastActiveNoteId) {
                        noteIndicator.classList.add('last-active-note');
                    }
                    const pitchText = document.createElement('span');
                    pitchText.classList.add('note-pitch-text');
                    pitchText.textContent = noteAtThisStepStart.pitch.replace(/[0-9]/g, '');
                    noteIndicator.appendChild(pitchText);
                    stepDiv.appendChild(noteIndicator);
                }
            });
        });
    }

    function setupTransport() {
        Tone.Transport.bpm.value = parseInt(tempoInput.value);
        Tone.Transport.timeSignature = [BEATS_PER_MEASURE, STEPS_PER_BEAT];
        Tone.Transport.loop = true;
        Tone.Transport.loopStart = 0;
        Tone.Transport.loopEnd = `${NUM_MEASURES}m`;
        Tone.Transport.cancel();
        projectData.channels.forEach((channelData, chIndex) => {
            const audioNodes = channelAudioNodes[chIndex];
            if (!channelData.notes || channelData.notes.length === 0 || !audioNodes || !audioNodes.synth) return;
            channelData.notes.forEach(note => {
                const noteTimeInSeconds = Tone.Time(note.time, "i").toSeconds();
                Tone.Transport.schedule(time => {
                    if (channelAudioNodes[chIndex] && channelAudioNodes[chIndex].synth) {
                        channelAudioNodes[chIndex].synth.triggerAttackRelease(note.pitch, note.duration, time, note.velocity);
                    }
                    if (currentMIDIOutput) {
                        const midiNoteNumber = Tone.Frequency(note.pitch).toMidi();
                        const midiVelocity = Math.round(note.velocity * 127);
                        const midiChannelByte = 0x90 | chIndex;
                        const delayInSeconds = time - Tone.context.currentTime;
                        const midiTimestamp = performance.now() + (delayInSeconds > 0 ? delayInSeconds * 1000 : 0);
                        currentMIDIOutput.send([midiChannelByte, midiNoteNumber, midiVelocity], midiTimestamp);
                        const durationInSeconds = Tone.Time(note.duration).toSeconds();
                        currentMIDIOutput.send([0x80 | chIndex, midiNoteNumber, 0], midiTimestamp + durationInSeconds * 1000 - 10);
                    }
                }, noteTimeInSeconds);
            });
        });
        if(playheadMarker) playheadMarker.dispose();
        playheadMarker = Tone.Transport.scheduleRepeat(time => {
            Tone.Draw.schedule(() => {
                const currentTransportTicks = Tone.Transport.ticks;
                const totalLoopTicks = Tone.Time(Tone.Transport.loopEnd).toTicks();
                const stepTicks = Tone.Time('16n').toTicks();
                currentPlaybackStep = Math.floor((currentTransportTicks % totalLoopTicks) / stepTicks);
                if (!isRecording) {
                    updateVisualPlayhead(currentPlaybackStep, false);
                }
            }, time);
        }, "16n");
    }

    playBtn.addEventListener('click', async () => {
        if (Tone.context.state !== 'running') {
            await Tone.start();
            showMessage("Audio context started!");
        }

        if (isRecording) {
            isRecording = false;
            recordBtn.classList.remove('active');
            updateVisualPlayhead(manualRecordStep, false);
            showMessage("Recording stopped. Press Play to hear sequence.", 3000);
            playBtn.innerHTML = PLAY_SYMBOL;
            playBtn.classList.remove("active");
            setupTransport();
            return;
        }

        if (Tone.Transport.state === 'started') {
            Tone.Transport.pause();
            playBtn.innerHTML = PLAY_SYMBOL;
            playBtn.classList.remove("active");
        } else if (Tone.Transport.state === 'paused') {
            Tone.Transport.start();
            playBtn.innerHTML = PAUSE_SYMBOL;
            playBtn.classList.add("active");
        } else {
            setupTransport();
            Tone.Transport.start();
            playBtn.innerHTML = PAUSE_SYMBOL;
            playBtn.classList.add("active");
        }
    });

    stopBtn.addEventListener('click', () => {
        if (Tone.Transport.state === 'started' || Tone.Transport.state === 'paused') {
            Tone.Transport.stop();
        }
        if(isRecording){
            isRecording = false;
            recordBtn.classList.remove('active');
        }
        Tone.Transport.position = 0;
        currentPlaybackStep = 0;
        manualRecordStep = 0;
        updateVisualPlayhead(0, false);
        playBtn.innerHTML = PLAY_SYMBOL;
        playBtn.classList.remove("active");
        updateSequencerGridVisuals();
    });

    recordBtn.addEventListener('click', () => {
        isRecording = !isRecording;
        recordBtn.classList.toggle('active', isRecording);
        if (isRecording) {
            if (Tone.Transport.state === 'started' || Tone.Transport.state === 'paused') {
                Tone.Transport.stop();
                Tone.Transport.position = 0;
                currentPlaybackStep = 0;
                playBtn.innerHTML = PLAY_SYMBOL;
                playBtn.classList.remove("active");
            }
            // When arming record, set record step to 0 OR to current playback step if preferred
            manualRecordStep = currentPlaybackStep; // Start recording where playback head is
            updateVisualPlayhead(manualRecordStep, true);
            showMessage("Recording armed. Play notes to add.", 3000);
        } else {
            if (Tone.Transport.state !== 'started') {
                updateVisualPlayhead(currentPlaybackStep, false);
            }
            setupTransport();
            updateSequencerGridVisuals();
            showMessage("Recording disarmed.", 2000);
        }
    });

    tempoInput.addEventListener('change', () => {
        projectData.tempo = parseInt(tempoInput.value);
        if (Tone.Transport) Tone.Transport.bpm.value = projectData.tempo;
    });

    masterVolumeSlider.addEventListener('input', (e) => {
        projectData.masterVolume = parseFloat(e.target.value);
        Tone.Destination.volume.value = Tone.gainToDb(projectData.masterVolume);
    });

    async function handleMIDIMessage(event) {
        if (Tone.context.state !== 'running') {
            await Tone.start();
            if (Tone.context.state !== 'running') { console.warn("Audio context not started."); return; }
        }
        const command = event.data[0] >> 4;
        const midiChannelFromDevice = (event.data[0] & 0xf);
        const noteNumber = event.data[1];
        const velocity = event.data[2];

        // If MIDI message is for a specific channel, select that channel
        if (midiChannelFromDevice !== selectedChannelIndex) {
            selectChannel(midiChannelFromDevice);
        }
        // Now selectedChannelIndex is the target for the note

        const pitchName = Tone.Frequency(noteNumber, "midi").toNote();
        const scaledVelocity = velocity / 127;

        if (selectedChannelIndex >= 0 && selectedChannelIndex < NUM_CHANNELS) { // Re-check with updated selectedChannelIndex
            const keyElement = pianoKeysWrapper.querySelector(`.piano-key[data-note="${pitchName}"]`);
            if (command === 9 && velocity > 0) {
                if (channelAudioNodes[selectedChannelIndex] && channelAudioNodes[selectedChannelIndex].synth) {
                    channelAudioNodes[selectedChannelIndex].synth.triggerAttack(pitchName, Tone.now(), scaledVelocity);
                }
                if(keyElement) keyElement.classList.add('pressed');
                if (isRecording && projectData.channels[selectedChannelIndex]) {
                    const stepTicks = Tone.Time('16n').toTicks();
                    const quantizedTimeTicks = manualRecordStep * stepTicks;
                    const newNoteId = generateId();
                    const newNote = {
                        id: newNoteId, time: quantizedTimeTicks, pitch: pitchName,
                        duration: '8n', velocity: scaledVelocity
                    };
                    const notesArray = projectData.channels[selectedChannelIndex].notes;
                    const existingNoteIndex = notesArray.findIndex(n => n.time === quantizedTimeTicks);
                    if (existingNoteIndex > -1) {
                        notesArray.splice(existingNoteIndex, 1, newNote);
                    } else {
                        notesArray.push(newNote);
                    }
                    lastActiveNoteId = newNoteId;
                    updateSequencerGridVisuals();
                    updateVisualPlayhead(manualRecordStep, true);
                    manualRecordStep = (manualRecordStep + 1) % TOTAL_STEPS;
                    updateVisualPlayhead(manualRecordStep, true);
                    if(keyElement) setTimeout(() => keyElement.classList.remove('pressed'), 100);
                }
            }
            else if (command === 8 || (command === 9 && velocity === 0)) {
                if (channelAudioNodes[selectedChannelIndex] && channelAudioNodes[selectedChannelIndex].synth) {
                    channelAudioNodes[selectedChannelIndex].synth.triggerRelease(pitchName, Tone.now());
                }
                if(keyElement) keyElement.classList.remove('pressed');
            }
        }
    }

    function refreshMIDIDeviceSelectors(midiAccess) {
        const previouslySelectedInputId = currentMIDIInput ? currentMIDIInput.id : null;
        const previouslySelectedOutputId = currentMIDIOutput ? currentMIDIOutput.id : null;
        midiInputSelect.innerHTML = '<option value="">No MIDI Input</option>';
        let inputFoundAndRestored = false;
        midiAccess.inputs.forEach(input => {
            const option = document.createElement('option');
            option.value = input.id; option.textContent = input.name;
            midiInputSelect.appendChild(option);
            if (input.id === previouslySelectedInputId) {
                midiInputSelect.value = input.id; inputFoundAndRestored = true;
            }
        });
        if (!inputFoundAndRestored && midiAccess.inputs.size > 0) {
            midiInputSelect.value = midiAccess.inputs.values().next().value.id;
        }
        setMIDIInputDevice(midiInputSelect.value, midiAccess);

        midiOutputSelect.innerHTML = '<option value="">No MIDI Output</option>';
        let outputFoundAndRestored = false;
        midiAccess.outputs.forEach(output => {
            const option = document.createElement('option');
            option.value = output.id; option.textContent = output.name;
            midiOutputSelect.appendChild(option);
            if (output.id === previouslySelectedOutputId) {
                midiOutputSelect.value = output.id; outputFoundAndRestored = true;
            }
        });
        if (!outputFoundAndRestored && midiAccess.outputs.size > 0) {
            midiOutputSelect.value = midiAccess.outputs.values().next().value.id;
        }
        setMIDIOutputDevice(midiOutputSelect.value, midiAccess);
    }

    async function initMIDI() {
        if (navigator.requestMIDIAccess) {
            try {
                midiAccessGlobal = await navigator.requestMIDIAccess({ sysex: false });
                console.log("MIDI Access Granted");
                refreshMIDIDeviceSelectors(midiAccessGlobal);
                if (midiAccessGlobal.inputs.size === 0 && !currentMIDIInput) {
                    showMessage("No MIDI input devices found.", 3000);
                }
                if (midiAccessGlobal.outputs.size === 0 && !currentMIDIOutput) {
                    showMessage("No MIDI output devices found.", 3000);
                }
                midiInputSelect.addEventListener('change', (event) => setMIDIInputDevice(event.target.value, midiAccessGlobal));
                midiOutputSelect.addEventListener('change', (event) => setMIDIOutputDevice(event.target.value, midiAccessGlobal));
                midiAccessGlobal.onstatechange = (event) => {
                    console.log(`MIDI state change: ${event.port.name}, Type: ${event.port.type}, State: ${event.port.state}`);
                    showMessage(`MIDI Device: ${event.port.name} ${event.port.state}. Lists refreshed.`, 3000);
                    refreshMIDIDeviceSelectors(midiAccessGlobal);
                };
            } catch (error) {
                console.error("Could not access MIDI devices:", error);
                showMessage("MIDI Access Denied/Error. Check browser permissions policy for MIDI.", 6000);
            }
        } else {
            console.warn("Web MIDI API not supported.");
            showMessage("Web MIDI API not supported.", 4000);
            midiInputSelect.innerHTML = '<option value="">MIDI N/A</option>'; midiInputSelect.disabled = true;
            midiOutputSelect.innerHTML = '<option value="">MIDI N/A</option>'; midiOutputSelect.disabled = true;
        }
    }

    function setMIDIInputDevice(deviceId, midiAccess) {
        if (currentMIDIInput && currentMIDIInput.id === deviceId && deviceId !== "") return;
        if (currentMIDIInput) {
            currentMIDIInput.onmidimessage = null;
            console.log(`Stopped listening to ${currentMIDIInput.name}`);
        }
        if (!deviceId) {
            if (currentMIDIInput) showMessage("MIDI Input deselected.", 2000);
            currentMIDIInput = null; console.log("MIDI input deselected.");
            midiInputSelect.value = ""; return;
        }
        const newDevice = midiAccess.inputs.get(deviceId);
        if (newDevice) {
            currentMIDIInput = newDevice; currentMIDIInput.onmidimessage = handleMIDIMessage;
            console.log(`Listening to MIDI Input: ${currentMIDIInput.name}`);
            showMessage(`MIDI Input: ${currentMIDIInput.name}`, 2000);
        } else {
            console.error(`Could not find MIDI input: ${deviceId}`);
            if (currentMIDIInput) showMessage("Selected MIDI Input gone.", 3000);
            currentMIDIInput = null; midiInputSelect.value = "";
        }
    }

    function setMIDIOutputDevice(deviceId, midiAccess) {
        if (currentMIDIOutput && currentMIDIOutput.id === deviceId && deviceId !== "") return;
        if (!deviceId) {
            if (currentMIDIOutput) showMessage("MIDI Output deselected.", 2000);
            currentMIDIOutput = null; console.log("MIDI output deselected.");
            midiOutputSelect.value = ""; return;
        }
        const newDevice = midiAccess.outputs.get(deviceId);
        if (newDevice) {
            currentMIDIOutput = newDevice;
            console.log(`Selected MIDI Output: ${currentMIDIOutput.name}`);
            showMessage(`MIDI Output: ${currentMIDIOutput.name}`, 2000);
        } else {
            console.error(`Could not find MIDI output: ${deviceId}`);
            if (currentMIDIOutput) showMessage("Selected MIDI Output gone.", 3000);
            currentMIDIOutput = null; midiOutputSelect.value = "";
        }
    }

    currentProjectNameInput.addEventListener('input', () => {
        projectData.projectName = currentProjectNameInput.value.trim();
        if (!projectData.projectName) projectData.projectName = "Local Groove";
    });

    function checkAndSetInitialRecordState() {
        const isEmpty = projectData.channels.every(channel => channel.notes.length === 0);
        if (isEmpty) {
            isRecording = true;
            recordBtn.classList.add('active');
            showMessage("Grid is empty. Recording armed!", 3000);
            updateVisualPlayhead(manualRecordStep, true);
        }
    }

    async function initializeAppSequence() {
        await initMIDI();
        Tone.Destination.volume.value = Tone.gainToDb(projectData.masterVolume);
        currentProjectNameInput.value = projectData.projectName;
        createPiano(); createChannels();
        updateSequencerGridVisuals();
        checkAndSetInitialRecordState();
        updateVisualPlayhead(isRecording ? manualRecordStep : currentPlaybackStep, isRecording);

        showMessage("Groovesynth 70 Ready (Local Mode)!", 2000);
        document.body.addEventListener('click', async () => {
            if (Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                    console.log("AudioContext started.");
                } catch (e) {
                    console.error("Error starting AudioContext:", e);
                    showMessage("Could not start audio.", 4000);
                }
            }
        }, { once: true });
        window.addEventListener('resize', () => {
            createPiano();
        });
    }
    initializeAppSequence();
</script>
</body>
</html>
