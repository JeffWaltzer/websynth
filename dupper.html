<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Channel Hopper 3000</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bungee+Inline&family=Righteous&family=VT323&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'VT323', monospace; /* Retro computer/console font */
            background-color: #4A3B31; /* Dark Brown - Base for woodgrain */
            background-image:
                    linear-gradient(45deg, rgba(255,255,255,0.03) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.03) 50%, rgba(255,255,255,0.03) 75%, transparent 75%, transparent),
                    linear-gradient(-45deg, rgba(255,255,255,0.03) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.03) 50%, rgba(255,255,255,0.03) 75%, transparent 75%, transparent);
            background-size: 50px 50px;
            color: #F3EAD3; /* Creamy off-white text */
        }
        .font-display { font-family: 'Bungee Inline', cursive; } /* Big, bold 70s display */
        .font-heading { font-family: 'Righteous', cursive; } /* Slightly more readable 70s heading */

        .panel {
            background-color: #795548; /* Medium Brown - Panel Color */
            border: 4px solid #4E342E; /* Darker Brown Border */
            box-shadow: inset 0 0 15px rgba(0,0,0,0.4), 0 8px 15px rgba(0,0,0,0.5);
        }
        .control-panel-bg {
            background-color: #A1887F; /* Lighter, slightly desaturated brown for control surfaces */
            border: 2px solid #5D4037; /* Dark brown accent border */
        }

        select, input[type="number"] { /* Removed input[type="text"] from this rule */
            font-family: 'VT323', monospace;
            background-color: #D7CCC8; /* Light beige/gray for input fields */
            color: #3E2723; /* Dark brown text in inputs */
            border: 2px solid #5D4037; /* Dark brown border for inputs */
            @apply rounded-md p-2 text-lg;
        }
        select:focus, input[type="number"]:focus {
            outline: 2px solid #FFAB00; /* Orange focus outline */
            border-color: #FFAB00;
        }

        .btn {
            font-family: 'Righteous', cursive;
            @apply text-lg py-2 px-5 rounded-lg shadow-md transition-all duration-150 ease-out;
            border-width: 3px;
            border-style: outset;
        }
        .btn-action {
            background-color: #FF8F00; /* Bright 70s Orange */
            border-color: #FFA000 #E65100 #E65100 #FFA000; /* 3D effect for button */
            color: #3E2723; /* Dark Brown text */
        }
        .btn-action:hover { background-color: #FFB300; }
        .btn-action:active { border-style: inset; background-color: #FF6F00; transform: translateY(1px); }

        .btn-toggle {
            background-color: #BF360C; /* Deep Red/Orange */
            border-color: #D84315 #A32F0A #A32F0A #D84315;
            color: #F3EAD3;
        }
        .btn-toggle.active {
            background-color: #2E7D32; /* 70s Green */
            border-color: #388E3C #1B5E20 #1B5E20 #388E3C;
        }
        .btn-toggle:hover { opacity: 0.85; }
        .btn-toggle:active { border-style: inset; transform: translateY(1px); }

        /* Individual Channel Toggles (LED style) */
        .channel-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr); /* 8 channels per row */
            gap: 5px; /* Small gap between toggles */
            padding: 8px;
            background-color: #6D4C41; /* Slightly darker than control panel bg for contrast */
            border-radius: 4px;
            margin-top: 8px; /* Space above the grid */
            border: 1px solid #4E342E;
        }
        .channel-led-toggle {
            display: flex; /* Use flex to center label content */
            align-items: center;
            justify-content: center;
        }
        .channel-led-toggle input[type="checkbox"] {
            display: none; /* Hide actual checkbox */
        }
        .channel-led-toggle .led-display {
            width: 24px; /* Slightly larger for touch */
            height: 24px;
            background-color: #757575; /* Dimmed/Off color - grey */
            border: 2px solid #424242; /* Darker grey border */
            border-radius: 4px; /* Slightly rounded square */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            color: #212121;
            font-size: 12px; /* For channel number */
            font-weight: bold;
        }
        .channel-led-toggle input[type="checkbox"]:checked + .led-display {
            background-color: #FFEB3B; /* Bright Yellow - On color */
            box-shadow: 0 0 8px #FFEB3B, inset 0 0 3px #FBC02D;
            color: #BF360C; /* Dark orange text on yellow */
        }
        .channel-led-toggle input[type="checkbox"]:disabled + .led-display {
            background-color: #545454; /* More dimmed when parent is off */
            cursor: not-allowed;
            opacity: 0.5;
            color: #333;
        }
        .output-device-container {
            display: flex;
            flex-direction: column; /* Stack name/toggle and channel grid */
        }
        .output-device-header { /* Now just contains the name */
            display: flex;
            justify-content: flex-start; /* Align name to the left */
            align-items: center;
            margin-bottom: 8px;
        }

    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4 text-xl selection:bg-orange-500 selection:text-black">

<div class="panel w-full max-w-3xl p-6 md:p-8 rounded-xl">
    <header class="mb-8 text-center">
        <h1 class="font-display text-5xl md:text-6xl text-orange-300" style="text-shadow: 2px 2px #7f1d1d;">MIDI Channel Hopper</h1>
        <p class="font-heading text-yellow-200 mt-2 text-2xl">Route MIDI from one channel to many!</p>
    </header>

    <main class="space-y-8">
        <section class="control-panel-bg p-4 rounded-lg shadow-inner space-y-3">
            <h2 class="font-heading text-2xl text-amber-900 border-b-2 border-amber-800 pb-1">INPUT SOURCE</h2>
            <div>
                <label for="midiInputDevice" class="block mb-1 text-amber-800 font-bold">MIDI Input Device:</label>
                <select id="midiInputDevice" class="w-full">
                    <option value="">Loading devices...</option>
                </select>
            </div>
            <div>
                <label for="midiInputChannel" class="block mb-1 text-amber-800 font-bold">Input Channel (1-16):</label>
                <input type="number" id="midiInputChannel" value="1" min="1" max="16" class="w-24">
            </div>
        </section>

        <section class="control-panel-bg p-4 rounded-lg shadow-inner space-y-3">
            <h2 class="font-heading text-2xl text-amber-900 border-b-2 border-amber-800 pb-1">OUTPUT TARGETS</h2>
            <div id="midiOutputList" class="space-y-6 max-h-72 overflow-y-auto pr-2">
                <p class="text-amber-700">No MIDI output devices found yet.</p>
            </div>
        </section>

        <section class="text-center mt-10">
            <button id="startStopButton" class="btn btn-toggle w-full md:w-1/2 text-2xl">START ROUTING</button>
        </section>

        <section id="statusMessage" class="text-center text-yellow-300 h-6 mt-4"></section>
    </main>

    <footer class="mt-10 text-center">
        <p class="text-sm text-orange-200 opacity-70">A Groovy MIDI Utility &copy; 197X</p>
    </footer>
</div>

<script>
    const midiInputDeviceSelect = document.getElementById('midiInputDevice');
    const midiInputChannelInput = document.getElementById('midiInputChannel');
    const midiOutputListDiv = document.getElementById('midiOutputList');
    const startStopButton = document.getElementById('startStopButton');
    const statusMessage = document.getElementById('statusMessage');

    let midiAccess = null;
    let selectedInputDevice = null;
    // Array of { id, device, name, channelToggles: boolean[16] } - removed 'active'
    let outputTargets = [];
    let isRoutingActive = false;

    // --- Initialization ---
    window.addEventListener('load', initializeApp);

    async function initializeApp() {
        try {
            midiAccess = await navigator.requestMIDIAccess({ sysex: true });
            populateInputDevices();
            populateOutputDevices();
            updateStatus('Select input device and configure outputs.', 'neutral');
        } catch (error) {
            console.error('MIDI Access Error:', error);
            updateStatus(`MIDI Error: ${error.message}. Please grant permission and refresh.`, 'error');
            disableAllControls();
        }
    }

    function populateInputDevices() {
        midiInputDeviceSelect.innerHTML = '<option value="">-- Select Input --</option>';
        if (midiAccess && midiAccess.inputs.size > 0) {
            midiAccess.inputs.forEach(input => {
                const option = document.createElement('option');
                option.value = input.id;
                option.textContent = input.name;
                midiInputDeviceSelect.appendChild(option);
            });
        } else {
            midiInputDeviceSelect.innerHTML = '<option value="">No Inputs Found</option>';
        }
        midiInputDeviceSelect.addEventListener('change', handleInputDeviceChange);
    }

    function handleInputDeviceChange() {
        const inputId = midiInputDeviceSelect.value;
        if (selectedInputDevice) {
            selectedInputDevice.removeEventListener('midimessage', onMidiMessage);
            selectedInputDevice.close().catch(e => console.warn("Error closing previous input:", e));
        }
        if (inputId) {
            selectedInputDevice = midiAccess.inputs.get(inputId);
            if (selectedInputDevice) {
                selectedInputDevice.open()
                    .then(() => {
                        selectedInputDevice.addEventListener('midimessage', onMidiMessage);
                        updateStatus(`Input: ${selectedInputDevice.name}. Ready.`, 'neutral');
                    })
                    .catch(err => {
                        updateStatus(`Error opening ${selectedInputDevice.name}: ${err.message}`, 'error');
                        selectedInputDevice = null;
                    });
            }
        } else {
            selectedInputDevice = null;
        }
    }

    function populateOutputDevices() {
        midiOutputListDiv.innerHTML = '';
        outputTargets = [];

        if (midiAccess && midiAccess.outputs.size > 0) {
            midiAccess.outputs.forEach(output => {
                const target = {
                    id: output.id,
                    device: output,
                    name: output.name,
                    // 'active' property for the main device toggle is removed
                    channelToggles: Array(16).fill(false) // State for each of the 16 output channels
                };
                outputTargets.push(target);

                const deviceContainerDiv = document.createElement('div');
                deviceContainerDiv.className = 'output-device-container p-3 rounded-md bg-amber-600 bg-opacity-30 border border-amber-700';

                const deviceHeaderDiv = document.createElement('div');
                deviceHeaderDiv.className = 'output-device-header';

                const nameLabel = document.createElement('span');
                nameLabel.textContent = output.name;
                nameLabel.className = 'font-bold text-lg text-yellow-100';

                // Main device toggle switch is removed here
                deviceHeaderDiv.appendChild(nameLabel);

                const channelGridDiv = document.createElement('div');
                channelGridDiv.className = 'channel-grid';
                // channelGridDiv.style.display = 'none'; // No longer hidden by default, always visible

                // Create 16 channel toggles
                for (let i = 0; i < 16; i++) {
                    const channelToggleLabel = document.createElement('label');
                    channelToggleLabel.className = 'channel-led-toggle';

                    const channelToggleInput = document.createElement('input');
                    channelToggleInput.type = 'checkbox';
                    // channelToggleInput.disabled = true; // No longer disabled by default
                    channelToggleInput.dataset.channelIndex = i; // Store 0-indexed channel

                    const ledDisplaySpan = document.createElement('span');
                    ledDisplaySpan.className = 'led-display';
                    ledDisplaySpan.textContent = i + 1; // Display 1-16

                    channelToggleInput.addEventListener('change', (e) => {
                        target.channelToggles[i] = e.target.checked;
                        // Attempt to open the port when a channel is first toggled on for this device
                        // This is a simple way to ensure the port is open if not already.
                        if (e.target.checked && !target.device.connection) { // Check if connection state is 'open' or 'pending'
                            target.device.open().catch(err => {
                                updateStatus(`Error opening ${target.name}: ${err.message}`, 'error');
                                // Optionally, uncheck the box or provide more feedback
                                e.target.checked = false;
                                target.channelToggles[i] = false;
                            });
                        }
                    });

                    channelToggleLabel.appendChild(channelToggleInput);
                    channelToggleLabel.appendChild(ledDisplaySpan);
                    channelGridDiv.appendChild(channelToggleLabel);
                }

                deviceContainerDiv.appendChild(deviceHeaderDiv);
                deviceContainerDiv.appendChild(channelGridDiv);
                midiOutputListDiv.appendChild(deviceContainerDiv);
            });
        } else {
            midiOutputListDiv.innerHTML = '<p class="text-amber-700">No MIDI output devices found.</p>';
        }
    }

    // --- MIDI Processing ---
    function onMidiMessage(event) {
        if (!isRoutingActive || !selectedInputDevice) return;

        const inputChannel = parseInt(midiInputChannelInput.value, 10);
        if (isNaN(inputChannel) || inputChannel < 1 || inputChannel > 16) return;

        const message = event.data;
        const statusByte = message[0];
        const messageType = statusByte & 0xF0;
        const originalChannel = (statusByte & 0x0F) + 1; // 1-indexed

        if (originalChannel === inputChannel) {
            outputTargets.forEach(target => {
                // The check for target.active is removed as the main device toggle is gone.
                // We route if any of its channels are active.
                let devicePortOpened = false; // Flag to open port once per device if needed
                target.channelToggles.forEach((isChannelActive, outputChannelZeroIndexed) => {
                    if (isChannelActive) {
                        // Ensure port is open before sending.
                        // This check might be redundant if the channel toggle listener already opened it,
                        // but good for safety.
                        if (!devicePortOpened && (!target.device.connection || target.device.connection === 'closed')) {
                            target.device.open().then(() => {
                                devicePortOpened = true;
                                // Send the message after successful open
                                const newStatusByte = messageType | outputChannelZeroIndexed;
                                const newMessage = [...message];
                                newMessage[0] = newStatusByte;
                                try {
                                    target.device.send(newMessage);
                                } catch (sendError) {
                                    console.error(`Error sending MIDI to ${target.name} on CH ${outputChannelZeroIndexed + 1} after open:`, sendError);
                                }
                            }).catch(openErr => {
                                console.error(`Error opening ${target.name} during send: ${openErr.message}`);
                                // Optionally disable this target's channel or the whole target
                            });
                        } else if (target.device.connection === 'open' || target.device.connection === 'pending') {
                            const newStatusByte = messageType | outputChannelZeroIndexed;
                            const newMessage = [...message];
                            newMessage[0] = newStatusByte;
                            try {
                                target.device.send(newMessage);
                            } catch (error) {
                                console.error(`Error sending MIDI to ${target.name} on channel ${outputChannelZeroIndexed + 1}:`, error);
                            }
                        }
                    }
                });
            });
        }
    }

    // --- Controls ---
    startStopButton.addEventListener('click', () => {
        isRoutingActive = !isRoutingActive;
        const allChannelToggles = document.querySelectorAll('#midiOutputList .channel-led-toggle input[type="checkbox"]');

        if (isRoutingActive) {
            if (!selectedInputDevice) {
                updateStatus('Please select an input device first!', 'error');
                isRoutingActive = false;
                return;
            }
            startStopButton.textContent = 'STOP ROUTING';
            startStopButton.classList.add('active');
            updateStatus('MIDI Routing ACTIVE!', 'success');
            midiInputDeviceSelect.disabled = true;
            midiInputChannelInput.disabled = true;
            allChannelToggles.forEach(cb => cb.disabled = true);

        } else {
            startStopButton.textContent = 'START ROUTING';
            startStopButton.classList.remove('active');
            updateStatus('MIDI Routing STOPPED.', 'neutral');
            midiInputDeviceSelect.disabled = false;
            midiInputChannelInput.disabled = false;
            allChannelToggles.forEach(cb => cb.disabled = false);
        }
    });

    function updateStatus(message, type = 'neutral') {
        statusMessage.textContent = message;
        if (type === 'error') statusMessage.className = 'text-center text-red-400 h-6 mt-4 animate-pulse';
        else if (type === 'success') statusMessage.className = 'text-center text-green-300 h-6 mt-4';
        else statusMessage.className = 'text-center text-yellow-300 h-6 mt-4';
    }

    function disableAllControls() {
        midiInputDeviceSelect.disabled = true;
        midiInputChannelInput.disabled = true;
        startStopButton.disabled = true;
        startStopButton.textContent = 'MIDI UNAVAILABLE';
        const outputControls = midiOutputListDiv.querySelectorAll('input');
        outputControls.forEach(control => control.disabled = true);
    }

</script>
</body>
</html>
