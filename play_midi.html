<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web MIDI Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
        }
        /* Piano Key Styles */
        .piano-wrapper { overflow-x: auto; background: #111; border-radius: 0 0 0.5rem 0.5rem; padding-bottom: 2px; }
        .piano-container { position: relative; display: flex; height: 50px; width: max-content; }
        .white-key { flex: 0 0 20px; height: 100%; background: #fff; border: 1px solid #ccc; border-radius: 0 0 3px 3px; position: relative; z-index: 1; margin-right: 1px; }
        .black-key { position: absolute; width: 12px; height: 60%; background: #222; border-radius: 0 0 3px 3px; z-index: 2; transform: translateX(-50%); box-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        .key-active-white { background: #60a5fa !important; }
        .key-active-black { background: #3b82f6 !important; }
        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar { height: 6px; width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1f2937; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen text-gray-200 p-2 font-sans">

<div class="bg-gray-800 shadow-2xl rounded-xl w-full max-w-6xl p-3 border border-gray-700 flex flex-col gap-2">

    <!-- Top Row: Configuration -->
    <div class="flex flex-wrap items-end gap-3 border-b border-gray-700 pb-2">
        <div class="mr-auto">
            <h1 class="text-lg font-bold text-white tracking-tight leading-tight">üéπ Web MIDI Player</h1>
            <p class="text-gray-400 text-[9px] mt-0.5">Direct hardware playback.</p>
        </div>

        <div class="w-40">
            <label class="block text-[9px] font-medium text-gray-400 mb-0.5 uppercase">1. Output Device</label>
            <select id="device-select" class="w-full bg-gray-900 border border-gray-600 rounded p-1 text-xs text-white focus:outline-none focus:border-blue-500">
                <option disabled>Discovering hardware...</option>
            </select>
        </div>

        <div class="w-48">
            <label class="block text-[9px] font-medium text-gray-400 mb-0.5 uppercase">2. Choose File</label>
            <input type="file" id="file-upload" accept=".mid,.midi" class="block w-full text-[9px] text-gray-400
                    file:mr-1 file:py-0.5 file:px-2 file:rounded file:border-0 file:text-[9px] file:font-semibold
                    file:bg-blue-600 file:text-white hover:file:bg-blue-500 file:cursor-pointer
                    border border-gray-600 rounded cursor-pointer bg-gray-900 p-0.5 h-[24px]">
        </div>

        <div class="w-24">
            <label class="block text-[9px] font-medium text-gray-400 mb-0.5 uppercase">3. Master Routing</label>
            <select id="master-select" class="w-full bg-gray-900 border border-gray-600 rounded p-1 text-[10px] text-white">
                <option value="original">Original</option>
            </select>
        </div>

        <div class="w-20">
            <label class="block text-[9px] font-medium text-gray-400 mb-1 uppercase">Volume</label>
            <input type="range" id="volume-slider" min="0" max="1" step="0.05" value="1" class="w-full accent-blue-500 h-1.5 bg-gray-900 rounded-lg appearance-none cursor-pointer">
        </div>
    </div>

    <div id="midi-error" class="hidden p-2 bg-red-900/40 border border-red-800 rounded text-red-100 text-[10px] leading-relaxed"></div>

    <!-- Track Grid (Dynamic height) -->
    <div class="bg-gray-900/50 border border-gray-700 rounded p-1.5 min-h-[50px]">
        <div id="track-routing-list" class="grid gap-1 content-start relative transition-all duration-300">
            <div class="text-[10px] text-gray-600 italic text-center w-full absolute col-span-full mt-2">Load a file to route tracks</div>
        </div>
    </div>

    <!-- Transport Row -->
    <div class="flex items-center gap-2 bg-gray-900 rounded p-1.5 border border-gray-700">
        <button id="play-btn" disabled class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-1 px-3 rounded text-[11px] transition-colors w-16">Play</button>
        <button id="stop-btn" disabled class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded text-[11px] transition-colors w-16">Stop</button>
        <button id="panic-btn" disabled title="Hard Reset" class="bg-red-700 hover:bg-red-600 text-white font-bold py-1 px-2 rounded text-[11px] w-20">‚ö†Ô∏è Panic</button>

        <div class="flex-1 flex flex-col border-l border-gray-700 ml-1 pl-2 min-w-0">
            <div class="flex items-center justify-between mb-1">
                <span id="status-text" class="text-[10px] font-medium text-blue-400 truncate pr-2">Waiting for file...</span>
                <div class="flex items-center gap-1.5 text-[9px] font-mono text-gray-500 flex-shrink-0">
                    <span id="time-current" class="text-blue-300">0:00</span>
                    <span>/</span>
                    <span id="time-total">0:00</span>
                </div>
            </div>
            <div class="w-full bg-gray-950 rounded-full h-1 overflow-hidden">
                <div id="progress-bar" class="bg-blue-500 h-full w-0"></div>
            </div>
        </div>

        <div class="flex items-center gap-4 flex-shrink-0 border-l border-gray-800 ml-2 pl-3">
            <div class="flex items-center gap-1.5 min-w-[70px]">
                <span class="text-[8px] font-medium text-gray-500 uppercase">Chord:</span>
                <span id="chord-display" class="text-sm font-bold text-yellow-400 truncate tabular-nums">-</span>
            </div>
            <div class="flex items-center gap-1.5 min-w-[90px]">
                <span class="text-[8px] font-medium text-gray-500 uppercase">Scale:</span>
                <span id="scale-display" class="text-[10px] font-bold text-green-400 truncate">-</span>
            </div>
        </div>
    </div>

    <div class="bg-black rounded border border-gray-700 overflow-hidden mt-0.5">
        <div class="piano-wrapper custom-scrollbar" id="piano-scroll">
            <div style="position: relative; width: max-content;">
                <canvas id="visualizer" height="40" class="block bg-gray-900 border-b border-gray-800"></canvas>
                <div id="keyboard" class="piano-container"></div>
            </div>
        </div>
    </div>

    <div id="warnings-container" class="p-1 bg-gray-900 border border-gray-700/50 rounded text-yellow-500 text-[9px] h-12 overflow-y-auto font-mono custom-scrollbar mt-0.5">
        <div class="text-gray-600 mb-1">System Logs & Errors:</div>
    </div>
</div>

<script type="module">
    import MidiPlayer from 'https://cdn.skypack.dev/midi-player-js';

    const GM_INSTRUMENTS = [
        "Grand Piano", "Bright Piano", "E-Grand Piano", "Honky-tonk Piano", "E-Piano 1", "E-Piano 2", "Harpsichord", "Clavinet",
        "Celesta", "Glockenspiel", "Music Box", "Vibraphone", "Marimba", "Xylophone", "Tubular Bells", "Dulcimer",
        "Drawbar Organ", "Percussive Organ", "Rock Organ", "Church Organ", "Reed Organ", "Accordion", "Harmonica", "Tango Accordion",
        "Nylon Guitar", "Steel Guitar", "Jazz Guitar", "Clean Guitar", "Muted Guitar", "Overdriven Guitar", "Distortion Guitar", "Harmonics",
        "Acoustic Bass", "Finger Bass", "Pick Bass", "Fretless Bass", "Slap Bass 1", "Slap Bass 2", "Synth Bass 1", "Synth Bass 2",
        "Violin", "Viola", "Cello", "Contrabass", "Tremolo Strings", "Pizzicato Strings", "Orchestral Harp", "Timpani",
        "String Ensemble 1", "String Ensemble 2", "SynthStrings 1", "SynthStrings 2", "Choir Aahs", "Voice Oohs", "Synth Voice", "Orchestra Hit",
        "Trumpet", "Trombone", "Tuba", "Muted Trumpet", "French Horn", "Brass Section", "SynthBrass 1", "SynthBrass 2",
        "Soprano Sax", "Alto Sax", "Tenor Sax", "Baritone Sax", "Oboe", "English Horn", "Bassoon", "Clarinet",
        "Piccolo", "Flute", "Recorder", "Pan Flute", "Blown Bottle", "Shakuhachi", "Whistle", "Ocarina",
        "Square Lead", "Sawtooth Lead", "Calliope Lead", "Chiff Lead", "Charang Lead", "Voice Lead", "Fifth Lead", "Bass+Lead",
        "New Age Pad", "Warm Pad", "Polysynth Pad", "Choir Pad", "Bowed Pad", "Metallic Pad", "Halo Pad", "Sweep Pad",
        "Rain SFX", "Soundtrack SFX", "Crystal SFX", "Atmosphere SFX", "Brightness SFX", "Goblins SFX", "Echoes SFX", "Sci-Fi SFX",
        "Sitar", "Banjo", "Shamisen", "Koto", "Kalimba", "Bagpipe", "Fiddle", "Shanai",
        "Tinkle Bell", "Agogo", "Steel Drums", "Woodblock", "Taiko Drum", "Melodic Tom", "Synth Drum", "Reverse Cymbal",
        "Guitar Fret Noise", "Breath Noise", "Seashore", "Bird Tweet", "Telephone Ring", "Helicopter", "Applause", "Gunshot"
    ];

    const deviceSelect = document.getElementById('device-select');
    const fileUpload = document.getElementById('file-upload');
    const masterSelect = document.getElementById('master-select');
    const trackRoutingList = document.getElementById('track-routing-list');
    const playBtn = document.getElementById('play-btn');
    const stopBtn = document.getElementById('stop-btn');
    const panicBtn = document.getElementById('panic-btn');
    const statusText = document.getElementById('status-text');
    const midiError = document.getElementById('midi-error');
    const warningsContainer = document.getElementById('warnings-container');
    const chordDisplay = document.getElementById('chord-display');
    const scaleDisplay = document.getElementById('scale-display');
    const progressBar = document.getElementById('progress-bar');
    const timeCurrent = document.getElementById('time-current');
    const timeTotal = document.getElementById('time-total');
    const keyboardContainer = document.getElementById('keyboard');
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    const pianoScroll = document.getElementById('piano-scroll');
    const volumeSlider = document.getElementById('volume-slider');

    let midiAccess = null;
    let selectedOutput = null;
    let audioContext = null;
    let currentFileName = '';
    let currentTrackRouting = {};
    let trackRows = {};
    let activeNotes = {};
    let playingHardwareNotes = new Set();
    let activeTracks = {};
    let keyElements = {};
    let isPanicking = false;
    let autoPaused = false;
    const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    // --- ERROR REPORTING ---
    function displayWarning(msg) {
        const logEntry = document.createElement('div');
        logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        warningsContainer.appendChild(logEntry);
        if (warningsContainer.childElementCount > 30) warningsContainer.removeChild(warningsContainer.children[1]);
        warningsContainer.scrollTop = warningsContainer.scrollHeight;
    }

    window.onerror = function(msg, url, lineNo, columnNo, error) {
        displayWarning(`ERROR: ${msg} (Line: ${lineNo})`);
        return false;
    };

    // Populate Master channels
    for(let i = 1; i <= 16; i++) {
        const opt = document.createElement('option');
        opt.value = i; opt.textContent = `Ch ${i}`;
        masterSelect.appendChild(opt);
    }

    const savedMaster = localStorage.getItem('midi_master_route');
    if (savedMaster) masterSelect.value = savedMaster;

    masterSelect.addEventListener('change', (e) => {
        localStorage.setItem('midi_master_route', e.target.value);
        stopAllNotes();
    });

    function syncSelectedOutput() {
        if (!midiAccess) return;
        const id = deviceSelect.value;
        selectedOutput = midiAccess.outputs.get(id);
        if (selectedOutput) {
            statusText.textContent = `Active: ${selectedOutput.name}`;
        }
    }

    deviceSelect.addEventListener('change', () => {
        stopAllNotes();
        syncSelectedOutput();
    });

    function getNoteName(midiNumber) {
        const name = NOTE_NAMES[midiNumber % 12];
        const octave = Math.floor(midiNumber / 12) - 1;
        return name + octave;
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function updateTrackGridLayout() {
        const numTracks = Object.keys(trackRows).length;
        if (numTracks === 0) return;
        let maxCols = 8;
        if (window.innerWidth < 640) maxCols = 2;
        else if (window.innerWidth < 1024) maxCols = 4;
        const rows = Math.ceil(numTracks / maxCols);
        const cols = Math.ceil(numTracks / rows);
        trackRoutingList.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`;
    }
    window.addEventListener('resize', updateTrackGridLayout);

    const CHORD_TYPES = {
        '0,4,7': ' Maj', '0,3,7': ' Min', '0,3,6': ' Dim', '0,4,8': ' Aug',
        '0,2,7': ' Sus2', '0,5,7': ' Sus4', '0,4,7,11': ' Maj7', '0,3,7,10': ' Min7',
        '0,4,7,10': ' Dom7', '0,3,6,9': ' Dim7', '0,3,6,10': ' m7b5', '0,7': '5'
    };

    const SCALE_TYPES = {
        '0,2,4,5,7,9,11': 'Major', '0,2,3,5,7,8,10': 'Minor', '0,2,3,5,7,9,10': 'Dorian',
        '0,1,3,5,7,8,10': 'Phrygian', '0,2,4,6,7,9,11': 'Lydian', '0,2,4,5,7,9,10': 'Mixolydian',
        '0,1,3,5,6,8,10': 'Locrian', '0,2,4,7,9': 'Maj Pentatonic', '0,3,5,7,10': 'Min Pentatonic'
    };

    function updateTheoryDisplay() {
        const activeKeys = Object.keys(activeNotes).map(Number);
        if (activeKeys.length === 0) {
            chordDisplay.textContent = '-'; scaleDisplay.textContent = '-'; return;
        }
        const pitches = [...new Set(activeKeys.map(n => n % 12))].sort((a, b) => a - b);

        let guessedChord = '-';
        for (let root = 0; root < 12; root++) {
            const intervals = pitches.map(p => (p - root + 12) % 12).sort((a, b) => a - b);
            if (CHORD_TYPES[intervals.join(',')]) {
                guessedChord = NOTE_NAMES[root] + CHORD_TYPES[intervals.join(',')];
                break;
            }
        }
        chordDisplay.textContent = guessedChord;

        let guessedScale = '-';
        for (let root = 0; root < 12; root++) {
            for (const [pattern, name] of Object.entries(SCALE_TYPES)) {
                const scaleIntervals = pattern.split(',').map(Number);
                if (pitches.every(p => scaleIntervals.includes((p - root + 12) % 12))) {
                    guessedScale = NOTE_NAMES[root] + ' ' + name;
                    break;
                }
            }
            if (guessedScale !== '-') break;
        }
        scaleDisplay.textContent = guessedScale;
    }

    function uiLoop() {
        if (typeof midiPlayer !== 'undefined' && midiPlayer.isPlaying()) {
            const progress = midiPlayer.getSongPercent() || 0;
            progressBar.style.width = `${progress}%`;
            const totalSecs = midiPlayer.getSongTime() || 0;
            timeCurrent.textContent = formatTime((progress / 100) * totalSecs);
            updateTheoryDisplay();
        }
        requestAnimationFrame(uiLoop);
    }

    function buildKeyboard() {
        const whiteNotes = [0, 2, 4, 5, 7, 9, 11];
        let whiteKeyCount = 0;
        for (let note = 21; note <= 108; note++) {
            const isWhite = whiteNotes.includes(note % 12);
            const keyDiv = document.createElement('div');
            keyDiv.dataset.note = note;
            if (isWhite) {
                keyDiv.className = 'white-key';
                keyboardContainer.appendChild(keyDiv);
                whiteKeyCount++;
            } else {
                keyDiv.className = 'black-key';
                keyDiv.style.left = `${whiteKeyCount * 21}px`;
                keyboardContainer.appendChild(keyDiv);
            }
            keyElements[note] = keyDiv;
        }
        canvas.width = whiteKeyCount * 21;
    }
    buildKeyboard();

    function drawVisualizer() {
        ctx.fillStyle = 'rgba(17, 24, 39, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (const [note, data] of Object.entries(activeNotes)) {
            if (data.velocity > 0 && keyElements[note]) {
                const keyEl = keyElements[note];
                const isBlack = keyEl.classList.contains('black-key');
                const left = isBlack ? keyEl.offsetLeft - 7 : keyEl.offsetLeft;
                const height = (data.velocity / 127) * (canvas.height - 10);
                ctx.fillStyle = `rgba(96, 165, 250, 0.8)`;
                ctx.fillRect(left, canvas.height - height, isBlack ? 12 : 20, height);
                if (data.tracks && data.tracks.size > 0) {
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 8px sans-serif';
                    ctx.fillText(Array.from(data.tracks).join(','), left + 2, canvas.height - height - 2);
                }
            }
        }
        requestAnimationFrame(drawVisualizer);
    }

    function initMIDI() {
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess({ sysex: false })
                .then(onMIDISuccess)
                .catch(onMIDIFailure);
        } else {
            onMIDIFailure(new Error("Web MIDI API not supported."));
        }
    }
    initMIDI();

    function onMIDISuccess(access) {
        statusText.textContent = "Scanning for MIDI hardware...";
        midiAccess = access;
        refreshOutputs();
        midiAccess.onstatechange = refreshOutputs;
    }

    function refreshOutputs() {
        if (!midiAccess) return;
        const outputs = Array.from(midiAccess.outputs.values());
        const currentSelectedId = deviceSelect.value;

        deviceSelect.innerHTML = '';
        if (outputs.length === 0) {
            deviceSelect.innerHTML = '<option disabled>No outputs found</option>';
            selectedOutput = null;
            panicBtn.disabled = true;
            return;
        }

        outputs.forEach((output, idx) => {
            const opt = document.createElement('option');
            opt.value = output.id;
            opt.textContent = output.name;
            if (output.id === currentSelectedId) opt.selected = true;
            deviceSelect.appendChild(opt);
        });

        syncSelectedOutput();
        panicBtn.disabled = false;
    }

    function onMIDIFailure(err) {
        deviceSelect.innerHTML = '<option disabled>MIDI Blocked</option>';
        midiError.classList.remove('hidden');
        if (err.name === 'SecurityError') {
            midiError.innerHTML = `<strong>‚ö†Ô∏è Hardware MIDI blocked.</strong> Web MIDI is restricted in iframes.<br/>To fix: Save this file locally and open it directly in Chrome/Edge.`;
        } else {
            midiError.textContent = "MIDI Access Error: " + err.message;
        }
    }

    function stopAllNotes() {
        if (isPanicking || !selectedOutput) return;
        for (let ch = 0; ch < 16; ch++) { try { selectedOutput.send([0xB0 + ch, 123, 0]); } catch (e) {} }
        playingHardwareNotes.forEach(noteId => {
            const [ch, note] = noteId.split('-').map(Number);
            try { selectedOutput.send([0x80 + ch, note, 0]); } catch(e){}
        });
        playingHardwareNotes.clear(); activeNotes = {}; activeTracks = {};
        document.querySelectorAll('.key-active-white, .key-active-black').forEach(el => el.classList.remove('key-active-white', 'key-active-black'));
        Object.values(trackRows).forEach(row => { row.style.borderColor = 'transparent'; row.style.backgroundColor = ''; });
    }

    function executePanic() {
        if (!selectedOutput || isPanicking) return;
        isPanicking = true;
        midiPlayer.stop(); playBtn.textContent = "Play";
        stopAllNotes();
        statusText.textContent = "üö® PANIC: Initializing hardware reset...";
        let ch = 0;
        const itv = setInterval(() => {
            if (ch >= 16) {
                clearInterval(itv); isPanicking = false; statusText.textContent = "‚úÖ Panic complete."; return;
            }
            statusText.textContent = `üö® PANIC: Clearing Ch ${ch + 1}/16...`;
            for (let n = 0; n < 128; n++) { try { selectedOutput.send([0x80 + ch, n, 0]); } catch(e){} }
            ch++;
        }, 30);
    }

    function sanitize(val) {
        if (typeof val !== 'number' || isNaN(val)) return 0;
        return Math.max(0, Math.min(127, Math.floor(val)));
    }

    const midiPlayer = new MidiPlayer.Player(function(event) {
        if (!selectedOutput || isPanicking) return;

        try {
            const trackNum = event.track;
            const setRoute = currentTrackRouting[trackNum] || 'master';
            if (setRoute === 'mute') return;

            let ch;
            if (setRoute === 'master') {
                const mVal = masterSelect.value;
                ch = (mVal === 'original') ? (event.channel - 1 || 0) : (parseInt(mVal) - 1);
            } else if (setRoute === 'original') {
                ch = (event.channel - 1 || 0);
            } else {
                ch = parseInt(setRoute) - 1;
            }
            ch = Math.max(0, Math.min(15, ch));

            let status = 0, d1 = 0, d2 = 0;

            if (event.name === 'Note on' || event.name === 'Note off') {
                const isOff = event.name === 'Note off' || event.velocity === 0;
                status = isOff ? (0x80 + ch) : (0x90 + ch);
                d1 = event.noteNumber;
                d2 = Math.floor((event.velocity || 0) * parseFloat(volumeSlider.value));

                if (!isOff && d2 > 0) {
                    playingHardwareNotes.add(`${ch}-${d1}`);
                    if (!activeNotes[d1]) activeNotes[d1] = { velocity: 0, tracks: new Set() };
                    activeNotes[d1].velocity = d2; activeNotes[d1].tracks.add(trackNum);
                    if (keyElements[d1]) keyElements[d1].classList.add(keyElements[d1].classList.contains('white-key') ? 'key-active-white' : 'key-active-black');
                    if (!activeTracks[trackNum]) activeTracks[trackNum] = new Set();
                    activeTracks[trackNum].add(d1);
                } else {
                    playingHardwareNotes.delete(`${ch}-${d1}`);
                    if (activeNotes[d1]) {
                        activeNotes[d1].tracks.delete(trackNum);
                        if (activeNotes[d1].tracks.size === 0) {
                            delete activeNotes[d1];
                            if (keyElements[d1]) keyElements[d1].classList.remove('key-active-white', 'key-active-black');
                        }
                    }
                    if (activeTracks[trackNum]) activeTracks[trackNum].delete(d1);
                }

                const row = trackRows[trackNum];
                if (row) {
                    const notes = activeTracks[trackNum];
                    if (notes && notes.size > 0) {
                        const hue = (Math.max(...Array.from(notes)) % 12) * 30;
                        row.style.borderColor = `hsl(${hue}, 80%, 55%)`; row.style.backgroundColor = `hsla(${hue}, 80%, 40%, 0.3)`;
                    } else { row.style.borderColor = 'transparent'; row.style.backgroundColor = ''; }
                }
            } else if (event.name === 'Controller Change') { status = 0xB0+ch; d1 = event.number; d2 = event.value; }
            else if (event.name === 'Program Change') { status = 0xC0+ch; d1 = event.value; }
            else if (event.name === 'Pitch Bend') { status = 0xE0+ch; d1 = event.value & 0x7F; d2 = (event.value >> 7) & 0x7F; }

            if (status > 0) selectedOutput.send([status, d1, d2].filter(v => v !== undefined));
        } catch (e) {}
    });

    midiPlayer.on('end', () => {
        statusText.textContent = "Playback finished."; playBtn.textContent = "Play";
        stopAllNotes(); progressBar.style.width = '0%';
    });

    fileUpload.addEventListener('change', function(e) {
        const file = e.target.files[0]; if (!file) return;
        midiPlayer.stop(); stopAllNotes();

        statusText.textContent = `1/4: Reading binary: ${file.name}...`;
        const reader = new FileReader();
        reader.onload = (evt) => {
            try {
                statusText.textContent = "2/4: Parsing MIDI sequence data...";
                midiPlayer.loadArrayBuffer(evt.target.result);
                currentFileName = file.name;
                timeTotal.textContent = formatTime(midiPlayer.getSongTime() || 0);

                statusText.textContent = `3/4: Analyzing ${midiPlayer.events.length} tracks...`;
                let saved = {}; try { saved = JSON.parse(localStorage.getItem(`midi_routing_${file.name}`)) || {}; } catch(e){}

                currentTrackRouting = {}; trackRows = {}; trackRoutingList.innerHTML = '';
                midiPlayer.events.forEach((events, idx) => {
                    const trackNum = idx + 1;
                    let firstCh = -1, name = `Track ${trackNum}`, inst = "", notes = 0;
                    let minNote = 127, maxNote = 0;

                    for(let i=0; i<events.length; i++) {
                        const ev = events[i];
                        if (firstCh === -1 && typeof ev.channel === 'number') firstCh = ev.channel;
                        if (ev.name === 'Track Name') name = ev.string;
                        if (ev.name === 'Instrument Name') inst = ev.string;
                        if (!inst && ev.name === 'Program Change') inst = GM_INSTRUMENTS[ev.value];
                        if (ev.name === 'Note on' && ev.velocity > 0) {
                            notes++;
                            if (ev.noteNumber < minNote) minNote = ev.noteNumber;
                            if (ev.noteNumber > maxNote) maxNote = ev.noteNumber;
                        }
                    }

                    if (firstCh === -1 && notes === 0) return;

                    const val = saved[trackNum] || 'master';
                    currentTrackRouting[trackNum] = val;

                    const rangeStr = notes > 0 ? `${getNoteName(minNote)} - ${getNoteName(maxNote)}` : "None";

                    const row = document.createElement('div');
                    row.className = 'flex items-center justify-between bg-gray-800 p-1 rounded border border-transparent min-w-0 h-[48px]';
                    row.innerHTML = `<div class="flex flex-col overflow-hidden mr-1 flex-1 leading-[1.1]">
                            <span class="text-[9px] font-semibold text-gray-200 truncate" title="${name}">${name}</span>
                            ${inst ? `<span class="text-[8px] text-blue-300/80 truncate italic">${inst}</span>` : ''}
                            <span class="text-[7px] text-gray-500 uppercase leading-none">Ch ${firstCh} ‚Ä¢ ${notes} notes</span>
                            <span class="text-[7px] text-gray-400 mt-0.5">Range: ${rangeStr}</span>
                        </div>
                        <select class="bg-gray-900 border border-gray-600 rounded py-0 px-0.5 text-[9px] text-white w-[52px] h-[18px]">
                            <option value="master">Master</option><option value="original">Orig</option>
                            ${Array.from({length:16}, (_,i)=>`<option value="${i+1}">Ch ${i+1}</option>`).join('')}
                            <option value="mute">Mute</option>
                        </select>`;
                    const sel = row.querySelector('select'); sel.value = val;
                    sel.addEventListener('change', (ev) => {
                        currentTrackRouting[trackNum] = ev.target.value; stopAllNotes();
                        try { saved[trackNum] = ev.target.value; localStorage.setItem(`midi_routing_${file.name}`, JSON.stringify(saved)); } catch(e){}
                    });
                    trackRows[trackNum] = row; trackRoutingList.appendChild(row);
                });

                statusText.textContent = "4/4: Initializing hardware mapping...";
                updateTrackGridLayout();
                statusText.textContent = `Ready: ${file.name}`;
                playBtn.disabled = false; stopBtn.disabled = false;
            } catch(e) {
                statusText.textContent = "Error: Invalid or corrupted MIDI file.";
            }
        };
        reader.readAsArrayBuffer(file);
    });

    playBtn.addEventListener('click', async () => {
        if (midiAccess) refreshOutputs();
        if (!selectedOutput) {
            alert("Please select a MIDI Output device in Step 1."); return;
        }

        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') await audioContext.resume();

        if (midiPlayer.isPlaying()) {
            midiPlayer.pause(); stopAllNotes(); playBtn.textContent = "Play";
            statusText.textContent = "Paused.";
        } else {
            midiPlayer.play(); playBtn.textContent = "Pause";
            statusText.textContent = "‚ñ∂ Playing...";
        }
    });

    stopBtn.addEventListener('click', () => {
        midiPlayer.stop(); stopAllNotes(); playBtn.textContent = "Play";
        statusText.textContent = "Playback stopped."; progressBar.style.width = '0%';
    });

    panicBtn.addEventListener('click', executePanic);

    // Start animation and UI loops only after everything is ready
    uiLoop();
    drawVisualizer();

</script>
</body>
</html>