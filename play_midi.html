<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web MIDI Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
        }
        /* Piano Key Styles */
        .piano-wrapper { overflow-x: auto; background: #111; border-radius: 0 0 0.5rem 0.5rem; padding-bottom: 4px; }
        .piano-container { position: relative; display: flex; height: 120px; width: max-content; }
        .white-key { flex: 0 0 30px; height: 100%; background: #fff; border: 1px solid #ccc; border-radius: 0 0 4px 4px; position: relative; z-index: 1; margin-right: 1px; }
        .black-key { position: absolute; width: 20px; height: 60%; background: #222; border-radius: 0 0 4px 4px; z-index: 2; transform: translateX(-50%); box-shadow: 1px 1px 3px rgba(0,0,0,0.5); }
        .key-active-white { background: #60a5fa !important; }
        .key-active-black { background: #3b82f6 !important; }
        /* Custom Scrollbar for the piano */
        .piano-wrapper::-webkit-scrollbar { height: 8px; }
        .piano-wrapper::-webkit-scrollbar-track { background: #1f2937; border-radius: 4px; }
        .piano-wrapper::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        .piano-wrapper::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen text-gray-200 p-4 font-sans">

<div class="bg-gray-800 shadow-2xl rounded-2xl w-full max-w-4xl p-8 border border-gray-700">

    <div class="text-center mb-8">
        <h1 class="text-3xl font-bold text-white tracking-tight mb-2">üéπ Web MIDI Player</h1>
        <p class="text-gray-400 text-sm">Play .mid files directly to your hardware devices.</p>
    </div>

    <!-- 1. Output Device Selection -->
    <div class="mb-5">
        <label class="block text-sm font-medium text-gray-400 mb-1">1. Select MIDI Output Device</label>
        <select id="device-select" class="w-full bg-gray-900 border border-gray-600 rounded-lg p-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50">
            <option disabled>Requesting MIDI Access...</option>
        </select>
        <!-- Enhanced Error Message Container -->
        <div id="midi-error" class="hidden mt-3 p-4 bg-red-900/40 border border-red-800 rounded-lg text-red-200 text-sm"></div>
    </div>

    <!-- 2. Channel Selection -->
    <div class="mb-5">
        <label class="block text-sm font-medium text-gray-400 mb-1">2. Select MIDI Channel</label>
        <select id="channel-select" class="w-full bg-gray-900 border border-gray-600 rounded-lg p-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
            <option value="all">Keep Original Channels (Default)</option>
            <!-- Generated options 1-16 via JS -->
        </select>
    </div>

    <!-- 3. File Upload -->
    <div class="mb-6">
        <label class="block text-sm font-medium text-gray-400 mb-1">3. Choose a MIDI File (.mid)</label>
        <input type="file" id="file-upload" accept=".mid,.midi" class="block w-full text-sm text-gray-400
                file:mr-4 file:py-2.5 file:px-4
                file:rounded-lg file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-600 file:text-white
                hover:file:bg-blue-500 file:cursor-pointer
                border border-gray-600 rounded-lg cursor-pointer bg-gray-900">
    </div>

    <!-- Status & Controls -->
    <div class="bg-gray-900 rounded-lg p-4 mb-6 border border-gray-700">
        <p class="text-xs text-gray-500 uppercase tracking-wider mb-1">Playback Status</p>
        <p id="status-text" class="text-sm font-medium text-blue-400 truncate transition-colors duration-200">Waiting for file...</p>
    </div>

    <div class="flex gap-4">
        <button id="play-btn" disabled class="flex-1 bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
            Play
        </button>
        <button id="stop-btn" disabled class="flex-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
            Stop
        </button>
        <button id="panic-btn" disabled title="Send All Notes Off to all channels (Spaced)" class="flex-1 bg-red-700 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2">
            <span>‚ö†Ô∏è</span> Panic
        </button>
    </div>

    <!-- 4. Advanced Controls & Visuals -->
    <div class="mt-8 border-t border-gray-700 pt-6">
        <div class="flex items-center justify-between mb-4">
            <label class="text-sm font-medium text-gray-400">Volume Scaling</label>
            <input type="range" id="volume-slider" min="0" max="1" step="0.05" value="1" class="w-48 accent-blue-500">
        </div>

        <div class="bg-black rounded-lg border border-gray-700 overflow-hidden shadow-inner">
            <div class="piano-wrapper" id="piano-scroll">
                <div style="position: relative; width: max-content;">
                    <!-- Note Visualizer Canvas -->
                    <canvas id="visualizer" height="120" class="block bg-gray-900 border-b border-gray-800"></canvas>

                    <!-- Piano Keyboard -->
                    <div id="keyboard" class="piano-container">
                        <!-- Keys generated by JS -->
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>

<script type="module">
    import MidiPlayer from 'https://cdn.skypack.dev/midi-player-js';

    // DOM Elements
    const deviceSelect = document.getElementById('device-select');
    const channelSelect = document.getElementById('channel-select');
    const fileUpload = document.getElementById('file-upload');
    const playBtn = document.getElementById('play-btn');
    const stopBtn = document.getElementById('stop-btn');
    const panicBtn = document.getElementById('panic-btn');
    const statusText = document.getElementById('status-text');
    const midiError = document.getElementById('midi-error');

    // Visual elements
    const volumeSlider = document.getElementById('volume-slider');
    const keyboardContainer = document.getElementById('keyboard');
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    const pianoScroll = document.getElementById('piano-scroll');

    let midiAccess = null;
    let selectedOutput = null;

    let activeNotes = {}; // Track active notes purely for canvas visuals
    let playingHardwareNotes = new Set(); // Specifically track notes playing on hardware to avoid MIDI choke
    let keyElements = {}; // Map note number to DOM element

    let isPanicking = false; // State flag to prevent overlapping panic commands
    let autoPaused = false; // Track if the player paused automatically due to focus loss

    // Initialize Keyboard (88 keys: A0 to C8, MIDI notes 21 to 108)
    function buildKeyboard() {
        const whiteNotes = [0, 2, 4, 5, 7, 9, 11]; // C, D, E, F, G, A, B
        let whiteKeyCount = 0;

        for (let note = 21; note <= 108; note++) {
            const noteInOctave = note % 12;
            const isWhite = whiteNotes.includes(noteInOctave);

            const keyDiv = document.createElement('div');
            keyDiv.dataset.note = note;

            if (isWhite) {
                keyDiv.className = 'white-key';
                keyboardContainer.appendChild(keyDiv);
                whiteKeyCount++;
            } else {
                keyDiv.className = 'black-key';
                keyDiv.style.left = `${whiteKeyCount * 31}px`;
                keyboardContainer.appendChild(keyDiv);
            }
            keyElements[note] = keyDiv;
        }

        // Set canvas width to perfectly match the piano
        canvas.width = whiteKeyCount * 31;

        // Center the scroll view around middle C (Note 60)
        setTimeout(() => {
            const middleC = keyElements[60];
            if (middleC && pianoScroll) {
                pianoScroll.scrollLeft = middleC.offsetLeft - (pianoScroll.clientWidth / 2);
            }
        }, 100);
    }
    buildKeyboard();

    // Visualizer Animation Loop
    function drawVisualizer() {
        // Fade effect
        ctx.fillStyle = 'rgba(17, 24, 39, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (const [note, velocity] of Object.entries(activeNotes)) {
            if (velocity > 0 && keyElements[note]) {
                const keyEl = keyElements[note];
                const isBlack = keyEl.classList.contains('black-key');
                const width = keyEl.offsetWidth;

                // Black keys are absolutely positioned and visually translated by -50%.
                // offsetLeft ignores transforms, so we must calculate the true visual left position.
                const left = isBlack ? keyEl.offsetLeft - (width / 2) : keyEl.offsetLeft;

                // Height scales slightly with velocity
                const height = (velocity / 127) * canvas.height;
                const y = canvas.height - height;

                // Color based on velocity
                const alpha = 0.5 + (velocity / 127) * 0.5;
                ctx.fillStyle = `rgba(96, 165, 250, ${alpha})`; // Tailwind blue-400

                // Draw a bar representing the note extending upwards from the keys
                ctx.fillRect(left, y, width, height);
            }
        }
        requestAnimationFrame(drawVisualizer);
    }
    drawVisualizer();

    // Populate Channel Dropdown (1-16)
    for (let i = 0; i < 16; i++) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = `Force Channel ${i + 1}`;
        channelSelect.appendChild(opt);
    }

    // Initialize Web MIDI API
    if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess({ sysex: false }).then(onMIDISuccess, onMIDIFailure);
    } else {
        onMIDIFailure(new Error("Web MIDI API not supported in this browser."));
    }

    function onMIDISuccess(access) {
        midiAccess = access;
        refreshOutputs();

        // Listen for device connections/disconnections
        midiAccess.onstatechange = refreshOutputs;
    }

    function refreshOutputs() {
        const outputs = Array.from(midiAccess.outputs.values());
        deviceSelect.innerHTML = '';

        if (outputs.length === 0) {
            const opt = document.createElement('option');
            opt.disabled = true;
            opt.textContent = 'No MIDI outputs detected';
            deviceSelect.appendChild(opt);
            selectedOutput = null;
            panicBtn.disabled = true;
            return;
        }

        outputs.forEach(output => {
            const opt = document.createElement('option');
            opt.value = output.id;
            opt.textContent = output.name;
            deviceSelect.appendChild(opt);
        });

        selectedOutput = midiAccess.outputs.get(deviceSelect.value);
        panicBtn.disabled = false; // Enable panic if we have a device

        deviceSelect.addEventListener('change', (e) => {
            stopAllNotes(); // Make sure to stop notes on the OLD device before switching
            selectedOutput = midiAccess.outputs.get(e.target.value);
        });
    }

    function onMIDIFailure(err) {
        console.error("MIDI Access Error:", err);
        deviceSelect.innerHTML = '<option disabled>Error accessing MIDI</option>';
        midiError.classList.remove('hidden');
        panicBtn.disabled = true;

        // Provide a graceful explanation for the SecurityError encountered in iframes
        if (err.name === 'SecurityError') {
            midiError.innerHTML = `<strong>‚ö†Ô∏è Hardware MIDI is blocked in this preview environment.</strong><br/><br/>
                For security reasons, web browsers block Web MIDI access inside embedded previews (iframes). <br/><br/>
                <strong>How to fix:</strong> Save this code to a local <code>.html</code> file on your computer and open it directly in Chrome, Edge, or Opera.`;
        } else {
            midiError.textContent = "Please allow MIDI permissions in your browser to use this app.";
        }
    }

    // Standard targeted note stop (Kept gentle for playback stops/channel routing changes)
    function stopAllNotes() {
        if (!selectedOutput || isPanicking) return;

        // Send standard All Notes Off (CC 123) just as a gentle baseline.
        for (let ch = 0; ch < 16; ch++) {
            try { selectedOutput.send([0xB0 + ch, 123, 0]); } catch (e) {}
        }

        // Targeted Note-Offs safely caught
        playingHardwareNotes.forEach(noteId => {
            const [chStr, noteStr] = noteId.split('-');
            const ch = parseInt(chStr);
            const note = parseInt(noteStr);
            if (!isNaN(ch) && !isNaN(note)) {
                try { selectedOutput.send([0x80 + ch, note, 0]); } catch (e) {}
            }
        });

        playingHardwareNotes.clear();

        // Clear active UI visuals
        activeNotes = {};
        document.querySelectorAll('.key-active-white, .key-active-black').forEach(el => {
            el.classList.remove('key-active-white', 'key-active-black');
        });
    }

    // PANIC SEQUENCE: Deep hardware reset (Spaced out to prevent choking)
    function executePanic() {
        if (!selectedOutput || isPanicking) return;
        isPanicking = true;
        autoPaused = false;

        // Stop playback if running
        if (midiPlayer.isPlaying()) {
            midiPlayer.stop();
            playBtn.textContent = "Play";
        }

        // Lock UI
        playBtn.disabled = true;
        stopBtn.disabled = true;
        panicBtn.disabled = true;
        fileUpload.disabled = true;

        statusText.textContent = "üö® PANIC: Initializing hardware reset...";
        statusText.classList.remove('text-blue-400');
        statusText.classList.add('text-red-400', 'animate-pulse');

        // 1. Send all stop/reset CC messages immediately across all channels
        for (let ch = 0; ch < 16; ch++) {
            try {
                selectedOutput.send([0xB0 + ch, 120, 0]); // All Sound Off
                selectedOutput.send([0xB0 + ch, 121, 0]); // Reset All Controllers
                selectedOutput.send([0xB0 + ch, 123, 0]); // All Notes Off
            } catch(e) {}
        }

        // Clear visual state
        activeNotes = {};
        document.querySelectorAll('.key-active-white, .key-active-black').forEach(el => {
            el.classList.remove('key-active-white', 'key-active-black');
        });
        playingHardwareNotes.clear();

        // 2. Throttled Note-Off Blast (Send 128 Note-Offs per channel, spaced by 30ms to prevent MIDI Choke)
        let currentChannel = 0;

        const panicInterval = setInterval(() => {
            if (currentChannel >= 16) {
                // Panic process finished
                clearInterval(panicInterval);
                isPanicking = false;

                // Unlock UI
                if (midiPlayer.totalTicks > 0) {
                    playBtn.disabled = false;
                    stopBtn.disabled = false;
                }
                panicBtn.disabled = false;
                fileUpload.disabled = false;

                statusText.classList.remove('text-red-400', 'animate-pulse');
                statusText.classList.add('text-green-400');
                statusText.textContent = "‚úÖ Panic complete. All channels clear.";

                // Revert text to blue after a moment
                setTimeout(() => {
                    statusText.classList.remove('text-green-400');
                    statusText.classList.add('text-blue-400');
                    if (!midiPlayer.isPlaying()) {
                        statusText.textContent = "Ready to play.";
                    }
                }, 2000);
                return;
            }

            // Send 128 Note-Offs for the current channel
            for (let note = 0; note < 128; note++) {
                try { selectedOutput.send([0x80 + currentChannel, note, 0]); } catch(e){}
            }

            // Update UI Feedback
            statusText.textContent = `üö® PANIC: Clearing notes on Channel ${currentChannel + 1}/16...`;
            currentChannel++;

        }, 30); // 30ms throttle between channels. Total execution time: ~480ms
    }

    // Helper to prevent Web MIDI API DOMExceptions by forcing valid 0-127 integer payloads
    function sanitize(val) {
        if (typeof val !== 'number' || isNaN(val)) return 0;
        return Math.max(0, Math.min(127, Math.floor(val)));
    }

    // Configure the MIDI Player
    const midiPlayer = new MidiPlayer.Player(function(event) {
        if (!selectedOutput || isPanicking) return; // Prevent sending notes during panic

        const forceChannel = channelSelect.value;
        // MidiPlayer channels are 1-16 natively, standard MIDI format expects 0-15
        let ch = forceChannel !== 'all' ? parseInt(forceChannel) : (event.channel - 1);

        // Safety fallback
        if (isNaN(ch) || ch < 0 || ch > 15) ch = 0;

        let statusByte;
        let data1 = null;
        let data2 = null;

        // Map player events to raw MIDI bytes and sanitize inputs!
        // Bad values here crash the entire player silently!
        switch (event.name) {
            case 'Note on':
                statusByte = 0x90 + ch;
                data1 = sanitize(event.noteNumber);
                data2 = sanitize((event.velocity || 0) * parseFloat(volumeSlider.value));

                // Hardware Tracking & UI Update
                if (data2 > 0) {
                    playingHardwareNotes.add(`${ch}-${data1}`); // Track for safe turn-off
                    activeNotes[data1] = data2;
                    if (keyElements[data1]) {
                        const isWhite = keyElements[data1].classList.contains('white-key');
                        keyElements[data1].classList.add(isWhite ? 'key-active-white' : 'key-active-black');
                    }
                } else {
                    // Velocity 0 is effectively a Note Off
                    playingHardwareNotes.delete(`${ch}-${data1}`);
                    delete activeNotes[data1];
                    if (keyElements[data1]) {
                        keyElements[data1].classList.remove('key-active-white', 'key-active-black');
                    }
                }
                break;
            case 'Note off':
                statusByte = 0x80 + ch;
                data1 = sanitize(event.noteNumber);
                data2 = sanitize((event.velocity || 0) * parseFloat(volumeSlider.value));

                // Hardware Tracking & UI Update
                playingHardwareNotes.delete(`${ch}-${data1}`);
                delete activeNotes[data1];
                if (keyElements[data1]) {
                    keyElements[data1].classList.remove('key-active-white', 'key-active-black');
                }
                break;
            case 'Controller Change':
                statusByte = 0xB0 + ch;
                data1 = sanitize(event.number);
                data2 = sanitize(event.value);
                break;
            case 'Program Change':
                statusByte = 0xC0 + ch;
                data1 = sanitize(event.value);
                break;
            case 'Pitch Bend':
                statusByte = 0xE0 + ch;
                // Bitwise forces it safely into an integer range automatically
                let bend = event.value || 0;
                data1 = bend & 0x7F;       // LSB
                data2 = (bend >> 7) & 0x7F; // MSB
                break;
        }

        // Send raw MIDI command via the OS with Try/Catch insulation
        if (statusByte !== undefined) {
            const message = [statusByte];
            if (data1 !== null) message.push(data1);
            if (data2 !== null) message.push(data2);

            try {
                selectedOutput.send(message);
            } catch (e) {
                console.warn("Dropped invalid MIDI byte sequence to protect playback loop:", message, e);
            }
        }
    });

    // Player event listeners
    midiPlayer.on('end', () => {
        if (!isPanicking) {
            statusText.textContent = "Finished playing.";
            playBtn.textContent = "Play";
            stopAllNotes();
        }
    });

    // Handle File Selection with structural validation
    fileUpload.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(evt) {
            try {
                // This can throw if the MIDI file header is heavily malformed or non-standard
                midiPlayer.loadArrayBuffer(evt.target.result);

                statusText.textContent = `Loaded: ${file.name} - Ready to play!`;
                statusText.classList.remove('text-red-400');
                statusText.classList.add('text-blue-400');
                playBtn.disabled = false;
                stopBtn.disabled = false;
                playBtn.textContent = "Play";

            } catch (err) {
                console.error("MIDI Parse Error:", err);
                statusText.textContent = "Error: Invalid or unsupported MIDI file format.";
                statusText.classList.remove('text-blue-400', 'text-green-400');
                statusText.classList.add('text-red-400');
                playBtn.disabled = true;
                stopBtn.disabled = true;
            }
        };
        reader.readAsArrayBuffer(file);
    });

    // Play / Pause Button Logic
    playBtn.addEventListener('click', () => {
        if (!selectedOutput) {
            alert("Please select a MIDI Output device first.");
            return;
        }

        autoPaused = false; // Reset the auto-pause state on manual interaction

        if (midiPlayer.isPlaying()) {
            midiPlayer.pause();
            stopAllNotes(); // Cut sound to prevent hanging notes while paused
            playBtn.textContent = "Resume";
            statusText.textContent = "Playback paused.";
        } else {
            midiPlayer.play();
            playBtn.textContent = "Pause";
            statusText.textContent = "‚ñ∂ Playing...";
        }
    });

    // Stop Button Logic
    stopBtn.addEventListener('click', () => {
        autoPaused = false; // Reset the auto-pause state on manual stop
        midiPlayer.stop();
        stopAllNotes();
        playBtn.textContent = "Play";
        statusText.textContent = "Playback stopped.";
    });

    // Panic Button Logic
    panicBtn.addEventListener('click', executePanic);

    // Channel change logic: Stop all hanging notes on previous channel when user changes routing
    channelSelect.addEventListener('change', () => {
        stopAllNotes();
    });

    // Handle focus loss: Pause playback and stop all notes to prevent hanging
    window.addEventListener('blur', () => {
        if (midiPlayer.isPlaying()) {
            midiPlayer.pause();
            stopAllNotes();
            autoPaused = true;
            playBtn.textContent = "Resume";
            statusText.textContent = "Playback paused (Focus lost).";
        }
    });

    // Handle focus regain: Resume if we auto-paused
    window.addEventListener('focus', () => {
        if (autoPaused) {
            autoPaused = false;
            midiPlayer.play();
            playBtn.textContent = "Pause";
            statusText.textContent = "‚ñ∂ Playing...";
        }
    });

    // Handle page visibility change (tab switch or minimize)
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            if (midiPlayer.isPlaying()) {
                midiPlayer.pause();
                stopAllNotes();
                autoPaused = true;
                playBtn.textContent = "Resume";
                statusText.textContent = "Playback paused (Tab hidden).";
            }
        } else {
            if (autoPaused) {
                autoPaused = false;
                midiPlayer.play();
                playBtn.textContent = "Pause";
                statusText.textContent = "‚ñ∂ Playing...";
            }
        }
    });

</script>
</body>
</html>