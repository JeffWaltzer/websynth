
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Delay</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Color Palette */
        :root {
            --primary-color: #7aa2f7;
            --background-dark: #1a1b26;
            --background-medium: #24283b;
            --background-light: #292e42;
            --text-primary: #c0caf5;
            --text-secondary: #a9b1d6;
            --border-color: #414868;
            --midi-in-active-color: #9ece6a; /* Green for MIDI In activity */
            --midi-in-inactive-color: #565f89;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-dark);
            color: var(--text-primary);
        }
        .container {
            max-width: 800px;
            margin: 1.5rem auto;
            padding: 1.5rem;
            background-color: var(--background-medium);
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            min-height: calc(100vh - 3rem);
        }
        .main-content {
            flex-grow: 1;
        }
        .control-group label {
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
            display: block;
        }
        input[type="range"] {
            width: 100%; height: 8px; background: var(--border-color);
            outline: none; opacity: 0.7; transition: opacity .2s; border-radius: 4px;
        }
        input[type="range"]:hover { opacity: 1; }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            background: var(--primary-color); cursor: pointer; border-radius: 50%;
            border: 2px solid var(--background-dark);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px; background: var(--primary-color);
            cursor: pointer; border-radius: 50%; border: 2px solid var(--background-dark);
        }
        select, button {
            background-color: var(--border-color); color: var(--text-primary);
            border: 1px solid var(--primary-color); border-radius: 0.375rem;
            padding: 0.5rem; transition: background-color 0.2s;
        }
        select { width: 100%; padding-right: 2.5rem }
        button { width: auto; padding: 0.5rem 1rem;}
        footer button { padding: 0.25rem 0.75rem; font-size: 0.75rem; }
        select:hover, button:hover { background-color: #565f89; }
        button:disabled, input:disabled, select:disabled {
            background-color: #3b4261; color: #787c99;
            cursor: not-allowed; border-color: #565f89;
        }

        .main-status-box {
            background-color: #1f2335; border: 1px solid var(--border-color);
            padding: 0.75rem; border-radius: 0.375rem; min-height: 40px;
            font-size: 0.875rem; color: var(--text-secondary);
            transition: border-color 0.1s ease-in-out;
            margin-top: 1rem; /* Added margin-top for space above */
        }
        .live-status-bar {
            background-color: #1f2335; border: 1px solid var(--border-color);
            padding: 0.35rem 0.75rem; border-radius: 0.375rem; min-height: 28px;
            font-size: 0.7rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            margin-top: 1rem;
        }
        .live-status-bar > div {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
        }
        .live-status-bar > div:not(:last-child) {
            margin-right: 0.75rem;
        }
        .live-status-bar > div:nth-child(1),
        .live-status-bar > div:nth-child(2) {
            flex-grow: 1;
            flex-basis: 0;
            min-width: 120px;
            overflow: hidden;
        }

        .status-dot {
            display: inline-block; width: 0.6rem; height: 0.6rem;
            border-radius: 50%; background-color: var(--midi-in-inactive-color);
            margin-right: 0.3rem; transition: background-color 0.1s;
        }
        .status-dot.active { background-color: var(--midi-in-active-color); }
        .live-status-bar .highlight {
            color: var(--primary-color);
            font-weight: 500;
            display: inline-block;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            vertical-align: bottom;
            max-width: 150px;
        }

        header h1 { font-size: 1.75rem; color: var(--primary-color); }
        header p { font-size: 0.875rem; }
        .settings-box {
            background-color: var(--background-light); padding: 0.75rem;
            border-radius: 0.375rem; border: 1px solid var(--border-color);
            display: flex; flex-direction: column;
        }
        .settings-box h2 { margin-bottom: 0.75rem; color: var(--text-secondary); }
        input[type="range"] + datalist {
            display: flex; justify-content: space-between; width: 100%;
            color: var(--text-secondary); font-size: 0.75rem; margin-top: -0.25rem;
        }
        footer { margin-top: auto; padding-top: 1rem; }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">
<div class="container">
    <div class="main-content">
        <header class="text-center mb-4">
            <h1 class="text-3xl font-bold">MIDI Delay</h1>
            <p class="text-sm text-a9b1d6">Incoming MIDI is delayed before being sent to the output.</p>
        </header>

        <div>
            <div class="flex flex-col sm:flex-row sm:space-x-4 space-y-4 sm:space-y-0 mb-4">
                <div class="settings-box sm:w-1/3 space-y-3">
                    <h2 class="text-md font-semibold text-center">Input Settings</h2>
                    <div class="control-group">
                        <label for="midiInputSelect" class="font-medium">Device:</label>
                        <select id="midiInputSelect" class="p-2 text-sm" disabled> </select>
                    </div>
                    <div class="control-group">
                        <label for="midiChannelSelect" class="font-medium">Channel:</label>
                        <select id="midiChannelSelect" class="p-2 text-sm" disabled> </select>
                    </div>
                </div>

                <div class="settings-box sm:w-1/3 space-y-3">
                    <h2 class="text-md font-semibold text-center">Output Settings</h2>
                    <div class="control-group">
                        <label for="midiOutputSelect" class="font-medium">Device:</label>
                        <select id="midiOutputSelect" class="p-2 text-sm" disabled> </select>
                    </div>
                    <div class="control-group">
                        <label for="midiOutputChannelSelect" class="font-medium">Channel:</label>
                        <select id="midiOutputChannelSelect" class="p-2 text-sm" disabled> </select>
                    </div>
                </div>

                <div class="settings-box sm:w-1/3 space-y-3">
                    <h2 class="text-md font-semibold text-center">Delay Effects</h2>
                    <div class="control-group">
                        <label for="delaySlider" class="block mb-1 font-medium">Delay Time: <span id="delayValue">0.25</span>s</label>
                        <input type="range" id="delaySlider" min="0" max="4" step="0.01" value="0.25" class="w-full" disabled>
                    </div>
                    <div class="control-group">
                        <label for="repeatsSlider" class="block mb-1 font-medium">Repeats: <span id="repeatsValue">7</span></label>
                        <input type="range" id="repeatsSlider" min="0" max="20" step="1" value="7" class="w-full" disabled>
                    </div>
                    <div class="control-group">
                        <label for="pitchShiftSlider" class="block mb-1 font-medium">Pitch Shift / rep: <span id="pitchShiftValue">1</span> st</label>
                        <input type="range" id="pitchShiftSlider" min="-12" max="12" step="1" value="1" class="w-full" list="pitchShiftTicks" disabled>
                        <datalist id="pitchShiftTicks"> </datalist>
                    </div>
                    <div class="control-group">
                        <label for="velocityScaleSlider" class="block mb-1 font-medium">Velocity Change / rep: <span id="velocityScaleValue">0</span></label>
                        <input type="range" id="velocityScaleSlider" min="-20" max="20" step="1" value="0" class="w-full" disabled>
                    </div>
                </div>
            </div>
        </div>
        <div class="main-status-box mb-4" id="mainStatusMessages"> Attempting to initialize MIDI...</div>
    </div>

    <footer class="text-center text-xs text-gray-500">
        <p>Web MIDI API based delay.</p>
        <button id="reInitMidiButton" class="mt-2">Re-initialize MIDI</button>
        <button id="resetEffectsButton" class="mt-2 ml-2">Reset Effects</button>
    </footer>

    <div class="live-status-bar">
        <div><span id="midiInActivity" class="status-dot"></span>In: <span id="currentInputDevice" class="highlight">-</span> Ch:<span id="currentInputChannel" class="highlight">-</span></div>
        <div>Out: <span id="currentOutputDevice" class="highlight">-</span> Ch:<span id="currentOutputChannel" class="highlight">-</span></div>
        <div class="ml-auto"> <span id="lastNotePlayedDisplay" class="highlight">-</span>
            <span id="timeToNextEchoDisplay" class="ml-2">Next: --</span>
        </div>
    </div>

</div>

<script>
    const reInitMidiButton = document.getElementById('reInitMidiButton');
    const delaySlider = document.getElementById('delaySlider');
    const delayValueDisplay = document.getElementById('delayValue');
    const repeatsSlider = document.getElementById('repeatsSlider');
    const repeatsValueDisplay = document.getElementById('repeatsValue');
    const pitchShiftSlider = document.getElementById('pitchShiftSlider');
    const pitchShiftValueDisplay = document.getElementById('pitchShiftValue');
    const pitchShiftTicksDatalist = document.getElementById('pitchShiftTicks');
    const velocityScaleSlider = document.getElementById('velocityScaleSlider');
    const velocityScaleValueDisplay = document.getElementById('velocityScaleValue');
    const resetEffectsButton = document.getElementById('resetEffectsButton');

    const midiInputSelect = document.getElementById('midiInputSelect');
    const midiChannelSelect = document.getElementById('midiChannelSelect');
    const midiOutputSelect = document.getElementById('midiOutputSelect');
    const midiOutputChannelSelect = document.getElementById('midiOutputChannelSelect');
    const mainStatusMessages = document.getElementById('mainStatusMessages');

    const midiInActivityEl = document.getElementById('midiInActivity');
    const currentInputDeviceEl = document.getElementById('currentInputDevice');
    const currentInputChannelEl = document.getElementById('currentInputChannel');
    const currentOutputDeviceEl = document.getElementById('currentOutputDevice');
    const currentOutputChannelEl = document.getElementById('currentOutputChannel');
    const lastNotePlayedDisplay = document.getElementById('lastNotePlayedDisplay');
    const timeToNextEchoDisplay = document.getElementById('timeToNextEchoDisplay');

    const LOCAL_STORAGE_KEY = 'midiDelaySettings';
    const initialDefaults = {
        delayTimeSec: 0.25, numberOfRepeats: 7, pitchShiftPerRepeat: 1, velocityChangePerRepeat: 0,
        selectedInputChannel: 0, selectedOutputChannel: 0, selectedMidiInputId: null, selectedMidiOutputId: null,
    };

    let delayTimeSec = initialDefaults.delayTimeSec;
    let numberOfRepeats = initialDefaults.numberOfRepeats;
    let pitchShiftPerRepeat = initialDefaults.pitchShiftPerRepeat;
    let velocityChangePerRepeat = initialDefaults.velocityChangePerRepeat;
    let selectedInputChannel = initialDefaults.selectedInputChannel;
    let selectedOutputChannel = initialDefaults.selectedOutputChannel;
    let selectedMidiInputId = initialDefaults.selectedMidiInputId;
    let selectedMidiOutputId = initialDefaults.selectedMidiOutputId;
    let midiAccess = null; let midiInitialized = false;
    let nextEchoFireTime = 0; let countdownInterval = null;

    const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    function loadSettingsFromLocalStorage() {
        const savedSettings = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                delayTimeSec = settings.delayTimeSec !== undefined ? parseFloat(settings.delayTimeSec) : initialDefaults.delayTimeSec;
                numberOfRepeats = settings.numberOfRepeats !== undefined ? parseInt(settings.numberOfRepeats) : initialDefaults.numberOfRepeats;
                pitchShiftPerRepeat = settings.pitchShiftPerRepeat !== undefined ? parseInt(settings.pitchShiftPerRepeat) : initialDefaults.pitchShiftPerRepeat;
                velocityChangePerRepeat = settings.velocityChangePerRepeat !== undefined ? parseInt(settings.velocityChangePerRepeat) : initialDefaults.velocityChangePerRepeat;
                selectedInputChannel = settings.selectedInputChannel !== undefined ? parseInt(settings.selectedInputChannel) : initialDefaults.selectedInputChannel;
                selectedOutputChannel = settings.selectedOutputChannel !== undefined ? parseInt(settings.selectedOutputChannel) : initialDefaults.selectedOutputChannel;
                selectedMidiInputId = settings.selectedMidiInputId || initialDefaults.selectedMidiInputId;
                selectedMidiOutputId = settings.selectedMidiOutputId || initialDefaults.selectedMidiOutputId;
            } catch (e) {
                delayTimeSec = initialDefaults.delayTimeSec; numberOfRepeats = initialDefaults.numberOfRepeats;
                pitchShiftPerRepeat = initialDefaults.pitchShiftPerRepeat; velocityChangePerRepeat = initialDefaults.velocityChangePerRepeat;
                selectedInputChannel = initialDefaults.selectedInputChannel; selectedOutputChannel = initialDefaults.selectedOutputChannel;
                selectedMidiInputId = initialDefaults.selectedMidiInputId; selectedMidiOutputId = initialDefaults.selectedMidiOutputId;
            }
        }
    }

    function saveSettingsToLocalStorage() {
        const settingsToSave = {
            delayTimeSec, numberOfRepeats, pitchShiftPerRepeat, velocityChangePerRepeat,
            selectedInputChannel, selectedOutputChannel, selectedMidiInputId, selectedMidiOutputId
        };
        try {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(settingsToSave));
        } catch (e) {}
    }

    function midiNoteToName(noteNumber) {
        if (noteNumber < 0 || noteNumber > 127) return "";
        const octave = Math.floor(noteNumber / 12) - 1;
        const noteIndex = noteNumber % 12;
        return NOTE_NAMES[noteIndex] + octave;
    }

    function updateDelayTimeDisplay() { delayValueDisplay.textContent = `${delayTimeSec.toFixed(2)}s`; }

    function startCountdownTimer() {
        if (countdownInterval) clearInterval(countdownInterval);
        if (nextEchoFireTime > 0) {
            countdownInterval = setInterval(() => {
                const remainingTime = nextEchoFireTime - Date.now();
                if (remainingTime <= 0) {
                    timeToNextEchoDisplay.textContent = "Next: --"; clearInterval(countdownInterval); nextEchoFireTime = 0;
                } else { timeToNextEchoDisplay.textContent = `Next: ${(remainingTime / 1000).toFixed(2)}s`; }
            }, 50);
        } else { timeToNextEchoDisplay.textContent = "Next: --"; }
    }

    function flashMidiInActivity() {
        midiInActivityEl.classList.add('active');
        setTimeout(() => midiInActivityEl.classList.remove('active'), 100);
    }

    function updateLiveStatusBar() {
        const inputDevice = selectedMidiInputId && midiAccess ? midiAccess.inputs.get(selectedMidiInputId) : null;
        const outputDevice = selectedMidiOutputId && midiAccess ? midiAccess.outputs.get(selectedMidiOutputId) : null;

        currentInputDeviceEl.textContent = inputDevice ? (inputDevice.name.length > 25 ? inputDevice.name.substring(0,22) + '...' : inputDevice.name) : '-';
        currentInputChannelEl.textContent = midiInitialized ? (selectedInputChannel + 1).toString() : '-';
        currentOutputDeviceEl.textContent = outputDevice ? (outputDevice.name.length > 25 ? outputDevice.name.substring(0,22) + '...' : outputDevice.name) : '-';
        currentOutputChannelEl.textContent = midiInitialized ? (selectedOutputChannel + 1).toString() : '-';
    }

    async function initializeMidiSystem() {
        midiInitialized = false;
        if (midiAccess) {
            try {
                if (midiAccess.inputs) midiAccess.inputs.forEach(input => input.onmidimessage = null);
                if (midiAccess.onstatechange) midiAccess.onstatechange = null;
            } catch (e) {}
        }
        midiAccess = null;
        mainStatusMessages.textContent = 'Attempting to initialize MIDI...';
        lastNotePlayedDisplay.textContent = '-';
        timeToNextEchoDisplay.textContent = 'Next Echo: --';
        updateLiveStatusBar();

        if (navigator.requestMIDIAccess) {
            try {
                midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                midiInitialized = true;
                mainStatusMessages.textContent = 'MIDI system initialized. Scanning devices...';
                onMIDISuccess(); enableControls();
            } catch (error) { onMIDIFailure(error); }
        } else {
            mainStatusMessages.textContent = 'Web MIDI API not supported in this browser.';
            onMIDIFailure({message: "Web MIDI API not supported."});
        }
    }

    function onMIDISuccess() {
        populateMidiDeviceSelectors();
        if (!midiAccess) { mainStatusMessages.textContent = "Error: MIDI Access became unavailable."; return; }

        if (midiAccess.inputs.size === 0 && midiAccess.outputs.size === 0) mainStatusMessages.textContent = 'No MIDI input or output devices found.';
        else if (midiAccess.inputs.size === 0) mainStatusMessages.textContent = 'No MIDI input devices found.';
        else if (midiAccess.outputs.size === 0) mainStatusMessages.textContent = 'No MIDI output devices found.';
        else mainStatusMessages.textContent = 'MIDI devices found. Select input, channel, and output.';

        midiAccess.onstatechange = (event) => {
            mainStatusMessages.textContent = `MIDI device ${event.port.name} (${event.port.type}) ${event.port.state}. Re-scanning...`;
            lastNotePlayedDisplay.textContent = '-'; timeToNextEchoDisplay.textContent = 'Next Echo: --';
            setTimeout(() => {
                populateMidiDeviceSelectors(); updateInputListeners();
                if (event.port.type === "output" && event.port.state === "disconnected" && event.port.id === selectedMidiOutputId) mainStatusMessages.textContent += " Output disconnected.";
                if (event.port.type === "input" && event.port.state === "disconnected" && event.port.id === selectedMidiInputId) mainStatusMessages.textContent += " Input disconnected.";
                updateStatusMessage(); updateLiveStatusBar();
            }, 100);
        };
        updateInputListeners(); updateStatusMessage(); updateLiveStatusBar();
    }

    function onMIDIFailure(error) {
        mainStatusMessages.textContent = `Failed to access MIDI: ${error.message || 'Unknown'}. Re-init if needed.`;
        lastNotePlayedDisplay.textContent = 'MIDI Error'; timeToNextEchoDisplay.textContent = 'Next Echo: --';
        midiInitialized = false; updateLiveStatusBar();
        [delaySlider, repeatsSlider, pitchShiftSlider, velocityScaleSlider, midiInputSelect, midiChannelSelect, midiOutputSelect, midiOutputChannelSelect, resetEffectsButton, reInitMidiButton].forEach(el => el.disabled = true);
    }

    function populateMidiDeviceSelectors() {
        if (!midiAccess) return;
        const populate = (selectEl, devices, currentId) => {
            selectEl.innerHTML = '';
            if (devices.size > 0) {
                devices.forEach(dev => { const opt = document.createElement('option'); opt.value = dev.id; opt.textContent = dev.name || `Unknown ${dev.type} ${dev.id.slice(0,5)}`; selectEl.appendChild(opt); });
                const newId = currentId && devices.get(currentId) ? currentId : (selectEl.options.length > 0 ? selectEl.options[0].value : null);
                if (newId) selectEl.value = newId; return newId;
            } else { const opt = document.createElement('option'); opt.value = ""; opt.textContent = `No ${selectEl === midiInputSelect ? 'input' : 'output'} devices`; selectEl.appendChild(opt); return null; }
        };
        selectedMidiInputId = populate(midiInputSelect, midiAccess.inputs, selectedMidiInputId);
        selectedMidiOutputId = populate(midiOutputSelect, midiAccess.outputs, selectedMidiOutputId);
        updateStatusMessage(); updateLiveStatusBar(); saveSettingsToLocalStorage();
    }

    function updateInputListeners() {
        if (!midiAccess) return;
        midiAccess.inputs.forEach(input => input.onmidimessage = null);
        const currentInput = selectedMidiInputId ? midiAccess.inputs.get(selectedMidiInputId) : null;
        if (currentInput) currentInput.onmidimessage = handleMIDIMessage;
        updateStatusMessage(); updateLiveStatusBar();
    }

    function handleMIDIMessage(event) {
        if (!midiInitialized || !selectedMidiOutputId) return;
        const outputDevice = midiAccess.outputs.get(selectedMidiOutputId);
        if (!outputDevice) {
            mainStatusMessages.textContent = "Error: Output device unavailable."; lastNotePlayedDisplay.textContent = 'Output Error';
            selectedMidiOutputId = null; midiOutputSelect.value = ""; populateMidiDeviceSelectors(); return;
        }

        const originalStatusByte = event.data[0];
        const originalChannel = originalStatusByte & 0x0F;
        const command = originalStatusByte >> 4;
        const originalVelocity = (command === 0x9 || command === 0x8) && event.data.length > 2 ? event.data[2] : 64;

        if (originalChannel === selectedInputChannel) {
            flashMidiInActivity();
            const effectiveDelayTime = delayTimeSec; nextEchoFireTime = 0;

            for (let r = 0; r < numberOfRepeats; r++) {
                const currentDelay = effectiveDelayTime * (r + 1);
                let messageDataForThisRepeat = [...event.data];

                if (command === 0x9 || command === 0x8) {
                    if (messageDataForThisRepeat.length > 1) {
                        let originalNote = messageDataForThisRepeat[1];
                        let cumulativePitchShift = pitchShiftPerRepeat * (r + 1);
                        let shiftedNote = originalNote + cumulativePitchShift;
                        shiftedNote = Math.max(0, Math.min(127, shiftedNote)); messageDataForThisRepeat[1] = shiftedNote;
                        if (messageDataForThisRepeat.length > 2) {
                            let currentVelocity = originalVelocity + (velocityChangePerRepeat * (r + 1));
                            currentVelocity = Math.max(1, Math.min(127, currentVelocity)); messageDataForThisRepeat[2] = currentVelocity;
                        }
                    }
                }
                const newStatusByteForRepeat = (command << 4) | selectedOutputChannel;
                const finalMessageToSend = [newStatusByteForRepeat, ...messageDataForThisRepeat.slice(1)];

                if (r === 0) { nextEchoFireTime = Date.now() + (currentDelay * 1000); startCountdownTimer(); }

                setTimeout(() => {
                    const currentOutputDevice = midiAccess ? midiAccess.outputs.get(selectedMidiOutputId) : null;
                    if (currentOutputDevice) {
                        try {
                            currentOutputDevice.send(finalMessageToSend); showMidiActivityIndicator(true);
                            if ((finalMessageToSend[0] >> 4) === 0x9 && finalMessageToSend.length > 2 && finalMessageToSend[2] > 0) {
                                lastNotePlayedDisplay.textContent = `Sent: ${midiNoteToName(finalMessageToSend[1])} (Vel: ${finalMessageToSend[2]})`;
                            }
                            if (Date.now() >= nextEchoFireTime - 50) {
                                if (r + 1 < numberOfRepeats) { nextEchoFireTime = Date.now() + (effectiveDelayTime * 1000); startCountdownTimer(); }
                                else { nextEchoFireTime = 0; startCountdownTimer(); }
                            }
                        } catch (error) { }
                    }
                }, currentDelay * 1000);
            }
            if (numberOfRepeats === 0) { nextEchoFireTime = 0; startCountdownTimer(); }
        }
    }

    function populateChannelSelect(selectElement, currentChannelVal) {
        selectElement.innerHTML = '';
        for (let i = 1; i <= 16; i++) { const option = document.createElement('option'); option.value = i - 1; option.textContent = `Ch ${i}`; selectElement.appendChild(option); }
        let channelValue = parseInt(currentChannelVal); if (isNaN(channelValue) || channelValue < 0 || channelValue > 15) channelValue = 0;
        selectElement.value = channelValue; return channelValue;
    }

    function populatePitchShiftTicks() {
        pitchShiftTicksDatalist.innerHTML = '';
        const ticks = [-12, -9, -7, -5, -4, -3, 0, 3, 4, 5, 7, 9, 12];
        for (let i = -12; i <= 12; i++) { const option = document.createElement('option'); option.value = i; if (ticks.includes(i)) option.label = i.toString(); pitchShiftTicksDatalist.appendChild(option); }
    }

    function resetEffectSettings() {
        delayTimeSec = initialDefaults.delayTimeSec; numberOfRepeats = initialDefaults.numberOfRepeats;
        pitchShiftPerRepeat = initialDefaults.pitchShiftPerRepeat; velocityChangePerRepeat = initialDefaults.velocityChangePerRepeat;
        applyUISettings(); updateDelayTimeDisplay(); updateStatusMessage(); updateLiveStatusBar();
        nextEchoFireTime = 0; startCountdownTimer(); saveSettingsToLocalStorage();
    }

    function enableControls() {
        [delaySlider, repeatsSlider, pitchShiftSlider, velocityScaleSlider, midiInputSelect, midiChannelSelect, midiOutputSelect, midiOutputChannelSelect, resetEffectsButton, reInitMidiButton].forEach(el => el.disabled = !midiInitialized);
        delaySlider.disabled = !midiInitialized;
    }

    function updateStatusMessage() {
        if (!midiInitialized || !midiAccess) return;
        const inputObj = selectedMidiInputId ? midiAccess.inputs.get(selectedMidiInputId) : null;
        const outputObj = selectedMidiOutputId ? midiAccess.outputs.get(selectedMidiOutputId) : null;
        const inputName = inputObj ? (inputObj.name.length > 10 ? inputObj.name.substring(0,8) + '..' : inputObj.name) : 'No Input';
        const outputName = outputObj ? (outputObj.name.length > 10 ? outputObj.name.substring(0,8) + '..' : outputObj.name) : 'No Output';
        mainStatusMessages.textContent = `Input: ${inputName} (Ch ${selectedInputChannel + 1}) | Output: ${outputName} (Ch ${selectedOutputChannel + 1}) | Delay: ${delayTimeSec.toFixed(2)}s | Rep: ${numberOfRepeats} | Pitch: ${pitchShiftPerRepeat}st | Vel: ${velocityChangePerRepeat}`;
        updateLiveStatusBar();
    }

    reInitMidiButton.addEventListener('click', initializeMidiSystem);
    resetEffectsButton.addEventListener('click', resetEffectSettings);

    delaySlider.addEventListener('input', (event) => { delayTimeSec = parseFloat(event.target.value); updateDelayTimeDisplay(); updateStatusMessage(); saveSettingsToLocalStorage(); });
    repeatsSlider.addEventListener('input', (event) => { numberOfRepeats = parseInt(event.target.value); repeatsValueDisplay.textContent = numberOfRepeats; updateStatusMessage(); saveSettingsToLocalStorage(); });
    pitchShiftSlider.addEventListener('input', (event) => { pitchShiftPerRepeat = parseInt(event.target.value); pitchShiftValueDisplay.textContent = pitchShiftPerRepeat; updateStatusMessage(); saveSettingsToLocalStorage(); });
    velocityScaleSlider.addEventListener('input', (event) => { velocityChangePerRepeat = parseInt(event.target.value); velocityScaleValueDisplay.textContent = velocityChangePerRepeat; updateStatusMessage(); saveSettingsToLocalStorage(); });

    midiInputSelect.addEventListener('change', (event) => { selectedMidiInputId = event.target.value; updateInputListeners(); saveSettingsToLocalStorage(); });
    midiChannelSelect.addEventListener('change', (event) => { selectedInputChannel = parseInt(event.target.value); if(midiInitialized) { updateStatusMessage(); updateLiveStatusBar();} saveSettingsToLocalStorage(); });
    midiOutputSelect.addEventListener('change', (event) => { selectedMidiOutputId = event.target.value; if(midiInitialized) { updateStatusMessage(); updateLiveStatusBar();} saveSettingsToLocalStorage(); });
    midiOutputChannelSelect.addEventListener('change', (event) => { selectedOutputChannel = parseInt(event.target.value); if(midiInitialized) { updateStatusMessage(); updateLiveStatusBar();} saveSettingsToLocalStorage(); });

    function applyUISettings() {
        delaySlider.value = delayTimeSec; repeatsSlider.value = numberOfRepeats;
        pitchShiftSlider.value = pitchShiftPerRepeat; velocityScaleSlider.value = velocityChangePerRepeat;
        delayValueDisplay.textContent = parseFloat(delaySlider.value).toFixed(2);
        repeatsValueDisplay.textContent = parseInt(repeatsSlider.value);
        pitchShiftValueDisplay.textContent = parseInt(pitchShiftSlider.value);
        velocityScaleValueDisplay.textContent = parseInt(velocityScaleSlider.value);
        if (midiInputSelect.options.length > 0 && selectedMidiInputId) midiInputSelect.value = selectedMidiInputId;
        if (midiOutputSelect.options.length > 0 && selectedMidiOutputId) midiOutputSelect.value = selectedMidiOutputId;
        midiChannelSelect.value = selectedInputChannel;
        midiOutputChannelSelect.value = selectedOutputChannel;
        updateDelayTimeDisplay(); updateLiveStatusBar();
    }

    document.addEventListener('DOMContentLoaded', () => {
        loadSettingsFromLocalStorage();
        selectedInputChannel = populateChannelSelect(midiChannelSelect, selectedInputChannel);
        selectedOutputChannel = populateChannelSelect(midiOutputChannelSelect, selectedOutputChannel);
        populatePitchShiftTicks();
        applyUISettings();
        initializeMidiSystem();
        updateStatusMessage();
    });

    let originalBorderColor = '#414868';
    const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#7aa2f7';

    function showMidiActivityIndicator(isEcho) {
        if (mainStatusMessages.style.borderColor === '' || mainStatusMessages.style.borderColor === primaryColor) {
            originalBorderColor = getComputedStyle(mainStatusMessages).borderColor || '#414868';
        }
        const blinkColor = primaryColor;
        mainStatusMessages.style.borderColor = blinkColor;
        setTimeout(() => { mainStatusMessages.style.borderColor = originalBorderColor; }, 150);
    }
</script>
</body>
</html>
