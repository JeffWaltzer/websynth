<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Delay - 1930s Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Josefin+Sans:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* 1930s Art Deco Inspired Color Palette & Styles */
        :root {
            --primary-color: #b8860b; /* DarkGoldenRod - a brass/gold */
            --primary-accent: #8B0000; /* DarkRed - for highlights */
            --background-console: #3D2B1F; /* Dark Wood Brown - for the main body */
            --background-panel: #F5F5DC; /* Beige - for control panels */
            --background-panel-inset: #E8E0C4; /* Slightly darker beige for inset effect */
            --text-on-panel: #4A3B31; /* Dark Brown/Black - for text on light panels */
            --text-on-console: #E0D6CC; /* Light Cream - for text on dark console */
            --border-panel: #8B4513; /* SaddleBrown - for panel borders */
            --control-accent: #DAA520; /* Goldenrod - for interactive elements */
            --control-text: #2F1E12; /* Darker text for controls */
            --midi-in-active-color: #32CD32; /* LimeGreen - a vibrant indicator */
            --midi-in-inactive-color: #556B2F; /* DarkOliveGreen - muted indicator */
            --shadow-color: rgba(0,0,0,0.3);
        }

        body {
            font-family: 'Josefin Sans', sans-serif;
            background-color: var(--background-console);
            color: var(--text-on-console);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 0.2rem;
        }

        .container {
            max-width: 900px;
            margin: 1rem auto;
            padding: 0.3rem;
            background-color: var(--background-console);
            border: 4px solid #5C3D2E;
            box-shadow: 0 0 10px var(--shadow-color), inset 0 0 15px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            border-radius: 2px;
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .main-controls-area {
            flex-grow: 1;
        }


        header h1 {
            font-family: 'Cinzel', serif;
            font-size: 2.5rem;
            color: var(--primary-color);
            text-shadow: 1px 1px 0px #000, 2px 2px 3px var(--shadow-color);
            margin-bottom: 0.25rem;
        }

        header p {
            font-size: 0.9rem;
            color: var(--text-on-console);
            opacity: 0.8;
        }

        .settings-box {
            background-color: var(--background-panel);
            color: var(--text-on-panel);
            padding-top: 0.4rem;
            padding-right: 0.4rem;
            padding-bottom: 0.8rem;
            padding-left: 0.4rem;
            border: 2px solid var(--border-panel);
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2), 0px 1px 2px rgba(255,255,255,0.3);
            display: flex;
            flex-direction: column;
            border-radius: 2px;
        }

        .settings-box h2 {
            font-family: 'Cinzel', serif;
            margin-bottom: 1rem;
            color: var(--text-on-panel);
            font-weight: 700;
            text-align: center;
            font-size: 1.1rem;
            border-bottom: 1px solid var(--border-panel);
            padding-bottom: 0.1rem;
        }

        .control-group label {
            color: var(--text-on-panel);
            margin-bottom: 0.35rem;
            display: block;
            font-weight: 600;
            font-size: 0.85rem;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--background-panel-inset);
            outline: none;
            opacity: 0.8;
            transition: opacity .2s;
            border-radius: 0px;
            border: 1px solid var(--border-panel);
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }
        input[type="range"]:hover { opacity: 1; }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 22px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 0px;
            border: 1px solid var(--control-text);
            box-shadow: 1px 1px 2px rgba(0,0,0,0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 22px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 0px;
            border: 1px solid var(--control-text);
            box-shadow: 1px 1px 2px rgba(0,0,0,0.4);
        }

        input[type="range"] + datalist {
            display: flex;
            justify-content: space-between;
            width: 100%;
            color: var(--text-on-panel);
            font-size: 0.7rem;
            margin-top: 0.1rem;
        }
        input[type="range"] + datalist option {
            padding: 0;
        }


        select, button {
            background-color: var(--background-panel-inset);
            color: var(--control-text);
            border: 1px solid var(--border-panel);
            border-radius: 2px;
            padding: 0.12rem;
            transition: background-color 0.2s, box-shadow 0.2s;
            font-weight: 600;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.2), inset 1px 1px 1px rgba(255,255,255,0.5);
            text-shadow: 0px 1px 0px rgba(255,255,255,0.3);
        }

        select {
            width: 100%;
            padding-right: 0.5rem;
            padding-top: 0.12rem;
            padding-bottom: 0.12rem;
            padding-left: 0.12rem;
        }


        select:hover, button:hover {
            background-color: #c8bda9;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3), inset 1px 1px 2px rgba(0,0,0,0.1);
        }
        button:active {
            box-shadow: inset 2px 2px 3px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }

        button:disabled, input:disabled, select:disabled {
            background-color: #A09483;
            color: #60544C;
            cursor: not-allowed;
            border-color: #70645C;
            box-shadow: inset 1px 1px 2px rgba(0,0,0,0.1);
            text-shadow: none;
        }

        .main-status-box {
            background-color: var(--background-panel);
            border: 2px solid var(--border-panel);
            padding: 0.15rem;
            border-radius: 2px;
            font-size: 0.85rem;
            color: var(--text-on-panel);
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.15);
            margin-top: 1rem;
            margin-bottom: 0;
        }
        .live-status-bar {
            background-color: var(--background-panel);
            border: 2px solid var(--border-panel);
            padding: 0.1rem 0.15rem;
            border-radius: 2px;
            font-size: 0.75rem;
            color: var(--text-on-panel);
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.15);
            margin-top: 0;
            display: flex;
            align-items: center;
        }


        .live-status-bar > div {
            display: flex;
            align-items: center;
        }
        .live-status-bar > div:not(:last-child) {
            margin-right: 1rem;
        }
        .live-status-bar > div:nth-child(1),
        .live-status-bar > div:nth-child(2) {
            flex-grow: 1;
            flex-basis: 0;
            /* min-width: 250px; Removed to allow full text to determine width */
            overflow: visible; /* Allow overflow if necessary, though flex should handle it */
        }


        .status-dot {
            display: inline-block;
            width: 0.7rem;
            height: 0.7rem;
            border-radius: 1px;
            background-color: var(--midi-in-inactive-color);
            margin-right: 0.4rem;
            transition: background-color 0.1s;
            border: 1px solid rgba(0,0,0,0.3);
        }
        .status-dot.active { background-color: var(--midi-in-active-color); }

        .live-status-bar .highlight {
            color: var(--primary-color);
            font-weight: 600;
            display: inline-block;
            /* white-space: nowrap; Removed */
            /* overflow: hidden; Removed */
            /* text-overflow: ellipsis; Removed */
            vertical-align: bottom;
            max-width: none; /* Changed from 240px */
            background-color: rgba(0,0,0,0.05);
            padding: 0.02rem 0.06rem;
            border-radius: 1px;
        }

        footer {
            margin-top: 0.5rem;
            padding-top: 0.3rem;
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-on-console);
            opacity: 0.7;
            min-height: 20px;
        }


        *, ::before, ::after {
            border-width: 0;
        }

    </style>
</head>
<body> <div class="container">
    <div class="main-content">
        <div class="main-controls-area">
            <header class="text-center mb-6"> <h1 class="text-3xl font-bold">MIDI DELAY</h1> <p class="text-sm">A Device for the Temporal Displacement of Musical Notes</p> </header>
            <div>
                <div class="flex flex-col sm:flex-row sm:space-x-6 space-y-6 sm:space-y-0 mb-6">
                    <div class="settings-box sm:w-1/3 space-y-4">
                        <h2 class="text-md font-semibold text-center">INPUT CONFIGURATION</h2>
                        <div class="control-group">
                            <label for="midiInputSelect" class="font-medium">Source Apparatus:</label>
                            <select id="midiInputSelect" class="text-sm" disabled> </select>
                        </div>
                        <div class="control-group">
                            <label for="midiChannelSelect" class="font-medium">Channel:</label>
                            <select id="midiChannelSelect" class="text-sm" disabled> </select>
                        </div>
                    </div>

                    <div class="settings-box sm:w-1/3 space-y-4">
                        <h2 class="text-md font-semibold text-center">OUTPUT CONFIGURATION</h2>
                        <div class="control-group">
                            <label for="midiOutputSelect" class="font-medium">Destination Unit:</label>
                            <select id="midiOutputSelect" class="text-sm" disabled> </select>
                        </div>
                        <div class="control-group">
                            <label for="midiOutputChannelSelect" class="font-medium">Channel:</label>
                            <select id="midiOutputChannelSelect" class="text-sm" disabled> </select>
                        </div>
                    </div>

                    <div class="settings-box sm:w-1/3 space-y-4">
                        <h2 class="text-md font-semibold text-center">TEMPORAL EFFECTS</h2>
                        <div class="control-group">
                            <label for="delaySlider" class="block mb-1 font-medium">Delay Time: <span id="delayValue">0.25</span>s</label>
                            <input type="range" id="delaySlider" min="0" max="4" step="0.01" value="0.25" class="w-full" disabled>
                        </div>
                        <div class="control-group">
                            <label for="repeatsSlider" class="block mb-1 font-medium">Repeats: <span id="repeatsValue">7</span></label>
                            <input type="range" id="repeatsSlider" min="0" max="20" step="1" value="7" class="w-full" disabled>
                        </div>
                        <div class="control-group">
                            <label for="pitchShiftSlider" class="block mb-1 font-medium">Pitch Shift / Repeat: <span id="pitchShiftValue">1</span> st</label>
                            <input type="range" id="pitchShiftSlider" min="-12" max="12" step="1" value="1" class="w-full" list="pitchShiftTicks" disabled>
                            <datalist id="pitchShiftTicks"> </datalist>
                        </div>
                        <div class="control-group">
                            <label for="velocityScaleSlider" class="block mb-1 font-medium">Velocity Change / Repeat: <span id="velocityScaleValue">0</span></label>
                            <input type="range" id="velocityScaleSlider" min="-20" max="20" step="1" value="0" class="w-full" disabled>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="main-status-box" id="mainStatusMessages">Initializing Etheric Modulator...</div>
        <div class="live-status-bar">
            <div><span id="midiInActivity" class="status-dot"></span>In: <span id="currentInputDevice" class="highlight">-</span> Ch:<span id="currentInputChannel" class="highlight">-</span></div>
            <div>Out: <span id="currentOutputDevice" class="highlight">-</span> Ch:<span id="currentOutputChannel" class="highlight">-</span></div>
            <div class="ml-auto"> <span id="lastNotePlayedDisplay" class="highlight">-</span></div>
        </div>
    </div>
    <footer class="text-xs"></footer>
</div>

<script>
    const delaySlider = document.getElementById('delaySlider');
    const delayValueDisplay = document.getElementById('delayValue');
    const repeatsSlider = document.getElementById('repeatsSlider');
    const repeatsValueDisplay = document.getElementById('repeatsValue');
    const pitchShiftSlider = document.getElementById('pitchShiftSlider');
    const pitchShiftValueDisplay = document.getElementById('pitchShiftValue');
    const pitchShiftTicksDatalist = document.getElementById('pitchShiftTicks');
    const velocityScaleSlider = document.getElementById('velocityScaleSlider');
    const velocityScaleValueDisplay = document.getElementById('velocityScaleValue');

    const midiInputSelect = document.getElementById('midiInputSelect');
    const midiChannelSelect = document.getElementById('midiChannelSelect');
    const midiOutputSelect = document.getElementById('midiOutputSelect');
    const midiOutputChannelSelect = document.getElementById('midiOutputChannelSelect');
    const mainStatusMessages = document.getElementById('mainStatusMessages');

    const midiInActivityEl = document.getElementById('midiInActivity');
    const currentInputDeviceEl = document.getElementById('currentInputDevice');
    const currentInputChannelEl = document.getElementById('currentInputChannel');
    const currentOutputDeviceEl = document.getElementById('currentOutputDevice');
    const currentOutputChannelEl = document.getElementById('currentOutputChannel');
    const lastNotePlayedDisplay = document.getElementById('lastNotePlayedDisplay');

    const LOCAL_STORAGE_KEY = 'midiDelaySettings_1930s';
    const initialDefaults = {
        delayTimeSec: 0.25, numberOfRepeats: 7, pitchShiftPerRepeat: 1, velocityChangePerRepeat: 0,
        selectedInputChannel: 0, selectedOutputChannel: 0, selectedMidiInputId: null, selectedMidiOutputId: null,
    };

    let delayTimeSec = initialDefaults.delayTimeSec;
    let numberOfRepeats = initialDefaults.numberOfRepeats;
    let pitchShiftPerRepeat = initialDefaults.pitchShiftPerRepeat;
    let velocityChangePerRepeat = initialDefaults.velocityChangePerRepeat;
    let selectedInputChannel = initialDefaults.selectedInputChannel;
    let selectedOutputChannel = initialDefaults.selectedOutputChannel;
    let selectedMidiInputId = initialDefaults.selectedMidiInputId;
    let selectedMidiOutputId = initialDefaults.selectedMidiOutputId;
    let midiAccess = null; let midiInitialized = false;

    const NOTE_NAMES = ["C", "C♯", "D", "D♯", "E", "F", "F♯", "G", "G♯", "A", "A♯", "B"];

    function loadSettingsFromLocalStorage() {
        const savedSettings = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                delayTimeSec = settings.delayTimeSec !== undefined ? parseFloat(settings.delayTimeSec) : initialDefaults.delayTimeSec;
                numberOfRepeats = settings.numberOfRepeats !== undefined ? parseInt(settings.numberOfRepeats) : initialDefaults.numberOfRepeats;
                pitchShiftPerRepeat = settings.pitchShiftPerRepeat !== undefined ? parseInt(settings.pitchShiftPerRepeat) : initialDefaults.pitchShiftPerRepeat;
                velocityChangePerRepeat = settings.velocityChangePerRepeat !== undefined ? parseInt(settings.velocityChangePerRepeat) : initialDefaults.velocityChangePerRepeat;
                selectedInputChannel = settings.selectedInputChannel !== undefined ? parseInt(settings.selectedInputChannel) : initialDefaults.selectedInputChannel;
                selectedOutputChannel = settings.selectedOutputChannel !== undefined ? parseInt(settings.selectedOutputChannel) : initialDefaults.selectedOutputChannel;
                selectedMidiInputId = settings.selectedMidiInputId || initialDefaults.selectedMidiInputId;
                selectedMidiOutputId = settings.selectedMidiOutputId || initialDefaults.selectedMidiOutputId;
            } catch (e) {
                console.warn("Failed to parse settings from localStorage, using defaults.", e);
                Object.assign(window, initialDefaults);
            }
        }
    }

    function saveSettingsToLocalStorage() {
        const settingsToSave = {
            delayTimeSec, numberOfRepeats, pitchShiftPerRepeat, velocityChangePerRepeat,
            selectedInputChannel, selectedOutputChannel, selectedMidiInputId, selectedMidiOutputId
        };
        try {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(settingsToSave));
        } catch (e) {
            console.warn("Failed to save settings to localStorage.", e);
        }
    }

    function midiNoteToName(noteNumber) {
        if (noteNumber < 0 || noteNumber > 127) return "";
        const octave = Math.floor(noteNumber / 12) - 1;
        const noteIndex = noteNumber % 12;
        return NOTE_NAMES[noteIndex] + octave;
    }

    function updateDelayTimeDisplay() { delayValueDisplay.textContent = `${delayTimeSec.toFixed(2)}s`; }

    function flashMidiInActivity() {
        midiInActivityEl.classList.add('active');
        setTimeout(() => midiInActivityEl.classList.remove('active'), 100);
    }

    function updateLiveStatusBar() {
        const inputDevice = selectedMidiInputId && midiAccess ? midiAccess.inputs.get(selectedMidiInputId) : null;
        const outputDevice = selectedMidiOutputId && midiAccess ? midiAccess.outputs.get(selectedMidiOutputId) : null;

        currentInputDeviceEl.textContent = inputDevice ? inputDevice.name : '-'; // Show full name
        currentInputChannelEl.textContent = midiInitialized ? (selectedInputChannel + 1).toString() : '-';
        currentOutputDeviceEl.textContent = outputDevice ? outputDevice.name : '-'; // Show full name
        currentOutputChannelEl.textContent = midiInitialized ? (selectedOutputChannel + 1).toString() : '-';
        lastNotePlayedDisplay.textContent = lastNotePlayedDisplay.textContent || '-'; // Preserve if already set
    }

    async function initializeMidiSystem() {
        midiInitialized = false;
        if (midiAccess) {
            try {
                if (midiAccess.inputs) midiAccess.inputs.forEach(input => { if(input) input.onmidimessage = null; });
                if (midiAccess.onstatechange) midiAccess.onstatechange = null;
            } catch (e) { console.warn("Error during MIDI cleanup:", e); }
        }
        midiAccess = null;
        mainStatusMessages.textContent = 'Initializing Etheric Modulator...';
        lastNotePlayedDisplay.textContent = '-';
        disableControls();
        updateLiveStatusBar();


        if (navigator.requestMIDIAccess) {
            try {
                midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                midiInitialized = true;
                mainStatusMessages.textContent = 'Etheric Modulator Online. Scanning Frequencies...';
                onMIDISuccess();
                enableControls();
            } catch (error) {
                onMIDIFailure(error);
            }
        } else {
            mainStatusMessages.textContent = 'Web MIDI Transmission System not detected in this Chrono-Receiver.';
            onMIDIFailure({message: "Web MIDI API not supported."});
        }
    }

    function onMIDISuccess() {
        populateMidiDeviceSelectors();
        if (!midiAccess) { mainStatusMessages.textContent = "Critical Error: Modulator Connection Lost."; return; }

        if (midiAccess.inputs.size === 0 && midiAccess.outputs.size === 0) mainStatusMessages.textContent = 'No Input or Output Apparatuses Detected.';
        else if (midiAccess.inputs.size === 0) mainStatusMessages.textContent = 'No Input Apparatuses Detected.';
        else if (midiAccess.outputs.size === 0) mainStatusMessages.textContent = 'No Output Apparatuses Detected.';
        else mainStatusMessages.textContent = 'Apparatuses Detected. Select input, channel, and output.';

        midiAccess.onstatechange = (event) => {
            mainStatusMessages.textContent = `Apparatus ${event.port.name} (${event.port.type}) status: ${event.port.state}. Re-scanning...`;
            lastNotePlayedDisplay.textContent = '-';
            setTimeout(() => {
                populateMidiDeviceSelectors();
                updateInputListeners();
                if (event.port.type === "output" && event.port.state === "disconnected" && event.port.id === selectedMidiOutputId) {
                    mainStatusMessages.textContent += " Output Disconnected.";
                    selectedMidiOutputId = null;
                }
                if (event.port.type === "input" && event.port.state === "disconnected" && event.port.id === selectedMidiInputId) {
                    mainStatusMessages.textContent += " Input Disconnected.";
                    selectedMidiInputId = null;
                }
                populateMidiDeviceSelectors();
                updateStatusMessage();
                updateLiveStatusBar();
            }, 100);
        };
        updateInputListeners();
        updateStatusMessage();
        updateLiveStatusBar();
    }


    function onMIDIFailure(error) {
        mainStatusMessages.textContent = `Modulator Failure: ${error.message || 'Unknown Anomaly'}.`;
        lastNotePlayedDisplay.textContent = 'Modulator Error';
        midiInitialized = false;
        disableControls();
        updateLiveStatusBar();
    }

    function populateMidiDeviceSelectors() {
        if (!midiAccess) return;

        const currentInputId = selectedMidiInputId;
        const currentOutputId = selectedMidiOutputId;

        const populate = (selectEl, devices, currentId, type) => {
            const previousValue = selectEl.value;
            selectEl.innerHTML = '';
            if (devices.size > 0) {
                devices.forEach(dev => { const opt = document.createElement('option'); opt.value = dev.id; opt.textContent = dev.name || `Unknown ${dev.type} ${dev.id.slice(0,5)}`; selectEl.appendChild(opt); });

                let newIdToSelect = null;
                if (currentId && devices.get(currentId)) {
                    newIdToSelect = currentId;
                } else if (previousValue && devices.get(previousValue)) {
                    newIdToSelect = previousValue;
                } else if (selectEl.options.length > 0) {
                    newIdToSelect = selectEl.options[0].value;
                }

                if (newIdToSelect) {
                    selectEl.value = newIdToSelect;
                } else {
                    selectEl.value = "";
                }
                return selectEl.value;

            } else {
                const opt = document.createElement('option'); opt.value = ""; opt.textContent = `No ${type} apparatuses`; selectEl.appendChild(opt);
                return null;
            }
        };

        selectedMidiInputId = populate(midiInputSelect, midiAccess.inputs, currentInputId, 'input');
        selectedMidiOutputId = populate(midiOutputSelect, midiAccess.outputs, currentOutputId, 'output');

        if (!midiAccess.inputs.get(selectedMidiInputId)) selectedMidiInputId = midiInputSelect.value || null;
        if (!midiAccess.outputs.get(selectedMidiOutputId)) selectedMidiOutputId = midiOutputSelect.value || null;


        updateStatusMessage();
        updateLiveStatusBar();
        saveSettingsToLocalStorage();
    }

    function updateInputListeners() {
        if (!midiAccess || !midiAccess.inputs) return;
        midiAccess.inputs.forEach(input => {
            if (input) input.onmidimessage = null;
        });

        const currentInput = selectedMidiInputId ? midiAccess.inputs.get(selectedMidiInputId) : null;
        if (currentInput) {
            currentInput.onmidimessage = handleMIDIMessage;
        }
        updateStatusMessage();
        updateLiveStatusBar();
    }


    function handleMIDIMessage(event) {
        if (!midiInitialized || !selectedMidiOutputId) return;
        const outputDevice = midiAccess.outputs.get(selectedMidiOutputId);
        if (!outputDevice) {
            mainStatusMessages.textContent = "Critical Error: Output Apparatus Unavailable."; lastNotePlayedDisplay.textContent = 'Output Error';
            selectedMidiOutputId = null;
            populateMidiDeviceSelectors();
            return;
        }

        const originalStatusByte = event.data[0];
        const originalChannel = originalStatusByte & 0x0F;
        const command = originalStatusByte >> 4;
        const originalVelocity = (command === 0x9 || command === 0x8) && event.data.length > 2 ? event.data[2] : 64;

        if (originalChannel === selectedInputChannel) {
            flashMidiInActivity();
            const effectiveDelayTime = delayTimeSec;

            if (numberOfRepeats === 0) {
                const newStatusByteForPassthrough = (command << 4) | selectedOutputChannel;
                const finalMessageToSend = [newStatusByteForPassthrough, ...event.data.slice(1)];
                try {
                    outputDevice.send(finalMessageToSend);
                    showMidiActivityIndicator(false);
                    if ((finalMessageToSend[0] >> 4) === 0x9 && finalMessageToSend.length > 2 && finalMessageToSend[2] > 0) {
                        lastNotePlayedDisplay.textContent = `Sent: ${midiNoteToName(finalMessageToSend[1])} (Vel: ${finalMessageToSend[2]})`;
                    }
                } catch (error) { console.error("Error sending MIDI message (passthrough):", error); }
                return;
            }


            for (let r = 0; r < numberOfRepeats; r++) {
                const currentDelayMs = effectiveDelayTime * (r + 1) * 1000;
                let messageDataForThisRepeat = [...event.data];

                if (command === 0x9 || command === 0x8) {
                    if (messageDataForThisRepeat.length > 1) {
                        let originalNote = messageDataForThisRepeat[1];
                        let cumulativePitchShift = pitchShiftPerRepeat * (r + 1);
                        let shiftedNote = originalNote + cumulativePitchShift;
                        shiftedNote = Math.max(0, Math.min(127, shiftedNote));
                        messageDataForThisRepeat[1] = shiftedNote;

                        if (messageDataForThisRepeat.length > 2) {
                            let currentVelocity = originalVelocity + (velocityChangePerRepeat * (r + 1));
                            currentVelocity = Math.max(1, Math.min(127, currentVelocity));
                            messageDataForThisRepeat[2] = currentVelocity;
                        }
                    }
                }
                const newStatusByteForRepeat = (command << 4) | selectedOutputChannel;
                const finalMessageToSend = [newStatusByteForRepeat, ...messageDataForThisRepeat.slice(1)];

                setTimeout(() => {
                    const currentOutputDevice = midiAccess ? midiAccess.outputs.get(selectedMidiOutputId) : null;
                    if (currentOutputDevice) {
                        try {
                            currentOutputDevice.send(finalMessageToSend);
                            showMidiActivityIndicator(true);
                            if ((finalMessageToSend[0] >> 4) === 0x9 && finalMessageToSend.length > 2 && finalMessageToSend[2] > 0) {
                                lastNotePlayedDisplay.textContent = `Echo: ${midiNoteToName(finalMessageToSend[1])} (Vel: ${finalMessageToSend[2]})`;
                            }
                        } catch (error) {
                            console.error("Error sending MIDI message (echo):", error);
                        }
                    }
                }, currentDelayMs);
            }
        }
    }


    function populateChannelSelect(selectElement, currentChannelVal) {
        selectElement.innerHTML = '';
        for (let i = 1; i <= 16; i++) {
            const option = document.createElement('option');
            option.value = i - 1;
            option.textContent = `Ch ${i}`;
            selectElement.appendChild(option);
        }
        let channelValue = parseInt(currentChannelVal); if (isNaN(channelValue) || channelValue < 0 || channelValue > 15) channelValue = 0;
        selectElement.value = channelValue; return channelValue;
    }

    function populatePitchShiftTicks() {
        pitchShiftTicksDatalist.innerHTML = '';
        const ticks = [-12, -7, -5, 0, 5, 7, 12];
        for (let i = parseInt(pitchShiftSlider.min); i <= parseInt(pitchShiftSlider.max); i++) {
            const option = document.createElement('option');
            option.value = i;
            if (ticks.includes(i)) option.label = i.toString();
            pitchShiftTicksDatalist.appendChild(option);
        }
    }

    function resetEffectSettings() {
        delayTimeSec = initialDefaults.delayTimeSec; numberOfRepeats = initialDefaults.numberOfRepeats;
        pitchShiftPerRepeat = initialDefaults.pitchShiftPerRepeat; velocityChangePerRepeat = initialDefaults.velocityChangePerRepeat;
        applyUISettings(); updateDelayTimeDisplay(); updateStatusMessage(); updateLiveStatusBar();
        saveSettingsToLocalStorage();
        mainStatusMessages.textContent = "Calibrations Reset to Standard Values.";
    }

    function enableControls() {
        [delaySlider, repeatsSlider, pitchShiftSlider, velocityScaleSlider, midiInputSelect, midiChannelSelect, midiOutputSelect, midiOutputChannelSelect].forEach(el => el.disabled = false);
    }
    function disableControls() {
        [delaySlider, repeatsSlider, pitchShiftSlider, velocityScaleSlider, midiInputSelect, midiChannelSelect, midiOutputSelect, midiOutputChannelSelect].forEach(el => el.disabled = true);
    }


    function updateStatusMessage() {
        if (!midiInitialized || !midiAccess) {
            mainStatusMessages.textContent = midiInitialized ? "Modulator Standby..." : "Modulator Offline.";
            return;
        }
        const inputObj = selectedMidiInputId ? midiAccess.inputs.get(selectedMidiInputId) : null;
        const outputObj = selectedMidiOutputId ? midiAccess.outputs.get(selectedMidiOutputId) : null;
        const inputName = inputObj ? (inputObj.name.length > 10 ? inputObj.name.substring(0,8) + '..' : inputObj.name) : 'None';
        const outputName = outputObj ? (outputObj.name.length > 10 ? outputObj.name.substring(0,8) + '..' : outputObj.name) : 'None';
        mainStatusMessages.textContent = `Input: ${inputName} (Ch ${selectedInputChannel + 1})  |  Output: ${outputName} (Ch ${selectedOutputChannel + 1})  |  Delay: ${delayTimeSec.toFixed(2)}s  |  Repeats: ${numberOfRepeats}  |  Pitch Shift: ${pitchShiftPerRepeat}st  |  Velocity Change: ${velocityChangePerRepeat}`;
        updateLiveStatusBar();
    }


    delaySlider.addEventListener('input', (event) => { delayTimeSec = parseFloat(event.target.value); updateDelayTimeDisplay(); updateStatusMessage(); saveSettingsToLocalStorage(); });
    repeatsSlider.addEventListener('input', (event) => { numberOfRepeats = parseInt(event.target.value); repeatsValueDisplay.textContent = numberOfRepeats; updateStatusMessage(); saveSettingsToLocalStorage(); });
    pitchShiftSlider.addEventListener('input', (event) => { pitchShiftPerRepeat = parseInt(event.target.value); pitchShiftValueDisplay.textContent = `${pitchShiftPerRepeat} st`; updateStatusMessage(); saveSettingsToLocalStorage(); });
    velocityScaleSlider.addEventListener('input', (event) => { velocityChangePerRepeat = parseInt(event.target.value); velocityScaleValueDisplay.textContent = velocityChangePerRepeat; updateStatusMessage(); saveSettingsToLocalStorage(); });

    midiInputSelect.addEventListener('change', (event) => { selectedMidiInputId = event.target.value; updateInputListeners(); saveSettingsToLocalStorage(); });
    midiChannelSelect.addEventListener('change', (event) => { selectedInputChannel = parseInt(event.target.value); if(midiInitialized) { updateStatusMessage(); updateLiveStatusBar();} saveSettingsToLocalStorage(); });
    midiOutputSelect.addEventListener('change', (event) => { selectedMidiOutputId = event.target.value; if(midiInitialized) { updateStatusMessage(); updateLiveStatusBar();} saveSettingsToLocalStorage(); });
    midiOutputChannelSelect.addEventListener('change', (event) => { selectedOutputChannel = parseInt(event.target.value); if(midiInitialized) { updateStatusMessage(); updateLiveStatusBar();} saveSettingsToLocalStorage(); });

    function applyUISettings() {
        delaySlider.value = delayTimeSec;
        repeatsSlider.value = numberOfRepeats;
        pitchShiftSlider.value = pitchShiftPerRepeat;
        velocityScaleSlider.value = velocityChangePerRepeat;

        delayValueDisplay.textContent = `${parseFloat(delaySlider.value).toFixed(2)}s`;
        repeatsValueDisplay.textContent = parseInt(repeatsSlider.value);
        pitchShiftValueDisplay.textContent = `${parseInt(pitchShiftSlider.value)} st`;
        velocityScaleValueDisplay.textContent = parseInt(velocityScaleSlider.value);

        if (midiInputSelect.options.length > 0 && selectedMidiInputId) midiInputSelect.value = selectedMidiInputId;
        if (midiOutputSelect.options.length > 0 && selectedMidiOutputId) midiOutputSelect.value = selectedMidiOutputId;
        midiChannelSelect.value = selectedInputChannel;
        midiOutputChannelSelect.value = selectedOutputChannel;

        updateDelayTimeDisplay();
        updateLiveStatusBar();
    }

    document.addEventListener('DOMContentLoaded', () => {
        loadSettingsFromLocalStorage();
        selectedInputChannel = populateChannelSelect(midiChannelSelect, selectedInputChannel);
        selectedOutputChannel = populateChannelSelect(midiOutputChannelSelect, selectedOutputChannel);
        populatePitchShiftTicks();
        applyUISettings();
        initializeMidiSystem();
    });

    let originalBorderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-panel').trim() || '#8B4513';
    const activityBlinkColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-accent').trim() || '#8B0000';

    function showMidiActivityIndicator(isEcho) {
        mainStatusMessages.style.borderColor = activityBlinkColor;
        setTimeout(() => {
            originalBorderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-panel').trim();
            mainStatusMessages.style.borderColor = originalBorderColor;
        }, 150);
    }
</script>
</body>
</html>
