<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Delay - 1930s Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Josefin+Sans:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* 1930s Art Deco Inspired Color Palette & Styles */
        :root {
            --primary-color: #b8860b; /* DarkGoldenRod - a brass/gold */
            --primary-accent: #8B0000; /* DarkRed - for highlights */
            --background-console: #3D2B1F; /* Dark Wood Brown - for the main body */
            --background-panel: #F5F5DC; /* Beige - for control panels */
            --background-panel-inset: #E8E0C4; /* Slightly darker beige for inset effect */
            --text-on-panel: #4A3B31; /* Dark Brown/Black - for text on light panels */
            --text-on-console: #E0D6CC; /* Light Cream - for text on dark console */
            --border-panel: #8B4513; /* SaddleBrown - for panel borders */
            --control-accent: #DAA520; /* Goldenrod - for interactive elements */
            --control-text: #2F1E12; /* Darker text for controls */
            --midi-in-active-color: #32CD32; /* LimeGreen - a vibrant indicator */
            --midi-in-inactive-color: #556B2F; /* DarkOliveGreen - muted indicator */
            --shadow-color: rgba(0,0,0,0.3);
        }

        body {
            font-family: 'Josefin Sans', sans-serif;
            background-color: var(--background-console);
            color: var(--text-on-console);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 0.2rem;
        }

        .container {
            max-width: 900px;
            margin: 1rem auto;
            padding: 0.3rem;
            background-color: var(--background-console);
            border: 4px solid #5C3D2E;
            box-shadow: 0 0 10px var(--shadow-color), inset 0 0 15px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            border-radius: 2px;
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .main-controls-area {
            flex-grow: 1;
        }


        header h1 {
            font-family: 'Cinzel', serif;
            font-size: 2.5rem;
            color: var(--primary-color);
            text-shadow: 1px 1px 0px #000, 2px 2px 3px var(--shadow-color);
            margin-bottom: 0.25rem;
        }

        header p {
            font-size: 0.9rem;
            color: var(--text-on-console);
            opacity: 0.8;
        }

        .settings-box {
            background-color: var(--background-panel);
            color: var(--text-on-panel);
            padding-top: 0.4rem;
            padding-right: 0.4rem;
            padding-bottom: 0.8rem;
            padding-left: 0.4rem;
            border: 2px solid var(--border-panel);
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2), 0px 1px 2px rgba(255,255,255,0.3);
            display: flex;
            flex-direction: column;
            border-radius: 2px;
        }

        .settings-box h2 {
            font-family: 'Cinzel', serif;
            margin-bottom: 1rem;
            color: var(--text-on-panel);
            font-weight: 700;
            text-align: center;
            font-size: 1.1rem;
            border-bottom: 1px solid var(--border-panel);
            padding-bottom: 0.1rem;
        }

        .control-group label {
            color: var(--text-on-panel);
            margin-bottom: 0.35rem;
            display: block;
            font-weight: 600;
            font-size: 0.85rem;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--background-panel-inset);
            outline: none;
            opacity: 0.8;ls

            transition: opacity .2s;
            border-radius: 0px;
            border: 1px solid var(--border-panel);
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
        }
        input[type="range"]:hover { opacity: 1; }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 22px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 0px;
            border: 1px solid var(--control-text);
            box-shadow: 1px 1px 2px rgba(0,0,0,0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 22px;
            background: var(--primary-color);
            cursor: pointer;
            border-radius: 0px;
            border: 1px solid var(--control-text);
            box-shadow: 1px 1px 2px rgba(0,0,0,0.4);
        }

        input[type="range"] + datalist {
            display: flex;
            justify-content: space-between;
            width: 100%;
            color: var(--text-on-panel);
            font-size: 0.7rem;
            margin-top: 0.1rem;
        }
        input[type="range"] + datalist option {
            padding: 0;
        }


        select, button {
            background-color: var(--background-panel-inset);
            color: var(--control-text); /* Default for buttons */
            border: 1px solid var(--border-panel);
            border-radius: 2px;
            padding: 0.12rem;
            transition: background-color 0.2s, box-shadow 0.2s;
            font-weight: 600;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.2), inset 1px 1px 1px rgba(255,255,255,0.5);
            text-shadow: 0px 1px 0px rgba(255,255,255,0.3);
        }

        select {
            width: 100%;
            padding-right: 0.5rem;
            padding-top: 0.12rem;
            padding-bottom: 0.12rem;
            padding-left: 0.12rem;
            color: #5C4033; /* Dark Brown for select text */
        }


        select:hover, button:hover {
            background-color: #c8bda9;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3), inset 1px 1px 2px rgba(0,0,0,0.1);
        }
        button:active {
            box-shadow: inset 2px 2px 3px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }

        button.panic-button {
            background-color: var(--primary-accent);
            color: var(--background-panel);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
            margin-top: 0.5rem;
            width: 100%;
            padding: 0.06rem 0.1rem; /* Reduced padding */
            font-size: 0.7rem; /* Reduced font size */
        }
        button.panic-button:hover {
            background-color: #A52A2A;
        }


        button:disabled, input:disabled, select:disabled {
            background-color: #A09483;
            color: #60544C;
            cursor: not-allowed;
            border-color: #70645C;
            box-shadow: inset 1px 1px 2px rgba(0,0,0,0.1);
            text-shadow: none;
        }

        .main-status-box {
            background-color: var(--background-panel);
            border: 2px solid var(--border-panel);
            padding: 0.15rem;
            border-radius: 2px;
            font-size: 0.85rem;
            color: var(--text-on-panel);
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.15);
            margin-top: 1rem;
            margin-bottom: 0;
        }
        .live-status-bar {
            background-color: var(--background-panel);
            border: 2px solid var(--border-panel);
            padding: 0.1rem 0.15rem;
            border-radius: 2px;
            font-size: 0.75rem;
            color: var(--text-on-panel);
            box-shadow: inset 1px 1px 3px rgba(0,0,0,0.15);
            margin-top: 0;
            display: flex;
            align-items: center;
        }


        .live-status-bar > div {
            display: flex;
            align-items: center;
        }
        .live-status-bar > div:not(:last-child) {
            margin-right: 1rem;
        }
        .live-status-bar > div:nth-child(1),
        .live-status-bar > div:nth-child(2) {
            flex-grow: 1;
            flex-basis: 0;
            overflow: visible;
        }


        .status-dot {
            display: inline-block;
            width: 0.7rem;
            height: 0.7rem;
            border-radius: 1px;
            background-color: var(--midi-in-inactive-color);
            margin-right: 0.4rem;
            transition: background-color 0.1s;
            border: 1px solid rgba(0,0,0,0.3);
        }
        .status-dot.active { background-color: var(--midi-in-active-color); }

        .live-status-bar .highlight {
            color: var(--primary-color);
            font-weight: 600;
            display: inline-block;
            vertical-align: bottom;
            max-width: none;
            background-color: rgba(0,0,0,0.05);
            padding: 0.02rem 0.06rem;
            border-radius: 1px;
        }

        footer {
            margin-top: 0.5rem;
            padding-top: 0.3rem;
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-on-console);
            opacity: 0.7;
            min-height: 20px;
        }


        *, ::before, ::after {
            border-width: 0;
        }

    </style>
</head>
<body> <div class="container">
    <div class="main-content">
        <div class="main-controls-area">
            <header class="text-center mb-6"> <h1 class="text-3xl font-bold">MIDI DELAY</h1> <p class="text-sm">A Device for the Temporal Displacement of Musical Notes</p> </header>
            <div>
                <div class="flex flex-col sm:flex-row sm:space-x-6 space-y-6 sm:space-y-0 mb-6">
                    <div class="settings-box sm:w-1/3 space-y-4">
                        <h2 class="text-md font-semibold text-center">INPUT CONFIGURATION</h2>
                        <div class="control-group">
                            <label for="midiInputSelect" class="font-medium">Source Apparatus:</label>
                            <select id="midiInputSelect" class="text-sm" disabled> </select>
                        </div>
                        <div class="control-group">
                            <label for="midiChannelSelect" class="font-medium">Channel:</label>
                            <select id="midiChannelSelect" class="text-sm" disabled> </select>
                        </div>
                    </div>

                    <div class="settings-box sm:w-1/3 space-y-4">
                        <h2 class="text-md font-semibold text-center">OUTPUT CONFIGURATION</h2>
                        <div class="control-group">
                            <label for="midiOutputSelect" class="font-medium">Destination Unit:</label>
                            <select id="midiOutputSelect" class="text-sm" disabled> </select>
                        </div>
                        <div class="control-group">
                            <label for="midiOutputChannelSelect" class="font-medium">Channel:</label>
                            <select id="midiOutputChannelSelect" class="text-sm" disabled> </select>
                        </div>
                        <div class="control-group">
                            <button id="panicButton" class="panic-button" disabled>ALL NOTES OFF / CLEAR ECHOES</button>
                        </div>
                    </div>

                    <div class="settings-box sm:w-1/3 space-y-4">
                        <h2 class="text-md font-semibold text-center">TEMPORAL EFFECTS</h2>
                        <div class="control-group">
                            <label for="delaySlider" class="block mb-1 font-medium">Delay Time: <span id="delayValue">0.25</span>s</label>
                            <input type="range" id="delaySlider" min="0" max="4" step="0.01" value="0.25" class="w-full" disabled>
                        </div>
                        <div class="control-group">
                            <label for="repeatsSlider" class="block mb-1 font-medium">Repeats: <span id="repeatsValue">7</span></label>
                            <input type="range" id="repeatsSlider" min="0" max="20" step="1" value="7" class="w-full" disabled>
                        </div>
                        <div class="control-group">
                            <label for="pitchShiftSlider" class="block mb-1 font-medium">Pitch Shift / Repeat: <span id="pitchShiftValue">1</span> st</label>
                            <input type="range" id="pitchShiftSlider" min="-12" max="12" step="1" value="1" class="w-full" list="pitchShiftTicks" disabled>
                            <datalist id="pitchShiftTicks"> </datalist>
                        </div>
                        <div class="control-group">
                            <label for="velocityScaleSlider" class="block mb-1 font-medium">Velocity Change / Repeat: <span id="velocityScaleValue">0</span></label>
                            <input type="range" id="velocityScaleSlider" min="-20" max="20" step="1" value="0" class="w-full" disabled>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="main-status-box" id="mainStatusMessages">Initializing Etheric Modulator...</div>
        <div class="live-status-bar">
            <div><span id="midiInActivity" class="status-dot"></span>In: <span id="currentInputDevice" class="highlight">-</span> Ch:<span id="currentInputChannel" class="highlight">-</span></div>
            <div>Out: <span id="currentOutputDevice" class="highlight">-</span> Ch:<span id="currentOutputChannel" class="highlight">-</span></div>
            <div class="ml-auto"> <span id="lastNotePlayedDisplay" class="highlight">-</span></div>
        </div>
    </div>
    <footer class="text-xs"></footer>
</div>

<script>
    const uiElements = {
        delaySlider: document.getElementById('delaySlider'),
        delayValueDisplay: document.getElementById('delayValue'),
        repeatsSlider: document.getElementById('repeatsSlider'),
        repeatsValueDisplay: document.getElementById('repeatsValue'),
        pitchShiftSlider: document.getElementById('pitchShiftSlider'),
        pitchShiftValueDisplay: document.getElementById('pitchShiftValue'),
        pitchShiftTicksDatalist: document.getElementById('pitchShiftTicks'),
        velocityScaleSlider: document.getElementById('velocityScaleSlider'),
        velocityScaleValueDisplay: document.getElementById('velocityScaleValue'),
        midiInputSelect: document.getElementById('midiInputSelect'),
        midiChannelSelect: document.getElementById('midiChannelSelect'),
        midiOutputSelect: document.getElementById('midiOutputSelect'),
        midiOutputChannelSelect: document.getElementById('midiOutputChannelSelect'),
        mainStatusMessages: document.getElementById('mainStatusMessages'),
        midiInActivityEl: document.getElementById('midiInActivity'),
        currentInputDeviceEl: document.getElementById('currentInputDevice'),
        currentInputChannelEl: document.getElementById('currentInputChannel'),
        currentOutputDeviceEl: document.getElementById('currentOutputDevice'),
        currentOutputChannelEl: document.getElementById('currentOutputChannel'),
        lastNotePlayedDisplay: document.getElementById('lastNotePlayedDisplay'),
        panicButton: document.getElementById('panicButton'),
    };

    const controlElementsForDisabling = [
        uiElements.delaySlider, uiElements.repeatsSlider, uiElements.pitchShiftSlider, uiElements.velocityScaleSlider,
        uiElements.midiInputSelect, uiElements.midiChannelSelect, uiElements.midiOutputSelect, uiElements.midiOutputChannelSelect,
        uiElements.panicButton
    ];

    const LOCAL_STORAGE_KEY = 'midiDelaySettings_1930s';
    const initialSettings = {
        delayTimeSec: 0.25, numberOfRepeats: 7, pitchShiftPerRepeat: 1, velocityChangePerRepeat: 0,
        selectedInputChannel: 0, selectedOutputChannel: 0, selectedMidiInputId: null, selectedMidiOutputId: null,
    };

    let settings = { ...initialSettings };
    let midiAccess = null;
    let midiInitialized = false;
    let scheduledEchoes = [];

    const NOTE_NAMES = ["C", "C♯", "D", "D♯", "E", "F", "F♯", "G", "G♯", "A", "A♯", "B"];

    function loadSettingsFromLocalStorage() {
        const savedSettings = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (savedSettings) {
            try {
                const parsed = JSON.parse(savedSettings);
                for (const key in initialSettings) {
                    settings[key] = parsed[key] !== undefined ? parsed[key] : initialSettings[key];
                }
                settings.delayTimeSec = parseFloat(settings.delayTimeSec);
                settings.numberOfRepeats = parseInt(settings.numberOfRepeats);
                settings.pitchShiftPerRepeat = parseInt(settings.pitchShiftPerRepeat);
                settings.velocityChangePerRepeat = parseInt(settings.velocityChangePerRepeat);
                settings.selectedInputChannel = parseInt(settings.selectedInputChannel);
                settings.selectedOutputChannel = parseInt(settings.selectedOutputChannel);

            } catch (e) {
                console.warn("Failed to parse settings from localStorage, using defaults.", e);
                settings = { ...initialSettings };
            }
        } else {
            settings = { ...initialSettings };
        }
    }

    function saveSettingsToLocalStorage() {
        try {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(settings));
        } catch (e) {
            console.warn("Failed to save settings to localStorage.", e);
        }
    }

    function midiNoteToName(noteNumber) {
        if (noteNumber < 0 || noteNumber > 127) return "";
        const octave = Math.floor(noteNumber / 12) - 1;
        const noteIndex = noteNumber % 12;
        return NOTE_NAMES[noteIndex] + octave;
    }

    function updateDelayTimeDisplay() {
        uiElements.delayValueDisplay.textContent = `${settings.delayTimeSec.toFixed(2)}s`;
    }

    function flashMidiInActivity() {
        uiElements.midiInActivityEl.classList.add('active');
        setTimeout(() => uiElements.midiInActivityEl.classList.remove('active'), 100);
    }

    function updateLiveStatusBar() {
        const inputDevice = settings.selectedMidiInputId && midiAccess ? midiAccess.inputs.get(settings.selectedMidiInputId) : null;
        const outputDevice = settings.selectedMidiOutputId && midiAccess ? midiAccess.outputs.get(settings.selectedMidiOutputId) : null;

        uiElements.currentInputDeviceEl.textContent = inputDevice ? inputDevice.name : '-';
        uiElements.currentInputChannelEl.textContent = midiInitialized ? (settings.selectedInputChannel + 1).toString() : '-';
        uiElements.currentOutputDeviceEl.textContent = outputDevice ? outputDevice.name : '-';
        uiElements.currentOutputChannelEl.textContent = midiInitialized ? (settings.selectedOutputChannel + 1).toString() : '-';
        uiElements.lastNotePlayedDisplay.textContent = uiElements.lastNotePlayedDisplay.textContent || '-';
    }

    async function initializeMidiSystem() {
        midiInitialized = false;
        if (midiAccess) {
            try {
                if (midiAccess.inputs) midiAccess.inputs.forEach(input => { if(input) input.onmidimessage = null; });
                if (midiAccess.onstatechange) midiAccess.onstatechange = null;
            } catch (e) { console.warn("Error during MIDI cleanup:", e); }
        }
        midiAccess = null;
        uiElements.mainStatusMessages.textContent = 'Initializing Etheric Modulator...';
        uiElements.lastNotePlayedDisplay.textContent = '-';
        disableControls();
        updateLiveStatusBar();


        if (navigator.requestMIDIAccess) {
            try {
                midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                midiInitialized = true;
                uiElements.mainStatusMessages.textContent = 'Etheric Modulator Online. Scanning Frequencies...';
                onMIDISuccess();
                enableControls();
            } catch (error) {
                onMIDIFailure(error);
            }
        } else {
            uiElements.mainStatusMessages.textContent = 'Web MIDI Transmission System not detected in this Chrono-Receiver.';
            onMIDIFailure({message: "Web MIDI API not supported."});
        }
    }

    function onMIDISuccess() {
        populateMidiDeviceSelectors();
        if (!midiAccess) { uiElements.mainStatusMessages.textContent = "Critical Error: Modulator Connection Lost."; return; }

        if (midiAccess.inputs.size === 0 && midiAccess.outputs.size === 0) uiElements.mainStatusMessages.textContent = 'No Input or Output Apparatuses Detected.';
        else if (midiAccess.inputs.size === 0) uiElements.mainStatusMessages.textContent = 'No Input Apparatuses Detected.';
        else if (midiAccess.outputs.size === 0) uiElements.mainStatusMessages.textContent = 'No Output Apparatuses Detected.';
        else uiElements.mainStatusMessages.textContent = 'Apparatuses Detected. Select input, channel, and output.';

        midiAccess.onstatechange = (event) => {
            uiElements.mainStatusMessages.textContent = `Apparatus ${event.port.name} (${event.port.type}) status: ${event.port.state}. Re-scanning...`;
            uiElements.lastNotePlayedDisplay.textContent = '-';
            setTimeout(() => {
                populateMidiDeviceSelectors();
                updateInputListeners();
                if (event.port.type === "output" && event.port.state === "disconnected" && event.port.id === settings.selectedMidiOutputId) {
                    uiElements.mainStatusMessages.textContent += " Output Disconnected.";
                    settings.selectedMidiOutputId = null;
                }
                if (event.port.type === "input" && event.port.state === "disconnected" && event.port.id === settings.selectedMidiInputId) {
                    uiElements.mainStatusMessages.textContent += " Input Disconnected.";
                    settings.selectedMidiInputId = null;
                }
                populateMidiDeviceSelectors();
                updateStatusMessage();
                updateLiveStatusBar();
            }, 100);
        };
        updateInputListeners();
        updateStatusMessage();
        updateLiveStatusBar();
    }


    function onMIDIFailure(error) {
        uiElements.mainStatusMessages.textContent = `Modulator Failure: ${error.message || 'Unknown Anomaly'}.`;
        uiElements.lastNotePlayedDisplay.textContent = 'Modulator Error';
        midiInitialized = false;
        disableControls();
        updateLiveStatusBar();
    }

    function populateMidiDeviceSelectors() {
        if (!midiAccess) return;

        const currentInputId = settings.selectedMidiInputId;
        const currentOutputId = settings.selectedMidiOutputId;

        const populate = (selectEl, devices, currentId, type) => {
            const previousValue = selectEl.value;
            selectEl.innerHTML = '';
            if (devices.size > 0) {
                devices.forEach(dev => { const opt = document.createElement('option'); opt.value = dev.id; opt.textContent = dev.name || `Unknown ${dev.type} ${dev.id.slice(0,5)}`; selectEl.appendChild(opt); });

                let newIdToSelect = null;
                if (currentId && devices.get(currentId)) {
                    newIdToSelect = currentId;
                } else if (previousValue && devices.get(previousValue)) {
                    newIdToSelect = previousValue;
                } else if (selectEl.options.length > 0) {
                    newIdToSelect = selectEl.options[0].value;
                }

                if (newIdToSelect) {
                    selectEl.value = newIdToSelect;
                } else {
                    selectEl.value = "";
                }
                return selectEl.value;

            } else {
                const opt = document.createElement('option'); opt.value = ""; opt.textContent = `No ${type} apparatuses`; selectEl.appendChild(opt);
                return null;
            }
        };

        settings.selectedMidiInputId = populate(uiElements.midiInputSelect, midiAccess.inputs, currentInputId, 'input');
        settings.selectedMidiOutputId = populate(uiElements.midiOutputSelect, midiAccess.outputs, currentOutputId, 'output');

        if (!midiAccess.inputs.get(settings.selectedMidiInputId)) settings.selectedMidiInputId = uiElements.midiInputSelect.value || null;
        if (!midiAccess.outputs.get(settings.selectedMidiOutputId)) settings.selectedMidiOutputId = uiElements.midiOutputSelect.value || null;


        updateStatusMessage();
        updateLiveStatusBar();
        saveSettingsToLocalStorage();
    }

    function updateInputListeners() {
        if (!midiAccess || !midiAccess.inputs) return;
        midiAccess.inputs.forEach(input => {
            if (input) input.onmidimessage = null;
        });

        const currentInput = settings.selectedMidiInputId ? midiAccess.inputs.get(settings.selectedMidiInputId) : null;
        if (currentInput) {
            currentInput.onmidimessage = handleMIDIMessage;
        }
        updateStatusMessage();
        updateLiveStatusBar();
    }


    function handleMIDIMessage(event) {
        if (!midiInitialized || !settings.selectedMidiOutputId) return;
        const outputDevice = midiAccess.outputs.get(settings.selectedMidiOutputId);
        if (!outputDevice) {
            uiElements.mainStatusMessages.textContent = "Critical Error: Output Apparatus Unavailable."; uiElements.lastNotePlayedDisplay.textContent = 'Output Error';
            settings.selectedMidiOutputId = null;
            populateMidiDeviceSelectors();
            return;
        }

        const originalStatusByte = event.data[0];
        const originalChannel = originalStatusByte & 0x0F;
        const command = originalStatusByte >> 4;
        const originalVelocity = (command === 0x9 || command === 0x8) && event.data.length > 2 ? event.data[2] : 64;

        if (originalChannel === settings.selectedInputChannel) {
            flashMidiInActivity();

            if (settings.numberOfRepeats === 0) {
                const newStatusByteForPassthrough = (command << 4) | settings.selectedOutputChannel;
                const finalMessageToSend = [newStatusByteForPassthrough, ...event.data.slice(1)];
                try {
                    outputDevice.send(finalMessageToSend);
                    showMidiActivityIndicator(false);
                    if ((finalMessageToSend[0] >> 4) === 0x9 && finalMessageToSend.length > 2 && finalMessageToSend[2] > 0) {
                        uiElements.lastNotePlayedDisplay.textContent = `Sent: Ch ${settings.selectedOutputChannel + 1} ${midiNoteToName(finalMessageToSend[1])} (Vel: ${finalMessageToSend[2]})`;
                    }
                } catch (error) { console.error("Error sending MIDI message (passthrough):", error); }
                return;
            }

            for (let r = 0; r < settings.numberOfRepeats; r++) {
                const currentDelayMs = settings.delayTimeSec * (r + 1) * 1000;
                let messageDataForThisRepeat = [...event.data];

                const intendedDeviceIdForEcho = settings.selectedMidiOutputId;
                const intendedChannelForEcho = settings.selectedOutputChannel;

                if (command === 0x9 || command === 0x8) {
                    if (messageDataForThisRepeat.length > 1) {
                        let originalNote = messageDataForThisRepeat[1];
                        let cumulativePitchShift = settings.pitchShiftPerRepeat * (r + 1);
                        let shiftedNote = originalNote + cumulativePitchShift;
                        shiftedNote = Math.max(0, Math.min(127, shiftedNote));
                        messageDataForThisRepeat[1] = shiftedNote;

                        if (messageDataForThisRepeat.length > 2) {
                            let currentVelocity = originalVelocity + (settings.velocityChangePerRepeat * (r + 1));
                            currentVelocity = Math.max(1, Math.min(127, currentVelocity));
                            messageDataForThisRepeat[2] = currentVelocity;
                        }
                    }
                }
                const newStatusByteForRepeat = (command << 4) | intendedChannelForEcho;
                const finalMessageToSend = [newStatusByteForRepeat, ...messageDataForThisRepeat.slice(1)];


                const timeoutId = setTimeout(() => {
                    const outputDeviceForEcho = midiAccess ? midiAccess.outputs.get(intendedDeviceIdForEcho) : null;
                    if (outputDeviceForEcho) {
                        try {
                            outputDeviceForEcho.send(finalMessageToSend);
                            showMidiActivityIndicator(true);
                            if ((finalMessageToSend[0] >> 4) === 0x9 && finalMessageToSend.length > 2 && finalMessageToSend[2] > 0) {
                                uiElements.lastNotePlayedDisplay.textContent = `Echo: Ch ${intendedChannelForEcho + 1} ${midiNoteToName(finalMessageToSend[1])} (Vel: ${finalMessageToSend[2]})`;
                            }
                        } catch (error) {
                            console.error("Error sending MIDI message (echo):", error);
                        }
                    }
                    scheduledEchoes = scheduledEchoes.filter(echo => echo.timeoutId !== timeoutId);
                }, currentDelayMs);

                scheduledEchoes.push({
                    timeoutId,
                    deviceId: intendedDeviceIdForEcho,
                    channel: intendedChannelForEcho
                });
            }
        }
    }


    function populateChannelSelect(selectElement, currentChannelVal) {
        selectElement.innerHTML = '';
        for (let i = 1; i <= 16; i++) {
            const option = document.createElement('option');
            option.value = i - 1;
            option.textContent = `Ch ${i}`;
            selectElement.appendChild(option);
        }
        let channelValue = parseInt(currentChannelVal); if (isNaN(channelValue) || channelValue < 0 || channelValue > 15) channelValue = 0;
        selectElement.value = channelValue; return channelValue;
    }

    function populatePitchShiftTicks() {
        uiElements.pitchShiftTicksDatalist.innerHTML = '';
        const ticks = [-12, -7, -5, 0, 5, 7, 12];
        for (let i = parseInt(uiElements.pitchShiftSlider.min); i <= parseInt(uiElements.pitchShiftSlider.max); i++) {
            const option = document.createElement('option');
            option.value = i;
            if (ticks.includes(i)) option.label = i.toString();
            uiElements.pitchShiftTicksDatalist.appendChild(option);
        }
    }

    function resetEffectSettings() {
        settings = { ...initialSettings };
        applyUISettings();
        updateStatusMessage();
        updateLiveStatusBar();
        saveSettingsToLocalStorage();
        uiElements.mainStatusMessages.textContent = "Calibrations Reset to Standard Values.";
    }

    function setControlsDisabledState(disabled) {
        controlElementsForDisabling.forEach(el => {
            if (el) el.disabled = disabled;
        });
    }

    function enableControls() {
        setControlsDisabledState(false);
    }
    function disableControls() {
        setControlsDisabledState(true);
    }

    function updateStatusMessage() {
        if (!midiInitialized || !midiAccess) {
            uiElements.mainStatusMessages.textContent = midiInitialized ? "Modulator Standby..." : "Modulator Offline.";
            return;
        }
        const inputObj = settings.selectedMidiInputId ? midiAccess.inputs.get(settings.selectedMidiInputId) : null;
        const outputObj = settings.selectedMidiOutputId ? midiAccess.outputs.get(settings.selectedMidiOutputId) : null;
        const inputName = inputObj ? inputObj.name : 'None';
        const outputName = outputObj ? outputObj.name : 'None';

        uiElements.mainStatusMessages.textContent =
            `Input: ${inputName} (Ch ${settings.selectedInputChannel + 1})  |  ` +
            `Output: ${outputName} (Ch ${settings.selectedOutputChannel + 1})  |  ` +
            `Delay: ${settings.delayTimeSec.toFixed(2)}s  |  ` +
            `Repeats: ${settings.numberOfRepeats}  |  ` +
            `Pitch Shift: ${settings.pitchShiftPerRepeat}st  |  ` +
            `Velocity Change: ${settings.velocityChangePerRepeat}`;
        updateLiveStatusBar();
    }

    function setupSliderListener(sliderElem, valueDisplayElem, settingKey, options = {}) {
        const { parseFn = parseFloat, displaySuffix = '', valueFormatter } = options;

        sliderElem.addEventListener('input', (event) => {
            const rawValue = event.target.value;
            settings[settingKey] = parseFn(rawValue);

            if (valueFormatter) {
                valueDisplayElem.textContent = valueFormatter(settings[settingKey]);
            } else if (settingKey === 'delayTimeSec') {
                valueDisplayElem.textContent = `${settings[settingKey].toFixed(2)}${displaySuffix || 's'}`;
            }
            else {
                valueDisplayElem.textContent = `${settings[settingKey]}${displaySuffix}`;
            }

            updateStatusMessage();
            saveSettingsToLocalStorage();
        });
    }

    function applyUISettings() {
        uiElements.delaySlider.value = settings.delayTimeSec;
        uiElements.repeatsSlider.value = settings.numberOfRepeats;
        uiElements.pitchShiftSlider.value = settings.pitchShiftPerRepeat;
        uiElements.velocityScaleSlider.value = settings.velocityChangePerRepeat;

        updateDelayTimeDisplay();
        uiElements.repeatsValueDisplay.textContent = settings.numberOfRepeats;
        uiElements.pitchShiftValueDisplay.textContent = `${settings.pitchShiftPerRepeat} st`;
        uiElements.velocityScaleValueDisplay.textContent = settings.velocityChangePerRepeat;

        if (uiElements.midiInputSelect.options.length > 0 && settings.selectedMidiInputId) {
            uiElements.midiInputSelect.value = settings.selectedMidiInputId;
        }
        if (uiElements.midiOutputSelect.options.length > 0 && settings.selectedMidiOutputId) {
            uiElements.midiOutputSelect.value = settings.selectedMidiOutputId;
        }
        uiElements.midiChannelSelect.value = settings.selectedInputChannel;
        uiElements.midiOutputChannelSelect.value = settings.selectedOutputChannel;

        updateLiveStatusBar();
    }

    function clearAllScheduledEchoes() {
        scheduledEchoes.forEach(echo => clearTimeout(echo.timeoutId));
        scheduledEchoes = [];
        console.log("All scheduled echoes cleared.");
    }

    function sendAllNotesOffToDevice(deviceId, channel) {
        if (!midiAccess || !deviceId) return;
        const outputDevice = midiAccess.outputs.get(deviceId);
        if (outputDevice) {
            try {
                const allNotesOffMessage = [(0xB0 | channel), 123, 0]; // CC 123: All Notes Off
                outputDevice.send(allNotesOffMessage);
                console.log(`Sent All Notes Off to Ch ${channel + 1} on ${outputDevice.name}`);
            } catch (error) {
                console.error(`Error sending All Notes Off to Ch ${channel + 1} on ${outputDevice.name}:`, error);
            }
        }
    }

    function sendAllNotesOffToAllChannelsOnDevice(deviceId) {
        if (!midiAccess || !deviceId) return;
        const outputDevice = midiAccess.outputs.get(deviceId);
        if (outputDevice) {
            for (let ch = 0; ch < 16; ch++) {
                try {
                    const allNotesOffMessage = [(0xB0 | ch), 123, 0];
                    outputDevice.send(allNotesOffMessage);
                } catch (error) {
                    console.error(`Error sending All Notes Off to Ch ${ch + 1} on ${outputDevice.name}:`, error);
                }
            }
            console.log(`Sent All Notes Off to ALL CHANNELS on ${outputDevice.name}`);
            uiElements.mainStatusMessages.textContent = `All notes off sent to ${outputDevice.name}. Echoes cleared.`;

        }
    }


    document.addEventListener('DOMContentLoaded', () => {
        loadSettingsFromLocalStorage();

        settings.selectedInputChannel = populateChannelSelect(uiElements.midiChannelSelect, settings.selectedInputChannel);
        settings.selectedOutputChannel = populateChannelSelect(uiElements.midiOutputChannelSelect, settings.selectedOutputChannel);
        populatePitchShiftTicks();

        applyUISettings();

        setupSliderListener(uiElements.delaySlider, uiElements.delayValueDisplay, 'delayTimeSec', {
            valueFormatter: val => `${parseFloat(val).toFixed(2)}s`
        });
        setupSliderListener(uiElements.repeatsSlider, uiElements.repeatsValueDisplay, 'numberOfRepeats', { parseFn: parseInt });
        setupSliderListener(uiElements.pitchShiftSlider, uiElements.pitchShiftValueDisplay, 'pitchShiftPerRepeat', { parseFn: parseInt, displaySuffix: ' st' });
        setupSliderListener(uiElements.velocityScaleSlider, uiElements.velocityScaleValueDisplay, 'velocityChangePerRepeat', { parseFn: parseInt });

        uiElements.midiInputSelect.addEventListener('change', (event) => {
            settings.selectedMidiInputId = event.target.value;
            updateInputListeners();
            saveSettingsToLocalStorage();
            if (midiInitialized) { updateStatusMessage(); updateLiveStatusBar(); }
        });

        uiElements.midiChannelSelect.addEventListener('change', (event) => {
            settings.selectedInputChannel = parseInt(event.target.value);
            saveSettingsToLocalStorage();
            if (midiInitialized) { updateStatusMessage(); updateLiveStatusBar(); }
        });

        uiElements.midiOutputSelect.addEventListener('change', (event) => {
            const newDeviceId = event.target.value;
            const oldDeviceId = settings.selectedMidiOutputId;
            const channelThatWasActiveOnOldDevice = settings.selectedOutputChannel;

            if (midiInitialized && oldDeviceId && oldDeviceId !== newDeviceId) {
                clearAllScheduledEchoes();
                sendAllNotesOffToDevice(oldDeviceId, channelThatWasActiveOnOldDevice);
            }
            settings.selectedMidiOutputId = newDeviceId;
            if (midiInitialized) { updateStatusMessage(); updateLiveStatusBar(); }
            saveSettingsToLocalStorage();
        });

        uiElements.midiOutputChannelSelect.addEventListener('change', (event) => {
            const newChannel = parseInt(event.target.value);
            const oldChannelOnCurrentDevice = settings.selectedOutputChannel;
            const currentDeviceId = settings.selectedMidiOutputId;

            if (midiInitialized && currentDeviceId && oldChannelOnCurrentDevice !== newChannel) {
                const echoesToClear = scheduledEchoes.filter(echo =>
                    echo.deviceId === currentDeviceId && echo.channel === oldChannelOnCurrentDevice
                );
                echoesToClear.forEach(echo => clearTimeout(echo.timeoutId));
                scheduledEchoes = scheduledEchoes.filter(echo =>
                    !(echo.deviceId === currentDeviceId && echo.channel === oldChannelOnCurrentDevice)
                );
                sendAllNotesOffToDevice(currentDeviceId, oldChannelOnCurrentDevice);
            }
            settings.selectedOutputChannel = newChannel;
            if (midiInitialized) { updateStatusMessage(); updateLiveStatusBar(); }
            saveSettingsToLocalStorage();
        });

        uiElements.panicButton.addEventListener('click', () => {
            if (!midiInitialized || !midiAccess) {
                uiElements.mainStatusMessages.textContent = "Modulator offline. Cannot send panic.";
                return;
            }
            clearAllScheduledEchoes();
            if (settings.selectedMidiOutputId) {
                sendAllNotesOffToAllChannelsOnDevice(settings.selectedMidiOutputId);
            } else {
                uiElements.mainStatusMessages.textContent = "No output device selected for panic.";
            }
        });

        initializeMidiSystem();
    });

    let originalBorderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-panel').trim() || '#8B4513';
    const activityBlinkColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-accent').trim() || '#8B0000';

    function showMidiActivityIndicator(isEcho) {
        uiElements.mainStatusMessages.style.borderColor = activityBlinkColor;
        setTimeout(() => {
            originalBorderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-panel').trim();
            uiElements.mainStatusMessages.style.borderColor = originalBorderColor;
        }, 150);
    }
</script>
</body>
</html>
