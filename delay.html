<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Echo Unit - Model 70</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    <style>
        /* 1970s Synth Inspired Color Palette & Styles */
        :root {
            --synth-cream: #f5e6cc;
            --synth-orange: #ff8c00;
            --synth-brown-dark: #3d2314;
            --synth-brown-medium: #6f4e37;
            --synth-panel-bg: #e0dac7;
            --synth-slider-track: #5a3d2b;
            --synth-text-primary: var(--synth-brown-dark);
            --synth-text-secondary: #5c4033;
            --midi-in-active-color: #32cd32;
            --midi-in-inactive-color: #7f7f7f;
        }

        body {
            font-family: 'Roboto Mono', monospace;
            background-color: var(--synth-brown-dark);
            color: var(--synth-text-primary);
            padding-top: 1rem; padding-bottom: 1rem;
        }
        .container {
            max-width: 850px;
            margin: 1rem auto;
            padding: 1.5rem;
            background-color: var(--synth-cream);
            border: 4px solid var(--synth-brown-dark);
            border-radius: 10px;
            box-shadow: 0 8px 15px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255,255,255,0.2), inset 0 -2px 4px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
        }
        .main-content {
            flex-grow: 1;
        }
        .control-group label {
            color: var(--synth-text-secondary);
            margin-bottom: 0.25rem;
            display: block;
            font-size: 0.75rem;
            text-transform: uppercase;
            font-weight: bold;
        }
        input[type="range"] {
            width: 100%; height: 20px;
            background: transparent;
            outline: none;
            -webkit-appearance: none; appearance: none;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%; height: 6px; background: var(--synth-slider-track);
            border-radius: 3px; border: 1px solid var(--synth-brown-dark);
        }
        input[type="range"]::-moz-range-track {
            width: 100%; height: 6px; background: var(--synth-slider-track);
            border-radius: 3px; border: 1px solid var(--synth-brown-dark);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 14px; height: 28px;
            background: var(--synth-orange);
            border: 2px solid var(--synth-brown-dark);
            border-radius: 3px;
            margin-top: -12px;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        input[type="range"]::-moz-range-thumb {
            width: 14px; height: 28px; background: var(--synth-orange);
            border: 2px solid var(--synth-brown-dark); border-radius: 3px;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        select, button {
            background-color: var(--synth-brown-medium);
            color: var(--synth-cream);
            border: 2px solid var(--synth-brown-dark);
            border-radius: 4px;
            padding: 0.4rem 0.6rem;
            transition: background-color 0.2s;
            font-family: 'Roboto Mono', monospace;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            font-size: 0.8rem;
        }
        select { width: 100%; }
        button { width: auto; padding: 0.4rem 0.8rem;}

        footer button {
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
            background-color: var(--synth-panel-bg);
            color: var(--synth-brown-dark);
            border-color: var(--synth-brown-medium);
        }
        footer button:hover {
            background-color: var(--synth-orange);
            color: var(--synth-cream);
        }

        select:hover, button:hover { background-color: var(--synth-orange); color: var(--synth-cream); }
        button:active, select:active { transform: translateY(1px); box-shadow: inset 1px 1px 2px rgba(0,0,0,0.4); }

        button:disabled, input:disabled, select:disabled {
            background-color: #a0a0a0; color: #505050;
            cursor: not-allowed; border-color: #707070;
            box-shadow: none;
        }

        .main-status-box {
            background-color: var(--synth-panel-bg); border: 1px solid var(--synth-brown-medium);
            padding: 0.5rem; border-radius: 4px; min-height: 30px;
            font-size: 0.75rem; color: var(--synth-text-secondary);
            margin-top: 1rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        .live-status-bar {
            background-color: var(--synth-panel-bg); border-top: 2px solid var(--synth-brown-dark);
            padding: 0.35rem 0.75rem; border-radius: 0 0 8px 8px;
            font-size: 0.75rem;
            color: var(--synth-text-secondary);
            display: flex;
            align-items: center;
            margin-top: 1rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        .live-status-bar > div {
            display: flex; align-items: center; margin-bottom: 0.25rem;
        }
        .live-status-bar > div:not(:last-child) { margin-right: 0.75rem; }
        .live-status-bar > div:nth-child(1),
        .live-status-bar > div:nth-child(2) {
            flex-grow: 1; flex-basis: 0; min-width: 100px; overflow: hidden;
        }

        .status-dot {
            display: inline-block; width: 0.7rem; height: 0.7rem;
            border-radius: 50%; background-color: var(--midi-in-inactive-color);
            margin-right: 0.4rem; transition: background-color 0.1s;
            border: 1px solid var(--synth-brown-dark);
        }
        .status-dot.active { background-color: var(--midi-in-active-color); box-shadow: 0 0 5px var(--midi-in-active-color);}
        .live-status-bar .highlight {
            color: var(--synth-orange);
            font-weight: bold;
            display: inline-block; white-space: nowrap;
            overflow: hidden; text-overflow: ellipsis;
            vertical-align: bottom; max-width: 100px;
        }

        header h1 { font-family: 'Orbitron', sans-serif; font-size: 1.8rem; color: var(--synth-orange); text-shadow: 1px 1px 0px var(--synth-brown-dark); }
        header p { font-size: 0.8rem; color: var(--synth-text-secondary); }
        .settings-box {
            background-color: var(--synth-panel-bg); padding: 1rem;
            border-radius: 6px; border: 2px solid var(--synth-brown-dark);
            display: flex; flex-direction: column;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 1px 2px rgba(255,255,255,0.1);
        }
        .settings-box h2 {
            margin-bottom: 1rem; color: var(--synth-text-primary);
            font-family: 'Orbitron', sans-serif; font-size: 0.85rem;
            text-transform: uppercase;
            border-bottom: 1px solid var(--synth-brown-medium);
            padding-bottom: 0.3rem;
            font-weight: bold;
        }
        input[type="range"] + datalist {
            display: flex; justify-content: space-between; width: 100%;
            color: var(--synth-text-secondary); font-size: 0.7rem; margin-top: 0.1rem;
        }
        footer { margin-top: auto; padding-top: 1rem; color: var(--synth-text-secondary); }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">
<div class="container">
    <div class="main-content">
        <header class="text-center mb-6">
            <h1 class="font-bold">MIDI ECHO UNIT</h1>
            <p>Model MDE-77</p>
        </header>

        <div>
            <div class="flex flex-col lg:flex-row lg:space-x-4 space-y-4 lg:space-y-0 mb-6">
                <div class="settings-box lg:w-1/3 space-y-4">
                    <h2 class="text-center">MIDI INPUT</h2>
                    <div class="control-group">
                        <label for="midiInputSelect">Source:</label>
                        <select id="midiInputSelect" class="p-2 text-sm" disabled> </select>
                    </div>
                    <div class="control-group">
                        <label for="midiChannelSelect">CH:</label>
                        <select id="midiChannelSelect" class="p-2 text-sm" disabled> </select>
                    </div>
                </div>

                <div class="settings-box lg:w-1/3 space-y-4">
                    <h2 class="text-center">MIDI OUTPUT</h2>
                    <div class="control-group">
                        <label for="midiOutputSelect">Destination:</label>
                        <select id="midiOutputSelect" class="p-2 text-sm" disabled> </select>
                    </div>
                    <div class="control-group">
                        <label for="midiOutputChannelSelect">CH:</label>
                        <select id="midiOutputChannelSelect" class="p-2 text-sm" disabled> </select>
                    </div>
                </div>

                <div class="settings-box lg:w-1/3 space-y-4">
                    <h2 class="text-center">ECHO PARAMETERS</h2>
                    <div class="control-group">
                        <label for="delaySlider">TIME: <span id="delayValue" class="font-bold text-[var(--synth-orange)]">0.25</span>s</label>
                        <input type="range" id="delaySlider" min="0" max="4" step="0.01" value="0.25" class="w-full" disabled>
                    </div>
                    <div class="control-group">
                        <label for="repeatsSlider">FEEDBACK: <span id="repeatsValue" class="font-bold text-[var(--synth-orange)]">7</span></label>
                        <input type="range" id="repeatsSlider" min="0" max="20" step="1" value="7" class="w-full" disabled>
                    </div>
                    <div class="control-group">
                        <label for="pitchShiftSlider">PITCH MOD: <span id="pitchShiftValue" class="font-bold text-[var(--synth-orange)]">1</span> st</label>
                        <input type="range" id="pitchShiftSlider" min="-12" max="12" step="1" value="1" class="w-full" list="pitchShiftTicks" disabled>
                        <datalist id="pitchShiftTicks"> </datalist>
                    </div>
                    <div class="control-group">
                        <label for="velocityScaleSlider">VEL. MOD: <span id="velocityScaleValue" class="font-bold text-[var(--synth-orange)]">0</span></label>
                        <input type="range" id="velocityScaleSlider" min="-20" max="20" step="1" value="0" class="w-full" disabled>
                    </div>
                </div>
            </div>
        </div>
        <div class="main-status-box mb-4" id="mainStatusMessages">Initializing Echo Unit...</div>
    </div>

    <footer class="text-center text-xs">
        <p class="mb-2">Retro Sound Design Inc.</p>
        <button id="reInitMidiButton" class="mt-1">RE-PATCH</button>
        <button id="resetEffectsButton" class="mt-1 ml-2">ZERO ALL</button>
    </footer>

    <div class="live-status-bar">
        <div><span id="midiInActivity" class="status-dot"></span>IN: <span id="currentInputDevice" class="highlight">-</span> CH:<span id="currentInputChannel" class="highlight">-</span></div>
        <div>OUT: <span id="currentOutputDevice" class="highlight">-</span> CH:<span id="currentOutputChannel" class="highlight">-</span></div>
        <div class="ml-auto"> <span id="lastNotePlayedDisplay" class="highlight">-</span>
            <span id="timeToNextEchoDisplay" class="ml-2">NEXT: --</span>
        </div>
    </div>

</div>

<script>
    const reInitMidiButton = document.getElementById('reInitMidiButton');
    const delaySlider = document.getElementById('delaySlider');
    const delayValueDisplay = document.getElementById('delayValue');
    const repeatsSlider = document.getElementById('repeatsSlider');
    const repeatsValueDisplay = document.getElementById('repeatsValue');
    const pitchShiftSlider = document.getElementById('pitchShiftSlider');
    const pitchShiftValueDisplay = document.getElementById('pitchShiftValue');
    const pitchShiftTicksDatalist = document.getElementById('pitchShiftTicks');
    const velocityScaleSlider = document.getElementById('velocityScaleSlider');
    const velocityScaleValueDisplay = document.getElementById('velocityScaleValue');
    const resetEffectsButton = document.getElementById('resetEffectsButton');

    const midiInputSelect = document.getElementById('midiInputSelect');
    const midiChannelSelect = document.getElementById('midiChannelSelect');
    const midiOutputSelect = document.getElementById('midiOutputSelect');
    const midiOutputChannelSelect = document.getElementById('midiOutputChannelSelect');
    const mainStatusMessages = document.getElementById('mainStatusMessages');

    const midiInActivityEl = document.getElementById('midiInActivity');
    const currentInputDeviceEl = document.getElementById('currentInputDevice');
    const currentInputChannelEl = document.getElementById('currentInputChannel');
    const currentOutputDeviceEl = document.getElementById('currentOutputDevice');
    const currentOutputChannelEl = document.getElementById('currentOutputChannel');
    const lastNotePlayedDisplay = document.getElementById('lastNotePlayedDisplay');
    const timeToNextEchoDisplay = document.getElementById('timeToNextEchoDisplay');

    const LOCAL_STORAGE_KEY = 'midiDelaySynthSettings_v1_analog';
    const initialDefaults = {
        delayTimeSec: 0.25, numberOfRepeats: 7, pitchShiftPerRepeat: 1, velocityChangePerRepeat: 0,
        selectedInputChannel: 0, selectedOutputChannel: 0, selectedMidiInputId: null, selectedMidiOutputId: null,
    };

    let delayTimeSec = initialDefaults.delayTimeSec;
    let numberOfRepeats = initialDefaults.numberOfRepeats;
    let pitchShiftPerRepeat = initialDefaults.pitchShiftPerRepeat;
    let velocityChangePerRepeat = initialDefaults.velocityChangePerRepeat;
    let selectedInputChannel = initialDefaults.selectedInputChannel;
    let selectedOutputChannel = initialDefaults.selectedOutputChannel;
    let selectedMidiInputId = initialDefaults.selectedMidiInputId;
    let selectedMidiOutputId = initialDefaults.selectedMidiOutputId;
    let midiAccess = null; let midiInitialized = false;
    let nextEchoFireTime = 0; let countdownInterval = null;

    const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    function loadSettingsFromLocalStorage() {
        const savedSettings = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                delayTimeSec = settings.delayTimeSec !== undefined ? parseFloat(settings.delayTimeSec) : initialDefaults.delayTimeSec;
                numberOfRepeats = settings.numberOfRepeats !== undefined ? parseInt(settings.numberOfRepeats) : initialDefaults.numberOfRepeats;
                pitchShiftPerRepeat = settings.pitchShiftPerRepeat !== undefined ? parseInt(settings.pitchShiftPerRepeat) : initialDefaults.pitchShiftPerRepeat;
                velocityChangePerRepeat = settings.velocityChangePerRepeat !== undefined ? parseInt(settings.velocityChangePerRepeat) : initialDefaults.velocityChangePerRepeat;
                selectedInputChannel = settings.selectedInputChannel !== undefined ? parseInt(settings.selectedInputChannel) : initialDefaults.selectedInputChannel;
                selectedOutputChannel = settings.selectedOutputChannel !== undefined ? parseInt(settings.selectedOutputChannel) : initialDefaults.selectedOutputChannel;
                selectedMidiInputId = settings.selectedMidiInputId || initialDefaults.selectedMidiInputId;
                selectedMidiOutputId = settings.selectedMidiOutputId || initialDefaults.selectedMidiOutputId;
            } catch (e) {
                delayTimeSec = initialDefaults.delayTimeSec; numberOfRepeats = initialDefaults.numberOfRepeats;
                pitchShiftPerRepeat = initialDefaults.pitchShiftPerRepeat; velocityChangePerRepeat = initialDefaults.velocityChangePerRepeat;
                selectedInputChannel = initialDefaults.selectedInputChannel; selectedOutputChannel = initialDefaults.selectedOutputChannel;
                selectedMidiInputId = initialDefaults.selectedMidiInputId; selectedMidiOutputId = initialDefaults.selectedMidiOutputId;
            }
        }
    }

    function saveSettingsToLocalStorage() {
        const settingsToSave = {
            delayTimeSec, numberOfRepeats, pitchShiftPerRepeat, velocityChangePerRepeat,
            selectedInputChannel, selectedOutputChannel, selectedMidiInputId, selectedMidiOutputId
        };
        try {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(settingsToSave));
        } catch (e) {}
    }

    function midiNoteToName(noteNumber) {
        if (noteNumber < 0 || noteNumber > 127) return "";
        const octave = Math.floor(noteNumber / 12) - 1;
        const noteIndex = noteNumber % 12;
        return NOTE_NAMES[noteIndex] + octave;
    }

    function updateDelayValueDisplay() {
        delayValueDisplay.textContent = delayTimeSec.toFixed(2);
    }

    function startCountdownTimer() {
        if (countdownInterval) clearInterval(countdownInterval);
        if (nextEchoFireTime > 0) {
            countdownInterval = setInterval(() => {
                const remainingTime = nextEchoFireTime - Date.now();
                if (remainingTime <= 0) {
                    timeToNextEchoDisplay.textContent = "NEXT: --"; clearInterval(countdownInterval); nextEchoFireTime = 0;
                } else { timeToNextEchoDisplay.textContent = `NEXT: ${(remainingTime / 1000).toFixed(2)}s`; }
            }, 50);
        } else { timeToNextEchoDisplay.textContent = "NEXT: --"; }
    }

    function flashMidiInActivity() {
        midiInActivityEl.classList.add('active');
        setTimeout(() => midiInActivityEl.classList.remove('active'), 150);
    }

    function updateLiveStatusBar() {
        const inputDevice = selectedMidiInputId && midiAccess ? midiAccess.inputs.get(selectedMidiInputId) : null;
        const outputDevice = selectedMidiOutputId && midiAccess ? midiAccess.outputs.get(selectedMidiOutputId) : null;

        currentInputDeviceEl.textContent = inputDevice ? (inputDevice.name.length > 10 ? inputDevice.name.substring(0,8) + '..' : inputDevice.name) : '-';
        currentInputChannelEl.textContent = midiInitialized ? (selectedInputChannel + 1).toString() : '-';
        currentOutputDeviceEl.textContent = outputDevice ? (outputDevice.name.length > 10 ? outputDevice.name.substring(0,8) + '..' : outputDevice.name) : '-';
        currentOutputChannelEl.textContent = midiInitialized ? (selectedOutputChannel + 1).toString() : '-';
    }

    async function initializeMidiSystem() {
        midiInitialized = false;
        if (midiAccess) {
            try {
                if (midiAccess.inputs) midiAccess.inputs.forEach(input => input.onmidimessage = null);
                if (midiAccess.onstatechange) midiAccess.onstatechange = null;
            } catch (e) {}
        }
        midiAccess = null;
        mainStatusMessages.textContent = 'Initializing Echo Unit...';
        lastNotePlayedDisplay.textContent = '-';
        timeToNextEchoDisplay.textContent = 'NEXT: --';
        updateLiveStatusBar();

        if (navigator.requestMIDIAccess) {
            try {
                midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                midiInitialized = true;
                mainStatusMessages.textContent = 'MIDI System Online.';
                onMIDISuccess(); enableControls();
            } catch (error) { onMIDIFailure(error); }
        } else {
            mainStatusMessages.textContent = 'Web MIDI Interface Not Detected.';
            onMIDIFailure({message: "Web MIDI API not supported."});
        }
    }

    function onMIDISuccess() {
        populateMidiDeviceSelectors();
        if (!midiAccess) { mainStatusMessages.textContent = "Error: MIDI Access Lost."; return; }

        if (midiAccess.inputs.size === 0 && midiAccess.outputs.size === 0) mainStatusMessages.textContent = 'No MIDI Ports Found.';
        else if (midiAccess.inputs.size === 0) mainStatusMessages.textContent = 'No MIDI Input Ports Found.';
        else if (midiAccess.outputs.size === 0) mainStatusMessages.textContent = 'No MIDI Output Ports Found.';
        else mainStatusMessages.textContent = 'MIDI Ports Detected. Patch In/Out.';

        midiAccess.onstatechange = (event) => {
            mainStatusMessages.textContent = `MIDI Port ${event.port.name} ${event.port.state}. Re-scanning...`;
            lastNotePlayedDisplay.textContent = '-'; timeToNextEchoDisplay.textContent = 'NEXT: --';
            setTimeout(() => {
                populateMidiDeviceSelectors(); updateInputListeners();
                if (event.port.type === "output" && event.port.state === "disconnected" && event.port.id === selectedMidiOutputId) mainStatusMessages.textContent += " Output Unpatched.";
                if (event.port.type === "input" && event.port.state === "disconnected" && event.port.id === selectedMidiInputId) mainStatusMessages.textContent += " Input Unpatched.";
                updateStatusMessage();
            }, 100);
        };
        updateInputListeners();
        updateStatusMessage();
    }

    function onMIDIFailure(error) {
        mainStatusMessages.textContent = `MIDI Access Error: ${error.message || 'Unknown'}.`;
        lastNotePlayedDisplay.textContent = 'MIDI Error'; timeToNextEchoDisplay.textContent = 'NEXT: --';
        midiInitialized = false;
        updateLiveStatusBar();
        [delaySlider, repeatsSlider, pitchShiftSlider, velocityScaleSlider, midiInputSelect, midiChannelSelect, midiOutputSelect, midiOutputChannelSelect, resetEffectsButton, reInitMidiButton].forEach(el => el.disabled = true);
    }

    function populateMidiDeviceSelectors() {
        if (!midiAccess) return;
        const populate = (selectEl, devices, currentId) => {
            selectEl.innerHTML = '';
            if (devices.size > 0) {
                devices.forEach(dev => { const opt = document.createElement('option'); opt.value = dev.id; opt.textContent = dev.name || `Port ${dev.id.slice(0,5)}`; selectEl.appendChild(opt); });
                const newId = currentId && devices.get(currentId) ? currentId : (selectEl.options.length > 0 ? selectEl.options[0].value : null);
                if (newId) selectEl.value = newId; return newId;
            } else { const opt = document.createElement('option'); opt.value = ""; opt.textContent = `No ${selectEl === midiInputSelect ? 'In' : 'Out'} Ports`; selectEl.appendChild(opt); return null; }
        };
        selectedMidiInputId = populate(midiInputSelect, midiAccess.inputs, selectedMidiInputId);
        selectedMidiOutputId = populate(midiOutputSelect, midiAccess.outputs, selectedMidiOutputId);
        updateStatusMessage();
        saveSettingsToLocalStorage();
    }

    function updateInputListeners() {
        if (!midiAccess) return;
        midiAccess.inputs.forEach(input => input.onmidimessage = null);
        const currentInput = selectedMidiInputId ? midiAccess.inputs.get(selectedMidiInputId) : null;
        if (currentInput) currentInput.onmidimessage = handleMIDIMessage;
        updateStatusMessage();
    }

    function handleMIDIMessage(event) {
        if (!midiInitialized || !selectedMidiOutputId) return;
        const outputDevice = midiAccess.outputs.get(selectedMidiOutputId);
        if (!outputDevice) {
            mainStatusMessages.textContent = "Error: Output Port Unavailable."; lastNotePlayedDisplay.textContent = 'Output Error';
            selectedMidiOutputId = null; midiOutputSelect.value = ""; populateMidiDeviceSelectors(); return;
        }

        const originalStatusByte = event.data[0];
        const originalChannel = originalStatusByte & 0x0F;
        const command = originalStatusByte >> 4;
        const originalVelocity = (command === 0x9 || command === 0x8) && event.data.length > 2 ? event.data[2] : 64;

        if (originalChannel === selectedInputChannel) {
            flashMidiInActivity();
            const effectiveDelayTime = delayTimeSec; nextEchoFireTime = 0;

            for (let r = 0; r < numberOfRepeats; r++) {
                const currentDelay = effectiveDelayTime * (r + 1);
                let messageDataForThisRepeat = [...event.data];

                if (command === 0x9 || command === 0x8) {
                    if (messageDataForThisRepeat.length > 1) {
                        let originalNote = messageDataForThisRepeat[1];
                        let cumulativePitchShift = pitchShiftPerRepeat * (r + 1);
                        let shiftedNote = originalNote + cumulativePitchShift;
                        shiftedNote = Math.max(0, Math.min(127, shiftedNote)); messageDataForThisRepeat[1] = shiftedNote;
                        if (messageDataForThisRepeat.length > 2) {
                            let currentVelocity = originalVelocity + (velocityChangePerRepeat * (r + 1));
                            currentVelocity = Math.max(1, Math.min(127, currentVelocity)); messageDataForThisRepeat[2] = currentVelocity;
                        }
                    }
                }
                const newStatusByteForRepeat = (command << 4) | selectedOutputChannel;
                const finalMessageToSend = [newStatusByteForRepeat, ...messageDataForThisRepeat.slice(1)];

                if (r === 0) { nextEchoFireTime = Date.now() + (currentDelay * 1000); startCountdownTimer(); }

                setTimeout(() => {
                    const currentOutputDevice = midiAccess ? midiAccess.outputs.get(selectedMidiOutputId) : null;
                    if (currentOutputDevice) {
                        try {
                            currentOutputDevice.send(finalMessageToSend); showMidiActivityIndicator(true);
                            if ((finalMessageToSend[0] >> 4) === 0x9 && finalMessageToSend.length > 2 && finalMessageToSend[2] > 0) {
                                lastNotePlayedDisplay.textContent = `ECHO: ${midiNoteToName(finalMessageToSend[1])} (V:${finalMessageToSend[2]})`;
                            }
                            if (Date.now() >= nextEchoFireTime - 50) {
                                if (r + 1 < numberOfRepeats) { nextEchoFireTime = Date.now() + (effectiveDelayTime * 1000); startCountdownTimer(); }
                                else { nextEchoFireTime = 0; startCountdownTimer(); }
                            }
                        } catch (error) { }
                    }
                }, currentDelay * 1000);
            }
            if (numberOfRepeats === 0) { nextEchoFireTime = 0; startCountdownTimer(); }
        }
    }

    function populateChannelSelect(selectElement, currentChannelVal) {
        selectElement.innerHTML = '';
        for (let i = 1; i <= 16; i++) { const option = document.createElement('option'); option.value = i - 1; option.textContent = `Ch ${i}`; selectElement.appendChild(option); }
        let channelValue = parseInt(currentChannelVal); if (isNaN(channelValue) || channelValue < 0 || channelValue > 15) channelValue = 0;
        selectElement.value = channelValue; return channelValue;
    }

    function populatePitchShiftTicks() {
        pitchShiftTicksDatalist.innerHTML = '';
        const ticks = [-12, -9, -7, -5, -4, -3, 0, 3, 4, 5, 7, 9, 12];
        for (let i = -12; i <= 12; i++) { const option = document.createElement('option'); option.value = i; if (ticks.includes(i)) option.label = i.toString(); pitchShiftTicksDatalist.appendChild(option); }
    }

    function applyUISettings() {
        delaySlider.value = delayTimeSec;
        repeatsSlider.value = numberOfRepeats;
        pitchShiftSlider.value = pitchShiftPerRepeat;
        velocityScaleSlider.value = velocityChangePerRepeat;

        delayValueDisplay.textContent = delayTimeSec.toFixed(2);
        repeatsValueDisplay.textContent = numberOfRepeats;
        pitchShiftValueDisplay.textContent = pitchShiftPerRepeat;
        velocityScaleValueDisplay.textContent = velocityChangePerRepeat;

        if (midiInputSelect.options.length > 0 && selectedMidiInputId) {
            const inputOptionExists = Array.from(midiInputSelect.options).some(opt => opt.value === selectedMidiInputId);
            if (inputOptionExists) midiInputSelect.value = selectedMidiInputId;
        }
        if (midiOutputSelect.options.length > 0 && selectedMidiOutputId) {
            const outputOptionExists = Array.from(midiOutputSelect.options).some(opt => opt.value === selectedMidiOutputId);
            if (outputOptionExists) midiOutputSelect.value = selectedMidiOutputId;
        }
        midiChannelSelect.value = selectedInputChannel;
        midiOutputChannelSelect.value = selectedOutputChannel;

        updateStatusMessage();
    }

    function resetEffectSettings() {
        delayTimeSec = initialDefaults.delayTimeSec; numberOfRepeats = initialDefaults.numberOfRepeats;
        pitchShiftPerRepeat = initialDefaults.pitchShiftPerRepeat; velocityChangePerRepeat = initialDefaults.velocityChangePerRepeat;
        applyUISettings();
        nextEchoFireTime = 0; startCountdownTimer(); saveSettingsToLocalStorage();
    }

    function enableControls() {
        [delaySlider, repeatsSlider, pitchShiftSlider, velocityScaleSlider, midiInputSelect, midiChannelSelect, midiOutputSelect, midiOutputChannelSelect, resetEffectsButton, reInitMidiButton].forEach(el => el.disabled = !midiInitialized);
    }

    function updateStatusMessage() {
        if (!midiInitialized || !midiAccess) return;
        const inputObj = selectedMidiInputId ? midiAccess.inputs.get(selectedMidiInputId) : null;
        const outputObj = selectedMidiOutputId ? midiAccess.outputs.get(selectedMidiOutputId) : null;
        const inputName = inputObj ? (inputObj.name.length > 10 ? inputObj.name.substring(0,8) + '..' : inputObj.name) : 'No Input';
        const outputName = outputObj ? (outputObj.name.length > 10 ? outputObj.name.substring(0,8) + '..' : outputObj.name) : 'No Output';
        mainStatusMessages.textContent = `Input: ${inputName} (Ch ${selectedInputChannel + 1}) | Output: ${outputName} (Ch ${selectedOutputChannel + 1}) | Delay: ${delayTimeSec.toFixed(2)}s | Rep: ${numberOfRepeats} | Pitch: ${pitchShiftPerRepeat}st | Vel: ${velocityChangePerRepeat}`;
        updateLiveStatusBar();
    }

    reInitMidiButton.addEventListener('click', initializeMidiSystem);
    resetEffectsButton.addEventListener('click', resetEffectSettings);

    delaySlider.addEventListener('input', (event) => { delayTimeSec = parseFloat(event.target.value); updateDelayValueDisplay(); updateStatusMessage(); saveSettingsToLocalStorage(); });
    repeatsSlider.addEventListener('input', (event) => { numberOfRepeats = parseInt(event.target.value); repeatsValueDisplay.textContent = numberOfRepeats; updateStatusMessage(); saveSettingsToLocalStorage(); });
    pitchShiftSlider.addEventListener('input', (event) => { pitchShiftPerRepeat = parseInt(event.target.value); pitchShiftValueDisplay.textContent = pitchShiftPerRepeat; updateStatusMessage(); saveSettingsToLocalStorage(); });
    velocityScaleSlider.addEventListener('input', (event) => { velocityChangePerRepeat = parseInt(event.target.value); velocityScaleValueDisplay.textContent = velocityChangePerRepeat; updateStatusMessage(); saveSettingsToLocalStorage(); });

    midiInputSelect.addEventListener('change', (event) => { selectedMidiInputId = event.target.value; updateInputListeners(); saveSettingsToLocalStorage(); });
    midiChannelSelect.addEventListener('change', (event) => { selectedInputChannel = parseInt(event.target.value); if(midiInitialized) { updateStatusMessage(); } saveSettingsToLocalStorage(); });
    midiOutputSelect.addEventListener('change', (event) => { selectedMidiOutputId = event.target.value; if(midiInitialized) { updateStatusMessage(); } saveSettingsToLocalStorage(); });
    midiOutputChannelSelect.addEventListener('change', (event) => { selectedOutputChannel = parseInt(event.target.value); if(midiInitialized) { updateStatusMessage(); } saveSettingsToLocalStorage(); });

    document.addEventListener('DOMContentLoaded', () => {
        loadSettingsFromLocalStorage();
        selectedInputChannel = populateChannelSelect(midiChannelSelect, selectedInputChannel);
        selectedOutputChannel = populateChannelSelect(midiOutputChannelSelect, selectedOutputChannel);
        populatePitchShiftTicks();
        applyUISettings();
        initializeMidiSystem();
    });

    let originalBorderColor = '#414868';
    const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#7aa2f7';

    function showMidiActivityIndicator(isEcho) {
        if (mainStatusMessages.style.borderColor === '' || mainStatusMessages.style.borderColor === primaryColor) {
            originalBorderColor = getComputedStyle(mainStatusMessages).borderColor || '#414868';
        }
        const blinkColor = primaryColor;
        mainStatusMessages.style.borderColor = blinkColor;
        setTimeout(() => { mainStatusMessages.style.borderColor = originalBorderColor; }, 150);
    }
</script>
</body>
</html>
