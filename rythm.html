<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm King 77 - Websynth (MIDI Only)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #3a3a3a;
            color: #f0e6d2;
            overscroll-behavior: none;
            font-size: 12px;
        }
        .synth-panel {
            background-color: #5a4a3a;
            border: 2px solid #7a6a5a;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5), inset 0 2px 4px rgba(255,255,255,0.1);
            padding: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .toolbar {
            background-color: #2a2a2a;
            border: 2px solid #4a4a4a;
        }
        .control-slider-container {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .number-input-container {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .slider-button, .number-input-button {
            background-color: #7a6a5a;
            color: #f0e6d2;
            border: 1px solid #5a4a3a;
            border-radius: 4px;
            padding: 0.05rem 0.25rem;
            font-size: 0.75rem;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            user-select: none;
        }
        .slider-button:hover, .number-input-button:hover {
            background-color: #9a8a7a;
        }

        .control-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 17.5px;
            background: #4a3a2a;
            border-radius: 8.75px;
            border: 1px solid #3a2a1a;
            outline: none;
            cursor: pointer;
            flex-grow: 1;
        }
        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 30px;
            height: 30px;
            background: #c0b090;
            border-radius: 6.25px;
            border: 2px solid #3a2a1a;
            cursor: grab;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .control-slider::-moz-range-thumb {
            width: 30px;
            height: 30px;
            background: #c0b090;
            border-radius: 6.25px;
            border: 2px solid #3a2a1a;
            cursor: grab;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .master-control-panel .control-slider {
            height: 24px;
        }
        .master-control-panel .control-slider::-webkit-slider-thumb {
            width: 30px;
            height: 30px;
        }
        .master-control-panel .control-slider::-moz-range-thumb {
            width: 30px;
            height: 30px;
        }
        .push-button {
            font-family: 'Orbitron', sans-serif;
            background-color: #7a6a5a;
            color: #f0e6d2;
            border: 2px solid #5a4a3a;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            text-transform: uppercase;
            font-weight: bold;
            font-size: 0.7rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 1px rgba(255,255,255,0.2);
            transition: all 0.1s ease-in-out;
        }
        .push-button:disabled {
            background-color: #4a3a2a;
            color: #7a6a5a;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .push-button:active, .push-button.active {
            background-color: #9a8a7a;
            box-shadow: 0 1px 2px rgba(0,0,0,0.4), inset 0 2px 3px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }
        .utility-button {
            color: white;
            padding: 0.15rem 0.35rem;
            font-size: 0.6rem;
            border-radius: 3px;
            margin-left: 0.2rem;
        }
        .learn-cc-button { background-color: #D84315; }
        .randomize-button { background-color: #2196F3; }
        .default-settings-button { background-color: #607D8B; }
        .master-randomize-button { background-color: #FFC107; color: #333; }
        .re-init-midi-button { background-color: #9C27B0; }
        .pattern-button { background-color: #009688; }
        .learn-cc-button.learning { background-color: #FF9800; }

        .pattern-display {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0.5rem auto;
            height: 24px;
        }
        .pattern-step {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #7a6a5a;
            margin: 0 1.5px;
            transition: background-color 0.1s;
        }
        .pattern-step.active { background-color: #f0ad4e; }
        .pattern-step.current {
            transform: scale(1.5);
            box-shadow: 0 0 8px #f0ad4e;
        }
        label {
            display: block;
            margin-bottom: 0.1rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            font-family: 'Orbitron', sans-serif;
        }
        .label-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .label-text {
            flex-grow: 1;
        }

        select, input[type="number"], input[type="text"] {
            background-color: #4a3a2a;
            border: 1px solid #7a6a5a;
            color: #f0e6d2;
            padding: 0.3rem;
            border-radius: 5px;
            width: 100%;
            font-size: 0.75rem;
        }
        .master-control-panel select, .master-control-panel input[type="number"] {
            padding: 0.5rem 0.3rem;
        }
        .master-control-panel .number-input-container input[type="number"] {
            padding: 0.3rem;
            text-align: center;
            flex-grow: 1;
        }
        .note-input-container {
            width: 33%;
        }
        .value-display {
            font-family: 'Orbitron', sans-serif;
            color: #f0ad4e;
            font-size: 0.75rem;
            min-width: 25px;
            text-align: right;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 0.4rem;
        }
        .control-group > div:first-child {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.05rem;
        }

        #sequencerTracksContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: flex-start;
        }
        #sequencerTracksContainer.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        #sequencerTracksContainer > .synth-panel {
            flex: 1 1 260px;
            min-width: 250px;
            max-width: 380px;
            margin-bottom: 0;
        }
        #statusBar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #2a2a2a;
            color: #f0e6d2;
            padding: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #statusBar.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #statusBar > span {
            flex-grow: 1;
            text-align: center;
        }
        #noteDisplay {
            font-family: 'Orbitron', sans-serif;
            color: #f0ad4e;
            padding: 0 1rem;
            min-width: 100px;
            text-align: right;
        }
        .explanation-text-footer {
            font-size: 0.75rem;
            line-height: 1.4;
            color: #c0b090;
            text-align: center;
            padding: 1rem 0.5rem;
            max-width: 600px;
            margin: 1rem auto 0 auto;
        }
    </style>
</head>
<body class="p-1 md:p-2 pb-12">

<header class="text-center mb-2">
    <h1 class="text-2xl md:text-3xl font-bold" style="font-family: 'Orbitron', sans-serif; color: #f0ad4e;">Rhythm King 77</h1>
    <p class="text-xs md:text-sm">Euclidean MIDI Sequencer</p>
</header>

<div class="synth-panel toolbar mb-2">
    <div class="flex flex-wrap items-center justify-between gap-x-4 gap-y-2">
        <div class="flex items-center gap-x-2">
            <button id="playStopButton" class="push-button text-lg" title="Start or stop all sequences">‚ñ∂</button>
            <button id="lockStepsToggleButton" class="push-button" title="When active, all tracks share the same 'Steps' value">Lock Steps</button>
            <button id="masterRandomizeButton" class="push-button master-randomize-button" title="Randomize all active tracks">Rnd All</button>
            <button id="defaultSettingsButton" class="push-button default-settings-button" title="Load default patterns for all tracks">Defaults</button>
            <button id="reInitMidiButton" class="push-button re-init-midi-button text-lg" title="Re-initialize MIDI devices and send All Notes Off">üîå</button>
        </div>
        <div class="flex items-end gap-x-2 flex-wrap">
            <div class="control-group mb-0 flex-grow min-w-[150px]">
                <label for="patternNameInput">Pattern Name</label>
                <input type="text" id="patternNameInput" title="Enter a name to save the current pattern">
            </div>
            <button id="savePatternButton" class="push-button pattern-button text-lg" title="Save all current track settings as a new pattern">üíæ</button>
            <div class="control-group mb-0 flex-grow min-w-[150px]">
                <label for="savedPatternsSelect">Load/Delete Pattern</label>
                <select id="savedPatternsSelect" title="Select a saved pattern"></select>
            </div>
            <button id="loadPatternButton" class="push-button pattern-button text-lg" title="Load the selected pattern">üìÇ</button>
            <button id="deletePatternButton" class="push-button chain-button text-lg" title="Delete the selected pattern">üóëÔ∏è</button>
        </div>
    </div>
</div>


<div class="flex flex-col md:flex-row gap-2">
    <div class="md:flex-none md:max-w-xs synth-panel flex flex-col gap-2 master-control-panel">
        <h2 class="text-base font-semibold mb-1 text-center" style="font-family: 'Orbitron', sans-serif;">Master Control</h2>

        <div class="control-group">
            <div>
                <label for="swingSlider">Swing:</label>
                <span id="swingValue" class="value-display">0</span>%
            </div>
            <input type="range" id="swingSlider" min="0" max="75" value="0" step="1" class="control-slider" title="Adjust master swing amount">
        </div>

        <div class="control-group">
            <div>
                <label for="numTracksInput">Number of Tracks:</label>
            </div>
            <div class="number-input-container">
                <button class="number-input-button" data-target="numTracksInput" data-action="decrement" title="Decrease number of tracks">-</button>
                <input type="number" id="numTracksInput" min="1" max="8" value="4" title="Set number of sequencer tracks (1-8)">
                <button class="number-input-button" data-target="numTracksInput" data-action="increment" title="Increase number of tracks">+</button>
            </div>
        </div>

        <div class="control-group">
            <div class="label-container">
                <label for="bpmSlider">Tempo:</label>
                <div>
                    <span id="bpmValue" class="value-display">55</span>
                    <button id="bpmSliderLearnCc" class="learn-cc-button utility-button" data-param-id="bpmSlider" title="Map Master Tempo to a MIDI CC">LRN</button>
                </div>
            </div>
            <div class="control-slider-container">
                <button class="slider-button" data-target="bpmSlider" data-action="decrement" title="Decrease Tempo">-</button>
                <input type="range" id="bpmSlider" min="20" max="240" value="55" class="control-slider" title="Adjust master tempo (20-240 BPM)">
                <button class="slider-button" data-target="bpmSlider" data-action="increment" title="Increase Tempo">+</button>
            </div>
        </div>

        <div class="control-group">
            <label for="midiOutSelect">MIDI Output:</label>
            <select id="midiOutSelect" title="Select MIDI output device">
                <option value="">No MIDI Devices Found</option>
            </select>
        </div>
        <div class="control-group">
            <label for="midiChannelSelect">Global MIDI Ch:</label>
            <select id="midiChannelSelect" title="Select global MIDI channel (1-16)">
            </select>
        </div>
        <div class="mt-auto pt-1">
            <p class="text-xs text-center">User ID: <span id="userIdDisplay" class="font-mono"></span></p>
        </div>
    </div>

    <div class="flex-grow synth-panel">
        <h2 class="text-base font-semibold mb-2 text-center" style="font-family: 'Orbitron', sans-serif;">Euclidean Sequencer</h2>
        <div id="sequencerTracksContainer">
        </div>
    </div>
</div>

<div id="explanationContainer" class="explanation-text-footer">
    <p>
        Euclidean rhythms are musical rhythms generated by distributing a number of beats (pulses) as evenly as possible over a set number of time steps.
        This creates natural-sounding, often complex polyrhythms found in various world music traditions.
    </p>
</div>
<div id="statusBar">
    <span id="statusMessage">Status Message Here</span>
    <span id="noteDisplay">--</span>
</div>

<script>
    const playStopButton = document.getElementById('playStopButton');
    const defaultSettingsButton = document.getElementById('defaultSettingsButton');
    const masterRandomizeButton = document.getElementById('masterRandomizeButton');
    const reInitMidiButton = document.getElementById('reInitMidiButton');
    const numTracksInput = document.getElementById('numTracksInput');
    const lockStepsToggleButton = document.getElementById('lockStepsToggleButton');
    const bpmSlider = document.getElementById('bpmSlider');
    const bpmValue = document.getElementById('bpmValue');
    const swingSlider = document.getElementById('swingSlider');
    const swingValue = document.getElementById('swingValue');
    const bpmSliderLearnCc = document.getElementById('bpmSliderLearnCc');
    const midiOutSelect = document.getElementById('midiOutSelect');
    const midiChannelSelect = document.getElementById('midiChannelSelect');
    const sequencerTracksContainer = document.getElementById('sequencerTracksContainer');
    const userIdDisplay = document.getElementById('userIdDisplay');
    const statusBar = document.getElementById('statusBar');
    const statusMessage = document.getElementById('statusMessage');
    const noteDisplay = document.getElementById('noteDisplay');

    const patternNameInput = document.getElementById('patternNameInput');
    const savePatternButton = document.getElementById('savePatternButton');
    const savedPatternsSelect = document.getElementById('savedPatternsSelect');
    const loadPatternButton = document.getElementById('loadPatternButton');
    const deletePatternButton = document.getElementById('deletePatternButton');


    let midiAccess = null;
    let midiOutput = null;
    let selectedMidiChannel = 1;
    let numTracks = 4;
    const MAX_TRACKS = 8;
    let sequencerTracks = [];
    let transportLoops = [];
    let currentLearningControl = null;
    let midiCcMap = {};
    const NOTE_RANGE_FOR_RANDOM = Array.from({length: (72-36)+1}, (_, i) => 36 + i);
    const SETTINGS_KEY = 'rhythmKing77Settings_v11';
    const PATTERNS_KEY = 'rhythmKing77Patterns_v3';
    let statusTimeout = null;
    let stepsLocked = false;
    let globalLockedSteps = 16;
    let savedPatterns = {};

    let autoRepeatTimeoutId = null;
    let autoRepeatIntervalId = null;
    const AUTO_REPEAT_DELAY = 500;
    const AUTO_REPEAT_INTERVAL = 100;


    function showStatusMessage(message, duration = 3000) {
        statusMessage.textContent = message;
        statusBar.classList.add('visible');
        if (statusTimeout) clearTimeout(statusTimeout);
        statusTimeout = setTimeout(() => {
            statusBar.classList.remove('visible');
        }, duration);
    }

    function generateEuclideanPattern(pulses, steps) {
        if (pulses > steps || pulses <= 0 || steps <= 0) {
            return Array(steps).fill(0);
        }
        let pattern = [];
        let groups = [];
        for (let i = 0; i < steps; i++) {
            groups.push(i < pulses ? [1] : [0]);
        }

        let remainder = pulses;
        let divisor = steps - pulses;

        while (true) {
            if (divisor === 0 || remainder === 0) break;
            if (divisor > remainder) {
                [remainder, divisor] = [divisor, remainder];
                let onesGroups = [];
                let zerosGroups = [];
                groups.forEach(group => {
                    if(group.length > 0 && group[0] === 1) onesGroups.push(group); else zerosGroups.push(group);
                });
                groups = zerosGroups.concat(onesGroups);
            }
            if (remainder === 0) break;

            for (let i = 0; i < divisor; i++) {
                if (groups[i] && groups[remainder + i]) {
                    groups[i] = groups[i].concat(groups[remainder + i]);
                } else {
                    break;
                }
            }
            groups.splice(remainder, divisor);
            remainder = remainder - divisor;
            if (remainder === 0 && divisor > 0 && groups.length > divisor) {
                break;
            }
            if (divisor === 0) break;
        }
        pattern = [].concat(...groups);

        if (pattern.length !== steps) {
            if (pattern.length < steps) {
                pattern = pattern.concat(Array(steps - pattern.length).fill(0));
            } else {
                pattern = pattern.slice(0, steps);
            }
        }
        return pattern;
    }


    function rotatePattern(pattern, rotation) {
        const len = pattern.length;
        if (len === 0) return [];
        const r = ((rotation % len) + len) % len;
        return pattern.slice(r).concat(pattern.slice(0, r));
    }

    function updateLearnButtonTooltip(buttonElement, paramId) {
        if (!buttonElement) return;
        const mapping = midiCcMap[paramId];
        let baseTitle = buttonElement.dataset.baseTitle || buttonElement.title || `Map ${paramId.replace(/([A-Z])/g, ' $1').replace(/(\d+)/g, '')} to MIDI CC`;
        if (!buttonElement.dataset.baseTitle) buttonElement.dataset.baseTitle = baseTitle;

        if (mapping) {
            buttonElement.title = `${baseTitle} (Mapped: CC#${mapping.cc} Ch${mapping.channel})`;
        } else {
            buttonElement.title = baseTitle;
        }
    }


    function saveSettings() {
        const settings = {
            numTracks: numTracks,
            bpm: parseInt(bpmSlider.value),
            swing: parseFloat(swingSlider.value),
            midiOutputId: midiOutput ? midiOutput.id : null,
            globalMidiChannel: selectedMidiChannel,
            stepsLocked: stepsLocked,
            globalLockedSteps: globalLockedSteps,
            tracks: sequencerTracks.slice(0, numTracks).map(track => ({
                pulses: track.pulses,
                steps: track.steps,
                rotation: track.rotation,
                note: track.note,
                velocity: track.velocity,
                active: track.active
            })),
            midiCcMap: midiCcMap
        };
        try {
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        } catch (e) {
            console.error("Error saving settings to localStorage:", e);
            showStatusMessage("Error: Could not save settings.", 5000);
        }
    }

    function loadSettings() {
        const savedSettings = localStorage.getItem(SETTINGS_KEY);
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);

                if (settings.numTracks !== undefined && settings.numTracks >= 1 && settings.numTracks <= MAX_TRACKS) {
                    numTracks = settings.numTracks;
                } else {
                    numTracks = 4;
                }
                if (settings.bpm !== undefined) bpmSlider.value = settings.bpm;
                if (settings.swing !== undefined) swingSlider.value = settings.swing;
                if (settings.globalMidiChannel !== undefined) selectedMidiChannel = settings.globalMidiChannel;
                if (settings.stepsLocked !== undefined) stepsLocked = settings.stepsLocked;
                if (settings.globalLockedSteps !== undefined) globalLockedSteps = settings.globalLockedSteps;
                if (settings.midiCcMap) midiCcMap = settings.midiCcMap;

                return settings;
            } catch (e) {
                console.error("Error parsing saved settings:", e);
                localStorage.removeItem(SETTINGS_KEY);
                numTracks = 4;
                showStatusMessage("Error: Corrupted settings cleared. Defaults loaded.", 5000);
            }
        }
        numTracks = 4;
        return null;
    }


    async function setupMIDI() {
        try {
            if (!navigator.requestMIDIAccess) {
                showStatusMessage('Web MIDI API is not supported.');
                return;
            }
            if (midiAccess) {
                midiAccess.inputs.forEach(input => input.onmidimessage = null);
            }

            midiAccess = await navigator.requestMIDIAccess({ sysex: false });
            populateMidiDeviceList();
            midiAccess.addEventListener('statechange', populateMidiDeviceList);

            const inputs = midiAccess.inputs.values();
            for (let input of inputs) {
                input.onmidimessage = handleMidiMessage;
            }
            showStatusMessage("MIDI re-initialized.", 2000);
        } catch (err) {
            console.error('MIDI Access Error:', err);
            if (err.name === 'SecurityError') showStatusMessage('MIDI Access disabled by page security policy.');
            else showStatusMessage('MIDI Access Denied/Not Supported.');
        }
    }

    reInitMidiButton.addEventListener('click', async () => {
        showStatusMessage("Re-initializing MIDI...", 1500);
        if (midiOutput) {
            for (let i = 1; i <= 16; i++) {
                sendAllNotesOff(i);
            }
        }
        if (Tone.Transport.state === 'started') {
            playStopButton.click();
        }
        Tone.Transport.cancel(0);
        transportLoops.forEach(loop => { if (loop) { loop.stop(0); loop.dispose(); } });
        transportLoops = [];
        sequencerTracks.forEach(track => {
            track.currentStep = 0;
            track.stepCounterForUI = 0;
            renderPatternDisplay(track);
        });

        await setupMIDI();
    });


    function populateMidiDeviceList() {
        if (!midiAccess) return;

        const loadedSettings = JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}');
        const preferredOutputId = loadedSettings.midiOutputId || (midiOutput ? midiOutput.id : null);

        midiOutSelect.innerHTML = '';
        const outputs = midiAccess.outputs.values();
        let firstOutput = null;
        let count = 0;
        let foundPreferred = false;

        for (let output of outputs) {
            const option = document.createElement('option');
            option.value = output.id;
            option.textContent = output.name;
            midiOutSelect.appendChild(option);
            if (!firstOutput) firstOutput = output;
            if (output.id === preferredOutputId) {
                foundPreferred = true;
            }
            count++;
        }

        if (count === 0) {
            midiOutSelect.innerHTML = '<option value="">No MIDI Devices Found</option>';
            midiOutput = null;
        } else {
            if (foundPreferred && preferredOutputId) {
                midiOutSelect.value = preferredOutputId;
            } else if (firstOutput) {
                midiOutSelect.value = firstOutput.id;
            }
        }
        updateMidiOutput();
    }

    function updateUiForMidiStatus() {
        const hasValidOutput = midiOutput !== null;
        playStopButton.disabled = !hasValidOutput;
        if (hasValidOutput) {
            sequencerTracksContainer.classList.remove('disabled', 'opacity-50', 'pointer-events-none');
        } else {
            sequencerTracksContainer.classList.add('disabled', 'opacity-50', 'pointer-events-none');
            showStatusMessage("No MIDI output selected. Playback is disabled.", 5000);
        }
    }


    function updateMidiOutput() {
        if (!midiAccess || !midiOutSelect.value || midiOutSelect.value === "") {
            midiOutput = null;
        } else {
            midiOutput = midiAccess.outputs.get(midiOutSelect.value);
        }
        updateUiForMidiStatus();
    }
    midiOutSelect.addEventListener('change', () => {
        const oldMidiOutputId = midiOutput ? midiOutput.id : null;
        updateMidiOutput();
        if (oldMidiOutputId && oldMidiOutputId !== (midiOutput ? midiOutput.id : null)) {
            const oldOutputDevice = midiAccess.outputs.get(oldMidiOutputId);
            if (oldOutputDevice) {
                setTimeout(() => {
                    const allNotesOffMessage = [0xB0 + (selectedMidiChannel - 1), 123, 0];
                    oldOutputDevice.send(allNotesOffMessage);
                }, 50);
            }
        }
        saveSettings();
    });

    function sendMidiNoteOn(note, velocity, channel) {
        if (!midiOutput) return;
        midiOutput.send([0x90 + (channel - 1), note, velocity]);
        noteDisplay.textContent = Tone.Frequency(note, 'midi').toNote();
    }

    function sendMidiNoteOff(note, channel) {
        if (!midiOutput) return;
        midiOutput.send([0x80 + (channel - 1), note, 0]);
    }

    function sendAllNotesOff(channel) {
        if (!midiOutput) return;
        midiOutput.send([0xB0 + (channel - 1), 123, 0]);
    }


    function handleMidiMessage(event) {
        const [command, ccNumber, ccValue] = event.data;
        if (command >= 0xB0 && command <= 0xBF) {
            const midiChannel = (command & 0x0F) + 1;
            if (currentLearningControl) {
                const paramId = currentLearningControl.paramId;
                midiCcMap[paramId] = { cc: ccNumber, channel: midiChannel };
                currentLearningControl.button.classList.remove('learning');
                currentLearningControl.button.textContent = 'LRN';
                updateLearnButtonTooltip(currentLearningControl.button, paramId);
                currentLearningControl = null;
                const readableParamId = paramId
                    .replace(/([A-Z])/g, ' $1')
                    .replace(/(\d+)/g, ' Track $1')
                    .replace(/^./, str => str.toUpperCase());
                showStatusMessage(`${readableParamId} mapped to CC#${ccNumber} on Ch ${midiChannel}.`);
                saveSettings();
            } else {
                for (const paramId in midiCcMap) {
                    const mapping = midiCcMap[paramId];
                    if (mapping.cc === ccNumber && mapping.channel === midiChannel) {
                        const controlElement = document.getElementById(paramId);
                        if (controlElement) {
                            const min = parseFloat(controlElement.min) || 0;
                            const max = parseFloat(controlElement.max) || 127;
                            const step = parseFloat(controlElement.step) || 1;
                            let newValue;
                            if (controlElement.type === 'range' || controlElement.type === 'number') {
                                newValue = min + ( ( (max - min) * ccValue ) / 127 );
                                newValue = Math.round(newValue / step) * step;
                                newValue = Math.max(min, Math.min(max, newValue));
                                controlElement.value = newValue;
                            } else if (controlElement.tagName === 'SELECT') {
                                const numOptions = controlElement.options.length;
                                const optionIndex = Math.floor((ccValue / 127) * (numOptions -1));
                                controlElement.selectedIndex = Math.max(0, Math.min(numOptions -1, optionIndex));
                                newValue = controlElement.value;
                            }
                            const eventType = (controlElement.tagName === 'SELECT') ? 'change' : 'input';
                            controlElement.dispatchEvent(new Event(eventType, { bubbles: true }));
                        }
                    }
                }
            }
        }
    }

    function startLearnCc(paramId, buttonElement) {
        if (currentLearningControl) {
            currentLearningControl.button.classList.remove('learning');
            currentLearningControl.button.textContent = 'LRN';
            updateLearnButtonTooltip(currentLearningControl.button, currentLearningControl.paramId);
        }
        currentLearningControl = { paramId, button: buttonElement };
        buttonElement.classList.add('learning');
        buttonElement.textContent = '...';
        const readableParamId = paramId
            .replace(/([A-Z])/g, ' $1')
            .replace(/(\d+)/g, ' Track $1')
            .replace(/^./, str => str.toUpperCase());
        showStatusMessage(`Listening for MIDI CC for ${readableParamId}. Move a control.`);
    }

    function setupTransport() {
        Tone.Transport.bpm.value = parseInt(bpmSlider.value);
        Tone.Transport.swing = parseFloat(swingSlider.value) / 100;
        Tone.Transport.swingSubdivision = "16n";
    }

    function startAutoRepeat(targetId, action) {
        stopAutoRepeat();
        adjustControlValue(targetId, action);
        autoRepeatTimeoutId = setTimeout(() => {
            autoRepeatIntervalId = setInterval(() => {
                adjustControlValue(targetId, action);
            }, AUTO_REPEAT_INTERVAL);
        }, AUTO_REPEAT_DELAY);
    }

    function stopAutoRepeat() {
        if (autoRepeatTimeoutId) clearTimeout(autoRepeatTimeoutId);
        if (autoRepeatIntervalId) clearInterval(autoRepeatIntervalId);
        autoRepeatTimeoutId = null;
        autoRepeatIntervalId = null;
    }

    function adjustControlValue(targetId, action) {
        const control = document.getElementById(targetId);
        if (!control) return;
        let currentValue = parseFloat(control.value);
        const step = parseFloat(control.step) || 1;
        const min = parseFloat(control.min);
        const max = parseFloat(control.max);

        if (action === 'increment') {
            currentValue = Math.min(max, currentValue + step);
        } else if (action === 'decrement') {
            currentValue = Math.max(min, currentValue - step);
        }
        control.value = currentValue;
        const eventType = (targetId === 'numTracksInput') ? 'change' : 'input';
        control.dispatchEvent(new Event(eventType, { bubbles: true }));
    }

    document.addEventListener('mousedown', (event) => {
        if (event.target.matches('.slider-button') || event.target.matches('.number-input-button')) {
            const targetId = event.target.dataset.target;
            const action = event.target.dataset.action;
            startAutoRepeat(targetId, action);
        }
    });
    document.addEventListener('mouseup', stopAutoRepeat);
    document.addEventListener('mouseleave', (event) => {
        if (event.target.matches('.slider-button') || event.target.matches('.number-input-button')) {
            stopAutoRepeat();
        }
    });
    document.addEventListener('touchstart', (event) => {
        if (event.target.matches('.slider-button') || event.target.matches('.number-input-button')) {
            event.preventDefault();
            const targetId = event.target.dataset.target;
            const action = event.target.dataset.action;
            startAutoRepeat(targetId, action);
        }
    }, { passive: false });
    document.addEventListener('touchend', stopAutoRepeat);
    document.addEventListener('touchcancel', stopAutoRepeat);



    bpmSlider.addEventListener('input', (e) => {
        const newBpm = parseInt(e.target.value);
        Tone.Transport.bpm.value = newBpm;
        bpmValue.textContent = newBpm;
        saveSettings();
    });

    if (bpmSliderLearnCc) {
        bpmSliderLearnCc.addEventListener('click', () => startLearnCc('bpmSlider', bpmSliderLearnCc));
    }

    swingSlider.addEventListener('input', (e) => {
        const newSwing = parseFloat(e.target.value);
        Tone.Transport.swing = newSwing / 100;
        swingValue.textContent = Math.round(newSwing);
        saveSettings();
    });


    function randomizeTrackParameters(track) {
        track.pulses = Math.floor(Math.random() * track.steps) + 1;
        if (track.pulses > track.steps) track.pulses = track.steps;
        if (track.pulses === 0 && track.steps > 0) track.pulses = 1;

        track.rotation = track.steps > 0 ? Math.floor(Math.random() * track.steps) : 0;

        const randomNoteIndex = Math.floor(Math.random() * NOTE_RANGE_FOR_RANDOM.length);
        track.note = NOTE_RANGE_FOR_RANDOM[randomNoteIndex];

        track.ui.pulsesSlider.value = track.pulses;
        track.ui.pulsesValue.textContent = track.pulses;
        track.ui.rotationSlider.value = track.rotation;
        track.ui.rotationValue.textContent = track.rotation;
        track.ui.noteInput.value = Tone.Frequency(track.note, "midi").toNote();

        updateTrackPattern(track);
    }

    masterRandomizeButton.addEventListener('click', () => {
        sequencerTracks.forEach(track => {
            if(track.active) {
                randomizeTrackParameters(track);
            }
        });
        saveSettings();
        showStatusMessage("All active tracks randomized!");
    });


    function applyDefaultSettings() {
        const defaultTrackSettings = [
            { pulses: 4, steps: 16, rotation: 0, note: Tone.Frequency("C3").toMidi(), velocity: 100, active: true },
            { pulses: 3, steps: 16, rotation: 2, note: Tone.Frequency("E3").toMidi(), velocity: 100, active: true },
            { pulses: 5, steps: 16, rotation: 1, note: Tone.Frequency("G#3").toMidi(), velocity: 90, active: true },
            { pulses: 7, steps: 16, rotation: 3, note: Tone.Frequency("B3").toMidi(), velocity: 80, active: true }
        ];

        const defaultSteps = stepsLocked ? globalLockedSteps : 16;


        sequencerTracks.forEach((track, index) => {
            const defaults = defaultTrackSettings[index % defaultTrackSettings.length];
            track.pulses = defaults.pulses;
            track.steps = defaultSteps;
            track.rotation = defaults.rotation % track.steps;
            track.note = defaults.note;
            track.velocity = defaults.velocity;
            track.active = defaults.active;

            track.ui.pulsesSlider.value = track.pulses;
            track.ui.pulsesValue.textContent = track.pulses;
            track.ui.stepsSlider.value = track.steps;
            track.ui.stepsValue.textContent = track.steps;
            track.ui.stepsSlider.min = track.pulses > track.steps ? track.steps : track.pulses;
            if (track.pulses > track.steps) {
                track.pulses = track.steps > 0 ? track.steps : 1;
                track.ui.pulsesSlider.value = track.pulses;
                track.ui.pulsesValue.textContent = track.pulses;
            }

            track.ui.rotationSlider.max = track.steps > 0 ? track.steps - 1 : 0;
            track.ui.rotationSlider.value = track.rotation;
            track.ui.rotationValue.textContent = track.rotation;
            track.ui.noteInput.value = Tone.Frequency(track.note, "midi").toNote();
            track.ui.velocitySlider.value = track.velocity;
            track.ui.velocityValue.textContent = track.velocity;
            track.ui.toggleButton.textContent = track.active ? 'ON' : 'OFF';
            track.ui.toggleButton.classList.toggle('active', track.active);

            updateTrackPattern(track);
        });
        saveSettings();
        showStatusMessage("Default patterns loaded for all tracks.");
    }
    defaultSettingsButton.addEventListener('click', applyDefaultSettings);

    lockStepsToggleButton.addEventListener('click', () => {
        stepsLocked = !stepsLocked;
        lockStepsToggleButton.classList.toggle('active', stepsLocked);
        if (stepsLocked) {
            lockStepsToggleButton.textContent = "Steps Locked";
            globalLockedSteps = sequencerTracks.length > 0 ? sequencerTracks[0].steps : 16;
            synchronizeAllTrackSteps(globalLockedSteps);
        } else {
            lockStepsToggleButton.textContent = "Lock Steps";
            sequencerTracks.forEach(track => {
                if (track.ui && track.ui.stepsSlider) track.ui.stepsSlider.disabled = false;
                track.ui.stepsSlider.min = track.pulses;
                track.ui.rotationSlider.max = track.steps > 0 ? track.steps - 1 : 0;
            });
        }
        saveSettings();
        showStatusMessage(stepsLocked ? `Steps Locked to ${globalLockedSteps}` : "Steps Unlocked");
    });

    function synchronizeAllTrackSteps(newStepsValue) {
        globalLockedSteps = newStepsValue;
        sequencerTracks.forEach(track => {
            track.steps = newStepsValue;
            if (track.ui && track.ui.stepsSlider) {
                track.ui.stepsSlider.value = newStepsValue;
                track.ui.stepsValue.textContent = newStepsValue;
                track.ui.stepsSlider.disabled = stepsLocked;

                if (track.pulses > track.steps) {
                    track.pulses = track.steps > 0 ? track.steps : 1;
                    track.ui.pulsesSlider.value = track.pulses;
                    track.ui.pulsesValue.textContent = track.pulses;
                }
                track.ui.stepsSlider.min = track.pulses;

                track.ui.rotationSlider.max = track.steps > 0 ? track.steps - 1 : 0;
                if (track.rotation >= track.steps) {
                    track.rotation = track.steps > 0 ? track.rotation % track.steps : 0;
                    track.ui.rotationSlider.value = track.rotation;
                    track.ui.rotationValue.textContent = track.rotation;
                }
                updateTrackPattern(track);
            }
        });
        saveSettings();
    }


    function createSequencerTrackUI(trackIndex) {
        let initialSteps = stepsLocked ? globalLockedSteps : 16;
        let initialRotation = Math.floor(Math.random() * initialSteps);
        let initialPulses = Math.floor(Math.random() * initialSteps / 2) + 1;
        if (initialPulses === 0 && initialSteps > 0) initialPulses = 1;
        if (initialPulses > initialSteps) initialPulses = initialSteps;


        const trackDiv = document.createElement('div');
        trackDiv.className = 'synth-panel p-2';
        trackDiv.id = `track-panel-${trackIndex}`;
        trackDiv.innerHTML = `
            <div class="flex justify-between items-center mb-1">
                <h3 class="text-xs font-semibold" style="font-family: 'Orbitron', sans-serif;">Track ${trackIndex + 1}</h3>
                <div>
                    <button id="randomizeTrack${trackIndex}" class="randomize-button utility-button" title="Randomize Pulses, Rotate, and Note for this track">Rnd</button>
                    <button id="trackToggle${trackIndex}" class="push-button text-xs py-1 px-2 ml-1" title="Toggle this track ON or OFF">ON</button>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-x-2 gap-y-1">
                <div class="control-group mb-0">
                    <div class="label-container"><label for="steps${trackIndex}">‚ò∑ Steps:</label><button class="learn-cc-button utility-button" data-param-id="steps${trackIndex}" title="Map Steps to MIDI CC">LRN</button><span id="stepsValue${trackIndex}" class="value-display">${initialSteps}</span></div>
                    <div class="control-slider-container">
                        <button class="slider-button" data-target="steps${trackIndex}" data-action="decrement" title="Decrease Steps">-</button>
                        <input type="range" id="steps${trackIndex}" min="1" max="32" value="${initialSteps}" class="control-slider" title="Total steps in the sequence">
                        <button class="slider-button" data-target="steps${trackIndex}" data-action="increment" title="Increase Steps">+</button>
                    </div>
                </div>
                <div class="control-group mb-0">
                    <div class="label-container"><label for="pulses${trackIndex}">‚ô´ Pulses:</label><button class="learn-cc-button utility-button" data-param-id="pulses${trackIndex}" title="Map Pulses to MIDI CC">LRN</button><span id="pulsesValue${trackIndex}" class="value-display">${initialPulses}</span></div>
                    <div class="control-slider-container">
                        <button class="slider-button" data-target="pulses${trackIndex}" data-action="decrement" title="Decrease Pulses">-</button>
                        <input type="range" id="pulses${trackIndex}" min="1" max="32" value="${initialPulses}" class="control-slider" title="Number of active beats (pulses)">
                        <button class="slider-button" data-target="pulses${trackIndex}" data-action="increment" title="Increase Pulses">+</button>
                    </div>
                </div>
                <div class="control-group mb-0">
                    <div class="label-container"><label for="rotation${trackIndex}">‚Üª Rotate:</label><button class="learn-cc-button utility-button" data-param-id="rotation${trackIndex}" title="Map Rotate to MIDI CC">LRN</button><span id="rotationValue${trackIndex}" class="value-display">${initialRotation}</span></div>
                    <div class="control-slider-container">
                        <button class="slider-button" data-target="rotation${trackIndex}" data-action="decrement" title="Decrease Rotation">-</button>
                        <input type="range" id="rotation${trackIndex}" min="0" max="${initialSteps > 0 ? initialSteps -1 : 0}" value="${initialRotation}" class="control-slider" title="Rotate the pattern offset">
                        <button class="slider-button" data-target="rotation${trackIndex}" data-action="increment" title="Increase Rotation">+</button>
                    </div>
                </div>
                 <div class="control-group mb-0">
                    <div class="label-container"><label for="note${trackIndex}">‚ô™ Note:</label><button class="learn-cc-button utility-button" data-param-id="note${trackIndex}" title="Map Note to MIDI CC">LRN</button></div>
                    <input type="text" id="note${trackIndex}" value="${['C3', 'E3', 'G3', 'B3'][trackIndex % 4]}" class="text-xs p-1" title="MIDI note for this track (e.g., C4, F#3)">
                </div>
            </div>
            <div id="patternDisplay${trackIndex}" class="pattern-display mt-2"></div>
        `;
        sequencerTracksContainer.appendChild(trackDiv);

        const track = {
            id: trackIndex, active: true, pulses: initialPulses, steps: initialSteps, rotation: initialRotation,
            note: Tone.Frequency(['C3', 'E3', 'G3', 'B3'][trackIndex % 4]).toMidi(),
            velocity: 100, pattern: [], currentStep: 0,
            stepCounterForUI: 0,
            ui: {
                toggleButton: document.getElementById(`trackToggle${trackIndex}`),
                randomizeButton: document.getElementById(`randomizeTrack${trackIndex}`),
                pulsesSlider: document.getElementById(`pulses${trackIndex}`),
                pulsesValue: document.getElementById(`pulsesValue${trackIndex}`),
                stepsSlider: document.getElementById(`steps${trackIndex}`),
                stepsValue: document.getElementById(`stepsValue${trackIndex}`),
                rotationSlider: document.getElementById(`rotation${trackIndex}`),
                rotationValue: document.getElementById(`rotationValue${trackIndex}`),
                noteInput: document.getElementById(`note${trackIndex}`),
                patternDisplay: document.getElementById(`patternDisplay${trackIndex}`),
            }
        };
        const randomNoteIndex = Math.floor(Math.random() * NOTE_RANGE_FOR_RANDOM.length);
        track.note = NOTE_RANGE_FOR_RANDOM[randomNoteIndex];
        track.ui.noteInput.value = Tone.Frequency(track.note, "midi").toNote();


        track.ui.randomizeButton.addEventListener('click', () => randomizeTrackParameters(track));

        track.ui.toggleButton.addEventListener('click', () => {
            track.active = !track.active;
            track.ui.toggleButton.textContent = track.active ? 'ON' : 'OFF';
            track.ui.toggleButton.classList.toggle('active', track.active);
            if (!track.active) {
                sendMidiNoteOff(track.note, selectedMidiChannel);
                track.currentStep = 0;
                track.stepCounterForUI = 0;
                renderPatternDisplay(track);
            }
            saveSettings();
        });
        track.ui.pulsesSlider.addEventListener('input', (e) => {
            track.pulses = parseInt(e.target.value);
            track.ui.pulsesValue.textContent = track.pulses;

            const currentTrackSteps = stepsLocked ? globalLockedSteps : track.steps;
            if (track.pulses > currentTrackSteps) {
                track.pulses = currentTrackSteps > 0 ? currentTrackSteps : 1;
                e.target.value = track.pulses;
                track.ui.pulsesValue.textContent = track.pulses;
            }
            track.ui.stepsSlider.min = track.pulses;
            updateTrackPattern(track);
            saveSettings();
        });
        track.ui.stepsSlider.addEventListener('input', (e) => {
            const newSteps = parseInt(e.target.value);
            if (stepsLocked) {
                synchronizeAllTrackSteps(newSteps);
            } else {
                track.steps = newSteps;
                if (track.steps < track.pulses) {
                    track.steps = track.pulses;
                    e.target.value = track.steps;
                }
                track.ui.stepsValue.textContent = track.steps;
                track.ui.rotationSlider.max = track.steps > 0 ? track.steps -1 : 0;
                if (track.rotation >= track.steps && track.steps > 0) {
                    track.rotation = 0;
                    track.ui.rotationSlider.value = 0;
                    track.ui.rotationValue.textContent = 0;
                } else if (track.steps === 0) {
                    track.rotation = 0;
                    track.ui.rotationSlider.value = 0;
                    track.ui.rotationValue.textContent = 0;
                }
                updateTrackPattern(track);
            }
            saveSettings();
        });
        track.ui.rotationSlider.addEventListener('input', (e) => {
            track.rotation = parseInt(e.target.value);
            track.ui.rotationValue.textContent = track.rotation;
            updateTrackPattern(track);
            saveSettings();
        });
        track.ui.noteInput.addEventListener('change', (e) => {
            try {
                track.note = Tone.Frequency(e.target.value.toUpperCase()).toMidi();
            } catch {
                showStatusMessage(`Invalid note: ${e.target.value}. Using previous.`);
                e.target.value = Tone.Frequency(track.note, "midi").toNote();
            }
            saveSettings();
        });

        trackDiv.querySelectorAll('.learn-cc-button').forEach(btn => {
            btn.addEventListener('click', () => startLearnCc(btn.dataset.paramId, btn));
            updateLearnButtonTooltip(btn, btn.dataset.paramId);
        });

        sequencerTracks.push(track);
    }

    function updateTrackPattern(track) {
        track.pattern = generateEuclideanPattern(track.pulses, track.steps);
        track.pattern = rotatePattern(track.pattern, track.rotation);
        track.stepCounterForUI = 0;
        track.currentStep = 0;
        renderPatternDisplay(track);
        setupTrackLoop(track);
    }

    function renderPatternDisplay(track) {
        if (!track || !track.ui || !track.ui.patternDisplay) return;
        const display = track.ui.patternDisplay;
        display.innerHTML = '';
        if (track.steps === 0 || !track.pattern) return;

        for (let i = 0; i < track.steps; i++) {
            const stepDiv = document.createElement('div');
            stepDiv.className = 'pattern-step';

            if (track.pattern && i < track.pattern.length && track.pattern[i] === 1) {
                stepDiv.classList.add('active');
            }
            if (i === track.currentStep && Tone.Transport.state === "started" && track.active) {
                stepDiv.classList.add('current');
            }
            display.appendChild(stepDiv);
        }
    }

    function setupTrackLoop(track) {
        if (transportLoops[track.id]) {
            transportLoops[track.id].stop(0);
            transportLoops[track.id].dispose();
        }
        if (track.steps === 0 || !track.pattern || track.pattern.length === 0) {
            renderPatternDisplay(track);
            return;
        }

        track.stepCounterForUI = 0;
        track.currentStep = 0;

        const subdivision = "16n";
        const stepDurationSeconds = Tone.Time(subdivision).toSeconds();

        const sequence = new Tone.Sequence((time, value) => {
            if (track.active && value === 1) {
                sendMidiNoteOn(track.note, track.velocity, selectedMidiChannel);
                Tone.Transport.scheduleOnce(() => {
                    sendMidiNoteOff(track.note, selectedMidiChannel);
                }, time + stepDurationSeconds * 0.80);
            }
            track.currentStep = track.stepCounterForUI;
            renderPatternDisplay(track);
            track.stepCounterForUI = (track.stepCounterForUI + 1) % track.steps;
        }, track.pattern, subdivision).start(0);

        sequence.loop = true;

        transportLoops[track.id] = sequence;
    }

    function regenerateAllTracks(newCount) {
        const oldTrackCount = sequencerTracks.length;
        numTracks = parseInt(newCount);
        if (isNaN(numTracks) || numTracks < 1) numTracks = 1;
        if (numTracks > MAX_TRACKS) numTracks = MAX_TRACKS;
        numTracksInput.value = numTracks;

        if (newCount > oldTrackCount) {
            for (let i = oldTrackCount; i < newCount; i++) {
                createSequencerTrackUI(i);
                updateTrackPattern(sequencerTracks[i]);
            }
        } else if (newCount < oldTrackCount) {
            for (let i = oldTrackCount - 1; i >= newCount; i--) {
                if (transportLoops[i]) {
                    transportLoops[i].stop(0).dispose();
                }
                const trackPanel = document.getElementById(`track-panel-${i}`);
                if (trackPanel) trackPanel.remove();
            }
            sequencerTracks.length = newCount;
            transportLoops.length = newCount;
        }

        if (stepsLocked) synchronizeAllTrackSteps(globalLockedSteps);
        saveSettings();
    }


    numTracksInput.addEventListener('change', (e) => {
        let newCount = parseInt(e.target.value);
        if (isNaN(newCount) || newCount < 1) newCount = 1;
        if (newCount > MAX_TRACKS) newCount = MAX_TRACKS;
        e.target.value = newCount;

        if (newCount !== numTracks) {
            regenerateAllTracks(newCount);
        }
    });


    playStopButton.addEventListener('click', async () => {
        if (playStopButton.disabled) return;
        if (Tone.Transport.state === 'started') {
            transportLoops.forEach(loop => {
                if (loop) loop.stop(0);
            });
            Tone.Transport.stop();
            Tone.Transport.cancel(0);
            sendAllNotesOff(selectedMidiChannel);

            sequencerTracks.forEach(t => {
                t.currentStep = 0;
                t.stepCounterForUI = 0;
                renderPatternDisplay(t);
            });
            playStopButton.textContent = '‚ñ∂';
            playStopButton.classList.remove('active');
        } else {
            try {
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                }
                sequencerTracks.forEach(t => {
                    t.currentStep = 0;
                    t.stepCounterForUI = 0;
                    if (transportLoops[t.id]) {
                        transportLoops[t.id].progress = 0;
                        transportLoops[t.id].start(0);
                    }
                    renderPatternDisplay(t);
                });
                Tone.Transport.start();
                playStopButton.textContent = '‚ñ†';
                playStopButton.classList.add('active');
            } catch (e) {
                console.error("Error starting Tone.js transport: ", e);
                showStatusMessage("Error starting audio/transport.", 5000);
            }
        }
    });

    midiChannelSelect.addEventListener('change', (e) => {
        const oldChannel = selectedMidiChannel;
        const newChannel = parseInt(e.target.value);

        if (oldChannel !== newChannel) {
            sendAllNotesOff(oldChannel);
            selectedMidiChannel = newChannel;
            saveSettings();
        }
    });

    for (let i = 1; i <= 16; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Ch ${i}`;
        midiChannelSelect.appendChild(option);
    }

    function loadPatterns() {
        const storedPatterns = localStorage.getItem(PATTERNS_KEY);
        if (storedPatterns) {
            savedPatterns = JSON.parse(storedPatterns);
        }
        updatePatternLists();
    }

    function saveCurrentPattern() {
        const name = patternNameInput.value.trim();
        if (!name) {
            showStatusMessage("Please enter a pattern name.", 3000);
            return;
        }
        savedPatterns[name] = sequencerTracks.map(track => ({
            pulses: track.pulses,
            steps: track.steps,
            rotation: track.rotation,
            note: track.note,
            velocity: track.velocity,
            active: track.active
        }));
        localStorage.setItem(PATTERNS_KEY, JSON.stringify(savedPatterns));
        updatePatternLists();
        showStatusMessage(`Pattern "${name}" saved!`, 3000);
    }

    function loadSelectedPattern() {
        const name = savedPatternsSelect.value;
        if (name && savedPatterns[name]) {
            const patternData = savedPatterns[name];
            if (patternData.length !== numTracks) {
                regenerateAllTracks(patternData.length);
            }

            sequencerTracks.forEach((track, index) => {
                const savedTrack = patternData[index];
                if (savedTrack) {
                    track.pulses = savedTrack.pulses;
                    track.steps = savedTrack.steps;
                    track.rotation = savedTrack.rotation;
                    track.note = savedTrack.note;
                    track.velocity = savedTrack.velocity;
                    track.active = savedTrack.active;

                    track.ui.pulsesSlider.value = track.pulses;
                    track.ui.pulsesValue.textContent = track.pulses;
                    track.ui.stepsSlider.value = track.steps;
                    track.ui.stepsValue.textContent = track.steps;
                    track.ui.rotationSlider.value = track.rotation;
                    track.ui.rotationValue.textContent = track.rotation;
                    track.ui.noteInput.value = Tone.Frequency(track.note, "midi").toNote();
                    track.ui.toggleButton.textContent = track.active ? 'ON' : 'OFF';
                    track.ui.toggleButton.classList.toggle('active', track.active);

                    updateTrackPattern(track);
                }
            });
            showStatusMessage(`Pattern "${name}" loaded.`, 3000);
            patternNameInput.value = name;
            saveSettings();
        }
    }

    function deleteSelectedPattern() {
        const name = savedPatternsSelect.value;
        if (name && savedPatterns[name]) {
            delete savedPatterns[name];
            localStorage.setItem(PATTERNS_KEY, JSON.stringify(savedPatterns));
            updatePatternLists();
            showStatusMessage(`Pattern "${name}" deleted.`, 3000);
        }
    }

    function updatePatternLists() {
        savedPatternsSelect.innerHTML = '';
        Object.keys(savedPatterns).sort().forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            savedPatternsSelect.appendChild(option);
        });
    }

    savePatternButton.addEventListener('click', saveCurrentPattern);
    loadPatternButton.addEventListener('click', loadSelectedPattern);
    deletePatternButton.addEventListener('click', deleteSelectedPattern);


    async function init() {
        const userId = crypto.randomUUID();
        userIdDisplay.textContent = userId.substring(0,8);

        bpmSlider.value = 55;
        bpmValue.textContent = '55';

        const loadedSettings = loadSettings();

        numTracksInput.value = numTracks;
        bpmSlider.value = parseInt(bpmSlider.value);
        swingValue.textContent = Math.round(swingSlider.value);
        Tone.Transport.bpm.value = parseInt(bpmSlider.value);
        bpmValue.textContent = bpmSlider.value;
        lockStepsToggleButton.classList.toggle('active', stepsLocked);
        lockStepsToggleButton.textContent = stepsLocked ? "Steps Locked" : "Lock Steps";
        midiChannelSelect.value = selectedMidiChannel;


        sequencerTracks = [];
        sequencerTracksContainer.innerHTML = '';
        for (let i = 0; i < numTracks; i++) {
            createSequencerTrackUI(i);
        }

        if (loadedSettings && loadedSettings.tracks) {
            loadedSettings.tracks.forEach((savedTrack, index) => {
                if (index < numTracks && sequencerTracks[index]) {
                    const track = sequencerTracks[index];
                    track.pulses = savedTrack.pulses ?? track.pulses;
                    track.steps = stepsLocked ? globalLockedSteps : (savedTrack.steps ?? globalLockedSteps);

                    if (track.pulses > track.steps) track.pulses = track.steps > 0 ? track.steps : 1;

                    track.rotation = savedTrack.rotation ?? track.rotation;
                    if (track.steps > 0) track.rotation %= track.steps; else track.rotation = 0;

                    track.note = savedTrack.note ?? track.note;
                    track.velocity = savedTrack.velocity ?? 100;
                    track.active = savedTrack.active ?? track.active;

                    track.ui.pulsesSlider.value = track.pulses;
                    track.ui.pulsesValue.textContent = track.pulses;
                    track.ui.stepsSlider.value = track.steps;
                    track.ui.stepsValue.textContent = track.steps;
                    track.ui.stepsSlider.min = track.pulses;
                    track.ui.rotationSlider.max = track.steps > 0 ? track.steps - 1 : 0;
                    track.ui.rotationSlider.value = track.rotation;
                    track.ui.rotationValue.textContent = track.rotation;
                    track.ui.noteInput.value = Tone.Frequency(track.note, "midi").toNote();
                    track.ui.toggleButton.textContent = track.active ? 'ON' : 'OFF';
                    track.ui.toggleButton.classList.toggle('active', track.active);
                }
            });
        }

        if (bpmSliderLearnCc) updateLearnButtonTooltip(bpmSliderLearnCc, 'bpmSlider');
        sequencerTracks.forEach(track => {
            track.ui.randomizeButton.parentElement.parentElement.querySelectorAll('.learn-cc-button').forEach(btn => {
                updateLearnButtonTooltip(btn, btn.dataset.paramId);
            });
        });

        sequencerTracks.forEach(track => updateTrackPattern(track));
        await setupMIDI();

        if (loadedSettings && loadedSettings.midiOutputId) {
            if (Array.from(midiOutSelect.options).some(opt => opt.value === loadedSettings.midiOutputId)) {
                midiOutSelect.value = loadedSettings.midiOutputId;
            }
            updateMidiOutput();
        } else if (midiOutSelect.options.length > 0 && midiOutSelect.options[0].value !== "") {
            midiOutSelect.value = midiOutSelect.options[0].value;
            updateMidiOutput();
        }

        setupTransport();

        loadPatterns();

        if (!loadedSettings) {
            applyDefaultSettings();
        } else if (stepsLocked) {
            synchronizeAllTrackSteps(globalLockedSteps);
        }

        showStatusMessage("Rhythm King 77 Initialized!", 3000);
    }
    window.onload = init;
</script>
</body>
</html>
